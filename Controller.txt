=== include/can_plc.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include "charger_config.hpp"
#include "hardware_interface.hpp"

#include <atomic>
#include <algorithm>
#include <cstdint>
#include <chrono>
#include <cstddef>
#include <map>
#include <mutex>
#include <optional>
#include <set>
#include <thread>
#include <vector>

#ifdef __linux__
#include <linux/can.h>
#else
constexpr uint32_t CAN_EFF_FLAG = 0x80000000U;
constexpr uint32_t CAN_EFF_MASK = 0x1FFFFFFFU;
#endif

namespace charger {

constexpr uint32_t PLC_TX_MASK = 0xFFFFFFF0;

struct PlcFilterSpec {
    uint32_t id{0};
    uint32_t mask{0};
};

inline uint8_t plc_crc8(const uint8_t* data, size_t len) {
    uint8_t crc = 0x00;
    for (size_t i = 0; i < len; ++i) {
        crc ^= data[i];
        for (int b = 0; b < 8; ++b) {
            crc = (crc & 0x80) ? static_cast<uint8_t>((crc << 1) ^ 0x07) : static_cast<uint8_t>(crc << 1);
        }
    }
    return crc;
}

inline PlcFilterSpec make_plc_rx_filter(uint32_t base, int plc_id) {
    PlcFilterSpec spec{};
    const uint32_t base_mask = (PLC_TX_MASK | 0x0F | CAN_EFF_FLAG) & (CAN_EFF_MASK | CAN_EFF_FLAG);
    spec.mask = base_mask;
    spec.id = (base & PLC_TX_MASK) | static_cast<uint32_t>(plc_id & 0x0F) | CAN_EFF_FLAG;
    return spec;
}

struct PlcSafetyStatus {
    bool safety_ok{false};
    bool estop{false};
    bool earth_fault{false};
    bool comm_fault{false};
    bool remote_force_off{false};
};

struct PlcMeterSnapshot {
    double voltage_v{0.0};
    double current_a{0.0};
    double power_w{0.0};
    double energy_Wh{0.0};
    double freq_hz{0.0};
    bool ok{false};
    bool stale{true};
};

struct PlcCpStatus {
    char state_char{'U'};
    double duty_pct{0.0};
    uint16_t mv_peak{0};
    uint16_t mv_min{0};
    uint16_t mv_robust{0};
    bool valid{false};
    std::chrono::steady_clock::time_point last_rx{};
};

struct PlcStatus {
    bool relay_closed{false};
    bool sys_enabled{false};
    uint8_t last_cmd_seq{0};
    uint8_t relay_state_mask{0};
    uint8_t last_fault_reason{0};
    uint8_t hlc_stage{0};
    bool hlc_charge_complete{false};
    bool hlc_precharge_active{false};
    bool hlc_cable_check_ok{false};
    bool hlc_power_ready{false};
    PlcSafetyStatus safety;
    PlcSafetyStatus pending_safety;
    std::chrono::steady_clock::time_point pending_safety_since{};
    PlcMeterSnapshot meter;
    PlcCpStatus cp;
    double target_voltage_v{0.0};
    double target_current_a{0.0};
    double present_voltage_v{0.0};
    double present_current_a{0.0};
    double present_power_w{0.0};
    double max_voltage_v{0.0};
    double max_current_a{0.0};
    double max_power_kw{0.0};
    uint32_t limit_ack_count{0};
    std::chrono::steady_clock::time_point last_limit_ack{};
    std::chrono::steady_clock::time_point last_meter_rx{};
    std::chrono::steady_clock::time_point last_relay_status{};
    std::chrono::steady_clock::time_point last_safety_status{};
    std::chrono::steady_clock::time_point last_any_rx{};
    uint32_t session_epoch{0};
    bool auth_pending_flag{false};
    uint32_t rx_count{0};
    uint32_t tx_count{0};
    uint32_t uptime_s{0};
    uint8_t fw_major{0};
    uint8_t fw_minor{0};
    uint8_t fw_patch{0};
    uint8_t feature_flags{0};
    uint8_t error_code{0};
};

/// \brief PLC/CAN-backed implementation of HardwareInterface using the DBC in Ref/Basic/docs/CAN_DBC.dbc.
class PlcHardware : public HardwareInterface {
public:
    explicit PlcHardware(const ChargerConfig& cfg, bool open_can = true);
    ~PlcHardware() override;

    bool enable(std::int32_t connector) override;
    bool disable(std::int32_t connector) override;
    bool pause_charging(std::int32_t connector) override;
    bool resume_charging(std::int32_t connector) override;
    bool stop_transaction(std::int32_t connector, ocpp::v16::Reason reason) override;
    ocpp::v16::UnlockStatus unlock(std::int32_t connector) override;
    ocpp::v16::ReservationStatus reserve(std::int32_t reservation_id, std::int32_t connector, ocpp::DateTime expiry,
                                         const std::string& id_tag,
                                         const std::optional<std::string>& parent_id) override;
    bool cancel_reservation(std::int32_t reservation_id) override;
    void apply_power_allocation(std::int32_t connector, int modules) override;

    ocpp::v16::GetLogResponse upload_diagnostics(const ocpp::v16::GetDiagnosticsRequest& request) override;
    ocpp::v16::GetLogResponse upload_logs(const ocpp::v16::GetLogRequest& request) override;
    void update_firmware(const ocpp::v16::UpdateFirmwareRequest& request) override;
    ocpp::v16::UpdateFirmwareStatusEnumType
    update_firmware_signed(const ocpp::v16::SignedUpdateFirmwareRequest& request) override;

    void set_connection_timeout(std::int32_t seconds) override;
    bool is_reset_allowed(const ocpp::v16::ResetType& reset_type) override;
    void reset(const ocpp::v16::ResetType& reset_type) override;

    void on_remote_start_token(const std::string& id_token,
                               const std::vector<std::int32_t>& referenced_connectors, bool prevalidated) override;

    ocpp::Measurement sample_meter(std::int32_t connector) override;
    GunStatus get_status(std::int32_t connector) override;
    void set_authorization_state(std::int32_t connector, bool authorized) override;
    void set_authorization_state(std::int32_t connector, AuthorizationState state) override;
    void apply_power_command(const PowerCommand& cmd) override;
    std::vector<AuthToken> poll_auth_tokens() override;
    bool supports_cross_slot_islands() const override;
    void set_evse_limits(std::int32_t connector, const EvseLimits& limits) override;
    void publish_evse_present(std::int32_t connector, double voltage_v, double current_a,
                              double power_kw, bool output_enabled, bool regulating) override;
    void publish_fault_state(std::int32_t connector, uint8_t fault_bits) override;
    /// \brief Inject a CAN frame directly (bypasses socket RX) for replay/testing.
    void ingest_can_frame(uint32_t can_id, const uint8_t* data, size_t len);
    void ingest_can_frame(uint32_t can_id, const std::vector<uint8_t>& data) {
        ingest_can_frame(can_id, data.data(), data.size());
    }

private:
    struct SegmentBuffer {
        uint8_t total_len{0};
        uint8_t expected_segments{0};
        std::vector<uint8_t> data;
        std::vector<bool> received;
        std::chrono::steady_clock::time_point last_rx{};
        void reset(uint8_t len, uint8_t segments, const std::chrono::steady_clock::time_point& now) {
            total_len = len;
            expected_segments = std::max<uint8_t>(static_cast<uint8_t>(1), segments);
            data.assign(total_len, 0);
            received.assign(expected_segments, false);
            last_rx = now;
        }
        bool complete() const {
            return !data.empty() && expected_segments > 0 &&
                   received.size() >= expected_segments &&
                   std::all_of(received.begin(), received.begin() + expected_segments, [](bool v) { return v; });
        }
    };

    struct Node {
        ConnectorConfig cfg;
        PlcStatus status;
        uint8_t cmd_seq{0};
        uint8_t expected_cmd_seq{0};
        bool awaiting_ack{false};
        std::chrono::steady_clock::time_point last_cmd_sent{};
        int retry_count{0};
        bool last_cmd_close{false};
        bool last_force_all_off{false};
        bool mc_closed_cmd{true};
        bool gc_closed_cmd{false};
        uint8_t module_mask{0x00}; // bit0: gun, bit1: module1, bit2: module2
        double energy_fallback_Wh{0.0};
        std::chrono::steady_clock::time_point last_energy_update{};
        bool meter_fallback_active{false};
        bool lock_engaged{true};
        bool lock_feedback_engaged{true};
        bool crc_mode_mismatch{false};
        bool crc_mode_mismatch_logged{false};
        bool crc_fault_logged{false};
        bool bus_off_logged{false};
        bool authorization_granted{false};
        uint8_t gcmc_cmd_seq{0};
        double last_limit_voltage_v{0.0};
        double last_limit_current_a{0.0};
        double last_limit_power_kw{0.0};
        uint64_t limit_tx_count{0};
        uint64_t limit_tx_fail{0};
        AuthorizationState authorization_state{AuthorizationState::Unknown};
        std::chrono::steady_clock::time_point last_auth_push{};
        uint64_t auth_push_count{0};
        uint8_t fault_bits{0};
        std::chrono::steady_clock::time_point last_fault_update{};
        std::chrono::steady_clock::time_point last_evse_present_tx{};
        std::chrono::steady_clock::time_point last_evse_limits_tx{};
        uint64_t present_stale_events{0};
        uint64_t limit_stale_events{0};
        uint64_t relay_conflict_count{0};
        std::map<uint8_t, SegmentBuffer> rfid_events;
        SegmentBuffer evccid;
        SegmentBuffer emaid0;
        SegmentBuffer emaid1;
        SegmentBuffer evmac;
    };

    std::map<std::int32_t, Node> nodes_; // keyed by connector id; one node per CAN iface (enforced in config)
    std::map<int, std::int32_t> plc_to_connector_;
    std::string iface_;
    bool use_crc8_{false};
    bool module_relays_enabled_{true};
    bool gun_relay_owned_by_plc_{true};
    int present_warn_ms_{1000};
    int limits_warn_ms_{1500};
    bool require_https_uploads_{true};
    std::size_t upload_max_bytes_{100 * 1024 * 1024};
    int upload_connect_timeout_s_{10};
    int upload_transfer_timeout_s_{60};
    bool upload_allow_file_targets_{true};
    int sock_{-1};
    std::atomic<bool> restart_requested_{false};
    std::atomic<bool> running_{false};
    std::thread rx_thread_;
    std::mutex mtx_;
    std::vector<AuthToken> auth_events_;
    std::set<uint32_t> unknown_can_ids_;
    bool module_relays_disabled_logged_{false};
    bool cadence_warn_logged_{false};

    bool open_socket();
    void restart_can();
    void rx_loop();
    void handle_frame(uint32_t can_id, const uint8_t* data, size_t len);
    void handle_relay_status(Node& node, const uint8_t* data, size_t len);
    void handle_safety_status(Node& node, const uint8_t* data, size_t len);
    void handle_meter(Node& node, const uint8_t* data, size_t len);
    void handle_cp_levels(Node& node, const uint8_t* data, size_t len);
    void handle_charging_session(Node& node, const uint8_t* data, size_t len);
    void handle_evac_control(Node& node, const uint8_t* data, size_t len);
    void handle_evdc_targets(Node& node, const uint8_t* data, size_t len);
    void handle_evdc_limits(Node& node, const uint8_t* data, size_t len);
    void handle_ev_status_display(Node& node, const uint8_t* data, size_t len);
    void handle_charge_info(Node& node, const uint8_t* data, size_t len);
    void handle_gcmc_status(Node& node, const uint8_t* data, size_t len);
    void handle_hw_status(Node& node, const uint8_t* data, size_t len);
    void handle_debug_info(Node& node, const uint8_t* data, size_t len);
    void handle_boot_config(Node& node, const uint8_t* data, size_t len);
    void handle_rtev_log(Node& node, const uint8_t* data, size_t len);
    void handle_rtt_log(Node& node, const uint8_t* data, size_t len);
    void handle_software_info(Node& node, const uint8_t* data, size_t len);
    void handle_error_codes(Node& node, const uint8_t* data, size_t len);
    void handle_hw_config(Node& node, const uint8_t* data, size_t len);
    void handle_rfid_event(Node& node, const uint8_t* data, size_t len);
    void handle_identity_segment(Node& node, SegmentBuffer& buffer, AuthTokenSource source, const uint8_t* data,
                                 size_t len);
    void prune_segment_buffers(Node& node, const std::chrono::steady_clock::time_point& now);
    void send_evse_limits(Node& node, const EvseLimits& limits);
    void send_evse_present(Node& node, double voltage_v, double current_a, double power_kw,
                           bool output_enabled, bool regulating);
    void refresh_authorization_locked(Node& node, const std::chrono::steady_clock::time_point& now, bool force);
    void update_fault_bits(Node& node, uint8_t fault_bits, const std::chrono::steady_clock::time_point& now);
    bool send_config_command(Node& node, uint8_t param_id, uint32_t value);
#ifdef __linux__
    void handle_error_frame(const struct can_frame& frame);
#endif

    bool send_relay_command(Node& node, bool close, bool force_all_off = false);
    bool send_gcmc_command(Node& node, uint8_t seq, bool close, bool force_all_off);
    bool send_frame(uint32_t can_id, const uint8_t* data, size_t len);
    Node* find_node(std::int32_t connector);
    Node* find_node_by_plc(int plc_id);
    void update_cp_status(Node& node, char cp_state_char, uint8_t duty_pct, uint16_t mv_peak = 0,
                          uint16_t mv_min = 0, bool has_mv = false, uint16_t mv_robust = 0,
                          bool has_robust = false);
    void update_hlc_state(Node& node, uint8_t stage, uint8_t flags);
    bool derive_lock_input(const Node& node, uint8_t sw_mask_byte, bool relay_status_frame) const;
    bool derive_hlc_power_ready(const PlcStatus& status, bool authorized) const;
};

} // namespace charger


=== include/charger_config.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include <cstddef>
#include <filesystem>
#include <string>
#include <vector>

namespace charger {

namespace fs = std::filesystem;

struct ConnectorConfig {
    int id{1};
    int plc_id{0};                 // PLC node id (low nibble in command IDs)
    std::string can_interface;     // Optional CAN iface override per connector (e.g. "can0")
    double max_current_a{0};
    double max_power_w{0};
    double max_voltage_v{0};
    double min_voltage_v{0};
    int meter_sample_interval_s{0};
    std::string label;
    bool require_lock{true};
    int lock_input_switch{3};       // Which PLC switch input indicates lock engaged (1-4)
    std::string meter_source{"plc"}; // "plc" (default) or "shunt"
    double meter_scale{1.0};        // Calibration multiplier for meter/shunt readings
    double meter_offset_wh{0.0};    // Calibration offset applied to imported energy
};

struct ModuleConfig {
    std::string id;
    std::string mn_id;
    std::string type;           // e.g. "maxwell-mxr"
    std::string can_interface;  // optional override for module CAN bus
    int address{-1};            // module address on the bus (0-63 for Maxwell)
    int group{0};               // optional module group number
    double rated_power_kw{0.0}; // optional per-module power rating
    double rated_current_a{0.0}; // optional per-module current rating
    int poll_interval_ms{500};
    int cmd_interval_ms{500};
    bool broadcast{false};
};

struct SlotMapping {
    int id{0};
    int gun_id{0};
    std::string gc_id;
    std::string mc_id;
    int cw_id{0};
    int ccw_id{0};
    std::vector<ModuleConfig> modules;
};

struct SecurityConfig {
    fs::path csms_ca_bundle;
    fs::path mo_ca_bundle;
    fs::path v2g_ca_bundle;
    fs::path client_cert_dir;
    fs::path client_key_dir;
    fs::path secc_cert_dir;
    fs::path secc_key_dir;
};

struct ChargerConfig {
    std::string charge_point_id;
    std::string vendor;
    std::string model;
    std::string firmware_version;
    std::string central_system_uri;
    std::string can_interface; // Default CAN interface for PLC nodes (e.g. "can0")
    bool use_plc{false};
    bool simulation_mode{false}; // If true, suppress comm faults and run purely simulated hardware
    bool plc_backend_available{false}; // Set at runtime when PLC backend actually initialized
    bool plc_use_crc8{true};
    bool plc_owns_gun_relay{true}; // When true, controller will not command GC relay; PLC owns it
    bool plc_module_relays_enabled{true}; // Allow PLC module relay control; disable when external module drivers used
    bool require_https_uploads{true};
    double module_power_kw{30.0};
    double grid_limit_kw{1000.0};
    double default_voltage_v{800.0};
    bool allow_cross_slot_islands{false};
    int max_modules_per_gun{2};
    int min_modules_per_active_gun{1};
    int max_island_radius{6};
    int min_module_hold_ms{1000};
    int min_mc_hold_ms{1000};
    int min_gc_hold_ms{500};
    double mc_open_current_a{1.0};
    double gc_open_current_a{1.0};
    std::size_t upload_max_bytes{100 * 1024 * 1024}; // 100 MB safety cap
    int upload_connect_timeout_s{10};
    int upload_transfer_timeout_s{60};
    bool upload_allow_file_targets{true};
    double precharge_voltage_tolerance_v{50.0};
    int precharge_timeout_ms{2000};
    int auth_wait_timeout_s{1800};
    int power_request_timeout_s{60};
    int evse_limit_ack_timeout_ms{1500};
    int telemetry_timeout_ms{2000};
    int plc_present_warn_ms{1000};
    int plc_limits_warn_ms{1500};
    int minimum_status_duration_s{0};
    int meter_keepalive_s{300};
    std::string ocpp_config_inline; // Preferred inline OCPP base config JSON (single source)

    fs::path ocpp_config;
    fs::path share_path;
    fs::path user_config;
    fs::path database_dir;
    fs::path sql_migrations;
    fs::path message_log_path;
    fs::path logging_config;

    SecurityConfig security;
    int meter_sample_interval_s{30};
    std::vector<ConnectorConfig> connectors;
    std::vector<SlotMapping> slots; // optional explicit topology map for ring/modules
};

/// \brief Load charger.json and populate a ChargerConfig with absolute paths.
ChargerConfig load_charger_config(const fs::path& config_path);

/// \brief Load the base OCPP config JSON and patch dynamic values (ids, URI, connector count).
std::string load_and_patch_ocpp_config(const ChargerConfig& cfg);

} // namespace charger


=== include/hardware_interface.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include <chrono>
#include <optional>
#include <cstdint>
#include <array>
#include <string>
#include <vector>

#include <ocpp/common/types.hpp>
#include <ocpp/v16/messages/GetDiagnostics.hpp>
#include <ocpp/v16/messages/GetLog.hpp>
#include <ocpp/v16/messages/SignedUpdateFirmware.hpp>
#include <ocpp/v16/messages/UpdateFirmware.hpp>

namespace charger {

enum class AuthTokenSource { RFID, Autocharge, RemoteStart };

enum class AuthorizationState {
    Unknown,
    Pending,
    Granted,
    Denied
};

struct AuthToken {
    std::string id_token;
    AuthTokenSource source{AuthTokenSource::RFID};
    int connector_hint{0}; // 0 => no preference
    bool prevalidated{false};
    std::chrono::steady_clock::time_point received_at{std::chrono::steady_clock::now()};
};

struct GunStatus {
    bool safety_ok{true};
    bool estop{false};
    bool earth_fault{false};
    bool comm_fault{false};
    bool isolation_fault{false};
    bool overtemp_fault{false};
    bool overcurrent_fault{false};
    bool relay_closed{false};
    bool meter_stale{false};
    bool plugged_in{false};
    bool cp_fault{false};
    bool lock_engaged{true};
    bool authorization_granted{false};
    char cp_state{'U'};
    uint8_t hlc_stage{0};
    bool hlc_cable_check_ok{false};
    bool hlc_precharge_active{false};
    bool hlc_charge_complete{false};
    bool hlc_power_ready{false};
    double pilot_duty_pct{0.0};
    std::optional<double> target_voltage_v;
    std::optional<double> target_current_a;
    std::optional<double> present_voltage_v;
    std::optional<double> present_current_a;
    std::optional<double> present_power_w;
    std::optional<double> evse_max_voltage_v;
    std::optional<double> evse_max_current_a;
    std::optional<double> evse_max_power_kw;
    std::chrono::steady_clock::time_point last_telemetry{};
    uint8_t module_healthy_mask{0x00}; // bit0=module0, bit1=module1, etc. Slot-local ordering.
    uint8_t module_fault_mask{0x00};   // bitmask mirroring module_healthy_mask for detected faults/welds
    bool gc_welded{false};
    bool mc_welded{false};
    double connector_temp_c{0.0};
    std::array<double, 2> module_temp_c{{0.0, 0.0}};
    uint32_t evse_limit_ack_count{0};
    std::chrono::steady_clock::time_point last_evse_limit_ack{};
    uint64_t present_stale_events{0};
    uint64_t limit_stale_events{0};
    uint64_t auth_push_count{0};
    uint64_t relay_conflict_count{0};
};

/// \brief Planner dispatch toward hardware (per connector).
struct PowerCommand {
    std::int32_t connector{0};
    int module_count{0};
    uint8_t module_mask{0}; // bit0 -> slot module[0], bit1 -> slot module[1], etc.
    bool gc_closed{false};
    bool mc_closed{false};
    double voltage_set_v{0.0};
    double current_limit_a{0.0};
    double power_kw{0.0};
};

struct EvseLimits {
    std::optional<double> max_voltage_v;
    std::optional<double> max_current_a;
    std::optional<double> max_power_kw;
};

/// \brief Abstract interface your EVSE controller should implement.
class HardwareInterface {
public:
    virtual ~HardwareInterface() = default;

    virtual bool enable(std::int32_t connector) = 0;
    virtual bool disable(std::int32_t connector) = 0;
    virtual bool pause_charging(std::int32_t connector) = 0;
    virtual bool resume_charging(std::int32_t connector) = 0;
    virtual bool stop_transaction(std::int32_t connector, ocpp::v16::Reason reason) = 0;
    virtual ocpp::v16::UnlockStatus unlock(std::int32_t connector) = 0;
    virtual ocpp::v16::ReservationStatus reserve(std::int32_t reservation_id, std::int32_t connector,
                                                 ocpp::DateTime expiry, const std::string& id_tag,
                                                 const std::optional<std::string>& parent_id) = 0;
    virtual bool cancel_reservation(std::int32_t reservation_id) = 0;

    virtual ocpp::v16::GetLogResponse upload_diagnostics(const ocpp::v16::GetDiagnosticsRequest& request) = 0;
    virtual ocpp::v16::GetLogResponse upload_logs(const ocpp::v16::GetLogRequest& request) = 0;
    virtual void update_firmware(const ocpp::v16::UpdateFirmwareRequest& request) = 0;
    virtual ocpp::v16::UpdateFirmwareStatusEnumType
    update_firmware_signed(const ocpp::v16::SignedUpdateFirmwareRequest& request) = 0;

    virtual void set_connection_timeout(std::int32_t seconds) = 0;
    virtual bool is_reset_allowed(const ocpp::v16::ResetType& reset_type) = 0;
    virtual void reset(const ocpp::v16::ResetType& reset_type) = 0;

    virtual void on_remote_start_token(const std::string& id_token,
                                       const std::vector<std::int32_t>& referenced_connectors, bool prevalidated) = 0;

    /// \brief Return the latest meter sample for the connector.
    virtual ocpp::Measurement sample_meter(std::int32_t connector) = 0;

    /// \brief Return latest safety/comm/meter state for the connector.
    virtual GunStatus get_status(std::int32_t connector) = 0;

    /// \brief Notify hardware/PLC that authorization has been granted or revoked for the connector.
    /// Implementations that do not need this can keep the default no-op.
    virtual void set_authorization_state(std::int32_t connector, bool authorized) {
        set_authorization_state(connector, authorized ? AuthorizationState::Granted : AuthorizationState::Denied);
    }

    /// \brief Extended authorization state hook that supports Pending/Denied semantics.
    /// Default implementation falls back to the legacy bool-based hook.
    virtual void set_authorization_state(std::int32_t connector, AuthorizationState state) {
        set_authorization_state(connector, state == AuthorizationState::Granted);
    }

    /// \brief Apply computed power allocation (modules, contactors, setpoints) for the connector.
    /// Default fallbacks map to the older apply_power_allocation + enable/disable calls.
    virtual void apply_power_command(const PowerCommand& cmd) {
        if (cmd.module_count <= 0 || !cmd.gc_closed) {
            apply_power_allocation(cmd.connector, 0);
            disable(cmd.connector);
            return;
        }
        apply_power_allocation(cmd.connector, cmd.module_count);
        enable(cmd.connector);
    }

    /// \brief Apply computed power allocation (module count / enable) for the connector.
    /// Implementations may no-op if unsupported.
    virtual void apply_power_allocation(std::int32_t connector, int modules) { (void)connector; (void)modules; }

    /// \brief Publish EVSE-side limits (what the EV should be told via PLC/ISO15118).
    /// Default is a no-op for hardware that does not support dynamic limit injection.
    virtual void set_evse_limits(std::int32_t connector, const EvseLimits& limits) {
        (void)connector;
        (void)limits;
    }

    /// \brief Publish measured/present EVSE output to the communications front-end (e.g., PLC).
    /// Default is a no-op for hardware that does not support feeding measurements back to the PLC.
    virtual void publish_evse_present(std::int32_t connector, double voltage_v, double current_a,
                                      double power_kw, bool output_enabled, bool regulating) {
        (void)connector;
        (void)voltage_v;
        (void)current_a;
        (void)power_kw;
        (void)output_enabled;
        (void)regulating;
    }

    /// \brief Publish EVSE-side fault bitmask toward the communications front-end.
    /// Bits are transport-specific; default is a no-op for hardware that does not forward faults.
    virtual void publish_fault_state(std::int32_t connector, uint8_t fault_bits) {
        (void)connector;
        (void)fault_bits;
    }

    /// \brief Drain any auth tokens (RFID/Autocharge/etc.) detected by the hardware since the last poll.
    /// Default implementation returns an empty list.
    virtual std::vector<AuthToken> poll_auth_tokens() { return {}; }

    /// \brief Capability flag: can this hardware switch modules across slots/islands.
    virtual bool supports_cross_slot_islands() const { return false; }
};

} // namespace charger


=== include/hardware_sim.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include "charger_config.hpp"
#include "hardware_interface.hpp"

#include <chrono>
#include <map>
#include <mutex>
#include <optional>
#include <array>

namespace charger {

/// \brief Simple in-process hardware stub so OCPP flows can be exercised without real EVSE hardware.
class SimulatedHardware : public HardwareInterface {
public:
    struct FaultOverride {
        bool estop{false};
        bool earth_fault{false};
        bool isolation_fault{false};
        bool overtemp_fault{false};
        bool overcurrent_fault{false};
        bool comm_fault{false};
        bool gc_welded{false};
        bool mc_welded{false};
        bool paused{false};
        bool disabled{false};
        std::optional<uint8_t> healthy_mask;
        std::optional<uint8_t> fault_mask;
        std::optional<double> connector_temp_c;
        std::array<double, 2> module_temp_c{{0.0, 0.0}};
    };

    explicit SimulatedHardware(const ChargerConfig& cfg);
    ~SimulatedHardware() override = default;

    bool enable(std::int32_t connector) override;
    bool disable(std::int32_t connector) override;
    bool pause_charging(std::int32_t connector) override;
    bool resume_charging(std::int32_t connector) override;
    bool stop_transaction(std::int32_t connector, ocpp::v16::Reason reason) override;
    ocpp::v16::UnlockStatus unlock(std::int32_t connector) override;
    ocpp::v16::ReservationStatus reserve(std::int32_t reservation_id, std::int32_t connector, ocpp::DateTime expiry,
                                         const std::string& id_tag,
                                         const std::optional<std::string>& parent_id) override;
    bool cancel_reservation(std::int32_t reservation_id) override;
    ocpp::v16::GetLogResponse upload_diagnostics(const ocpp::v16::GetDiagnosticsRequest& request) override;
    ocpp::v16::GetLogResponse upload_logs(const ocpp::v16::GetLogRequest& request) override;
    void update_firmware(const ocpp::v16::UpdateFirmwareRequest& request) override;
    ocpp::v16::UpdateFirmwareStatusEnumType
    update_firmware_signed(const ocpp::v16::SignedUpdateFirmwareRequest& request) override;
    void set_connection_timeout(std::int32_t seconds) override;
    bool is_reset_allowed(const ocpp::v16::ResetType& reset_type) override;
    void reset(const ocpp::v16::ResetType& reset_type) override;
    void on_remote_start_token(const std::string& id_token, const std::vector<std::int32_t>& referenced_connectors,
                               bool prevalidated) override;
    ocpp::Measurement sample_meter(std::int32_t connector) override;
    GunStatus get_status(std::int32_t connector) override;
    void set_authorization_state(std::int32_t connector, bool authorized) override;
    void set_authorization_state(std::int32_t connector, AuthorizationState state) override;
    void apply_power_command(const PowerCommand& cmd) override;
    void apply_power_allocation(std::int32_t connector, int modules) override;
    void set_evse_limits(std::int32_t connector, const EvseLimits& limits) override;
    void publish_fault_state(std::int32_t connector, uint8_t fault_bits) override;
    std::vector<AuthToken> poll_auth_tokens() override;
    bool supports_cross_slot_islands() const override;

    // Simulation controls for tests/harnesses
    void set_fault_override(std::int32_t connector, const FaultOverride& fault);
    void clear_fault_override(std::int32_t connector);
    void set_paused(std::int32_t connector, bool paused);
    void set_disabled(std::int32_t connector, bool disabled);
    void set_plugged_in(std::int32_t connector, bool plugged, bool lock_engaged = true);
    void set_ev_power_request(std::int32_t connector, bool request);
    void inject_auth_token(const AuthToken& token);
    void set_status_override(std::int32_t connector, const GunStatus& status);
    void clear_status_override(std::int32_t connector);

private:
    struct ConnectorState {
        ConnectorConfig config;
        bool enabled{true};
        bool charging{false};
        bool reserved{false};
        std::optional<std::int32_t> reservation_id;
        double target_power_w{0.0};
        double energy_Wh{0.0};
        bool plugged_in{true};
        bool request_power{false};
        bool lock_engaged{true};
        bool authorized{false};
        AuthorizationState auth_state{AuthorizationState::Unknown};
        std::chrono::steady_clock::time_point last_update;
        EvseLimits evse_limits;
    };

    std::mutex mutex_;
    std::map<std::int32_t, ConnectorState> connectors_;
    bool require_https_uploads_{true};
    std::size_t upload_max_bytes_{100 * 1024 * 1024};
    int upload_connect_timeout_s_{10};
    int upload_transfer_timeout_s_{60};
    bool upload_allow_file_targets_{true};
    std::map<std::int32_t, FaultOverride> fault_overrides_;
    std::vector<AuthToken> auth_events_;
    std::map<std::int32_t, std::optional<GunStatus>> status_override_;

    ConnectorState& get_state(std::int32_t connector);
    void update_energy(ConnectorState& state);
};

} // namespace charger


=== include/island_manager.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include "power_manager.hpp"

#include <map>
#include <set>
#include <vector>

namespace charger {

struct IslandInfo {
    std::vector<int> slots;           // contiguous slots in this island
    std::vector<std::string> open_mcs; // MC ids that bound this island
};

/// \brief Pure software helper to reason about ring segments and islands given MC open/closed states.
class IslandManager {
public:
    IslandManager() = default;
    explicit IslandManager(std::vector<Slot> slots);

    void set_slots(std::vector<Slot> slots);
    void set_mc_states(const std::map<std::string, ContactorState>& mc_states);

    /// \brief Compute island groupings of slots based on MC open boundaries.
    std::vector<IslandInfo> compute_islands() const;

private:
    std::vector<Slot> slots_;
    std::map<std::string, ContactorState> mc_states_;
    std::map<int, Slot> slot_lookup_;
};

} // namespace charger


=== include/ocpp_adapter.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include "charger_config.hpp"
#include "hardware_interface.hpp"
#include "power_manager.hpp"
#include "power_module_controller.hpp"

#include <atomic>
#include <chrono>
#include <deque>
#include <map>
#include <memory>
#include <optional>
#include <thread>
#include <mutex>
#include <filesystem>

#include <everest/logging.hpp>
#include <ocpp/v16/charge_point.hpp>

namespace charger {

enum class ConnectorState { Available, Preparing, Charging, SuspendedEV, SuspendedEVSE, Finishing, Faulted };

class OcppAdapter {
public:
    OcppAdapter(ChargerConfig cfg, std::shared_ptr<HardwareInterface> hardware);
    ~OcppAdapter();

    bool start();
    void stop();

    bool begin_transaction(std::int32_t connector, const std::string& id_token, bool prevalidated = false,
                           ocpp::SessionStartedReason reason = ocpp::SessionStartedReason::Authorized);
    void finish_transaction(std::int32_t connector, ocpp::v16::Reason reason,
                            std::optional<ocpp::CiString<20>> id_tag_end = std::nullopt);

    void push_meter_values(std::int32_t connector, const ocpp::Measurement& measurement);
    void report_fault(std::int32_t connector, const ocpp::v16::ErrorInfo& info);
    void clear_faults(std::int32_t connector);

private:
    struct ActiveSession {
        std::string session_id;
        std::optional<std::string> id_token;
        double meter_start_wh{0.0};
        std::chrono::steady_clock::time_point connected_at;
        std::optional<std::chrono::steady_clock::time_point> authorized_at;
        std::optional<std::chrono::steady_clock::time_point> power_requested_at;
        std::chrono::steady_clock::time_point pending_started;
        std::chrono::steady_clock::time_point last_seen_plugged;
        bool transaction_started{false};
        bool authorized{false};
        bool ev_connected{false};
        AuthTokenSource token_source{AuthTokenSource::RFID};
    };

    struct PendingToken {
        AuthToken token;
        std::chrono::steady_clock::time_point expires_at;
    };

    ChargerConfig cfg_;
    std::shared_ptr<HardwareInterface> hardware_;
    std::unique_ptr<ocpp::v16::ChargePoint> charge_point_;
    PlannerConfig planner_cfg_{};
    PowerManager power_manager_;
    std::vector<Slot> slots_;
    std::unique_ptr<PowerModuleController> module_controller_;

    std::atomic<bool> running_{false};
    std::filesystem::path pending_token_store_;
    std::filesystem::path local_auth_cache_store_;
    std::map<std::int32_t, ActiveSession> sessions_;
    std::map<std::int32_t, std::deque<PendingToken>> pending_tokens_;
    std::map<std::int32_t, std::chrono::steady_clock::time_point> plug_event_time_;
    std::map<std::int32_t, bool> plugged_in_state_;
    std::map<std::int32_t, bool> connector_faulted_;
    std::map<std::int32_t, ConnectorState> connector_state_;
    std::map<std::int32_t, bool> post_stop_plugged_;
    std::map<std::int32_t, std::chrono::steady_clock::time_point> post_stop_time_;
    std::vector<std::thread> meter_threads_;
    std::thread planner_thread_;
    std::atomic<bool> planner_thread_running_{false};
    std::map<int, bool> evse_disabled_;
    std::map<int, bool> reserved_connectors_;
    std::map<int, int> reservation_lookup_;
    std::map<int, std::string> reservation_required_tag_;
    std::map<int, std::optional<std::string>> reservation_parent_tag_;
    std::map<int, bool> power_constrained_;
    std::mutex session_mutex_;
    std::mutex state_mutex_;
    std::mutex plan_mutex_;
    std::mutex meter_mutex_;
    std::mutex auth_mutex_;
    std::vector<ModuleState> module_states_;
    bool slots_initialized_{false};
    std::map<int, int> last_module_alloc_;
    std::map<int, double> last_voltage_v_;
    std::map<int, double> last_power_w_;
    std::map<int, double> last_current_limit_a_;
    std::map<int, double> last_requested_power_kw_;
    std::map<std::string, ContactorState> last_gc_state_;
    std::map<std::string, ContactorState> last_mc_state_;
    std::map<int, bool> mc_open_pending_;
    std::map<int, std::chrono::steady_clock::time_point> mc_open_request_time_;
    std::map<int, bool> gc_open_pending_;
    std::map<int, std::chrono::steady_clock::time_point> gc_open_request_time_;
    std::map<std::string, std::chrono::steady_clock::time_point> mc_command_change_time_;
    std::map<std::string, std::chrono::steady_clock::time_point> gc_command_change_time_;
    std::map<int, bool> paused_evse_;
    std::map<int, uint8_t> last_module_mask_cmd_;
    std::map<int, double> profile_current_limit_a_;
    std::map<int, double> profile_power_limit_kw_;
    std::map<int, double> last_energy_wh_;
    std::map<int, double> last_meter_sent_wh_;
    std::map<int, std::chrono::steady_clock::time_point> last_meter_sent_time_;
    std::map<int, std::chrono::steady_clock::time_point> cp_fault_since_;
    std::map<int, uint64_t> last_present_stale_counts_;
    std::map<int, uint64_t> last_limit_stale_counts_;
    std::map<std::string, std::chrono::steady_clock::time_point> local_auth_cache_;
    std::map<std::string, std::chrono::steady_clock::time_point> recent_token_cache_;
    std::atomic<bool> global_fault_latched_{false};
    std::string global_fault_reason_;
    std::map<int, std::chrono::steady_clock::time_point> precharge_start_;
    std::map<int, AuthorizationState> auth_state_cache_;
    std::map<int, int> telemetry_mismatch_count_;
    bool simulation_mode_{false};
    bool force_comm_fault_{false};
    std::optional<std::chrono::steady_clock::time_point> profile_next_refresh_;
    std::map<int, int> connector_meter_intervals_;

    void register_callbacks();
    void start_metering_threads();
    void metering_loop(std::int32_t connector);
    std::string make_session_id() const;
    void prepare_security_files() const;
    void seed_default_evse_limits();
    const Slot* find_slot_for_gun(int gun_id) const;
    void update_connector_state(std::int32_t connector, GunStatus status, bool has_session, bool tx_started,
                                bool authorized, bool fault_active, bool disabled, bool post_stop_plugged,
                                bool seamless_retry_active);
    bool has_active_session(std::int32_t connector);
    void initialize_slots();
    void apply_power_plan();
    void refresh_charging_profile_limits();
    void enter_global_fault(const std::string& reason, ocpp::v16::Reason stop_reason);
    void apply_zero_power_plan();
    bool safety_trip_needed(const GunStatus& status) const;
    void record_presence_state(std::int32_t connector, bool plugged_in,
                               const std::chrono::steady_clock::time_point& now);
    void ingest_auth_tokens(const std::vector<AuthToken>& tokens,
                            const std::chrono::steady_clock::time_point& now);
    int select_connector_for_token(const AuthToken& token) const;
    std::optional<PendingToken> pop_next_pending_token(std::int32_t connector,
                                                       const std::chrono::steady_clock::time_point& now,
                                                       const std::optional<std::string>& required_token = std::nullopt,
                                                       const std::optional<std::string>& parent_token = std::nullopt);
    AuthorizationState try_authorize_with_token(std::int32_t connector, ActiveSession& session, const PendingToken& pending);
    bool authorize_from_cache(const std::string& token);
    void update_local_auth_cache(const std::string& token);
    std::string clamp_id_token(const std::string& raw) const;
    void persist_pending_tokens();
    void persist_pending_tokens_locked();
    void persist_local_auth_cache_locked();
    void load_pending_tokens_from_disk();
    void load_local_auth_cache_from_disk();
    std::chrono::steady_clock::time_point to_steady(std::chrono::system_clock::time_point t_sys) const;
    std::chrono::system_clock::time_point to_system(std::chrono::steady_clock::time_point t_steady) const;
    static std::string token_source_to_string(AuthTokenSource src);
    static AuthTokenSource token_source_from_string(const std::string& s);
    void set_auth_state(std::int32_t connector, AuthorizationState state);
    ocpp::v16::DataTransferResponse
    handle_data_transfer_request(const ocpp::v16::DataTransferRequest& request);
    void handle_configuration_key_change(const ocpp::v16::KeyValue& key_value);
    bool token_matches_reservation(std::int32_t connector, const std::string& token,
                                   const std::optional<std::string>& parent_token);
    int meter_interval_seconds_for_connector(std::int32_t connector);
};

} // namespace charger


=== include/power_manager.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include <algorithm>
#include <chrono>
#include <map>
#include <optional>
#include <set>
#include <string>
#include <limits>
#include <vector>

namespace charger {

enum class ContactorState { Open, Closed };

enum class GunFsmState { Idle, EvDetected, Ready, IslandReady, Charging, RampDown, Fault };

struct Slot {
    int id{0};
    std::vector<std::string> modules; // e.g. {"M1_0", "M1_1"}
    int gun_id{0};                    // gun mapped to this slot
    std::string gc_id;                // gun contactor id
    std::string mc_id;                // bus cut contactor id
    int cw_id{0};
    int ccw_id{0};
};

struct ModuleState {
    std::string id;
    int slot_id{0};
    std::string mn_id;
    int slot_index{0};
    std::string type;
    std::string can_interface;
    int address{-1};
    int group{0};
    double rated_power_kw{0.0};
    double rated_current_a{0.0};
    int poll_interval_ms{500};
    int cmd_interval_ms{500};
    bool healthy{true};
    bool enabled{false};
    double temperature_c{0.0};
};

struct GunState {
    int id{0};
    int slot_id{0};
    std::string gc_id;
    GunFsmState fsm_state{GunFsmState::Idle};
    bool ev_session_active{false};
    bool safety_ok{true};
    bool gc_welded{false};
    bool mc_welded{false};
    double ev_req_power_kw{0.0};
    double ev_req_voltage_v{0.0};
    double min_voltage_v{0.0};
    double max_voltage_v{0.0};
    double gun_power_limit_kw{0.0};
    double gun_current_limit_a{0.0};
    int priority{0};
    double i_meas_a{0.0};
    double i_set_a{0.0};
    double connector_temp_c{0.0};
    bool plugged_in{false};
    bool reserved{false};
};

struct IslandState {
    int id{0};
    std::vector<int> slot_ids;
    std::vector<std::string> module_ids;
    std::optional<int> gun_id;
    double v_set_v{0.0};
    double p_set_kw{0.0};
};

struct PlannerConfig {
    double module_power_kw{30.0};
    double grid_limit_kw{1000.0};
    double ov_current_factor{1.1};
    double ramp_step_a{10.0};
    double min_voltage_v_for_div{5.0};
    double ideal_low_factor{0.8};
    double ideal_high_factor{1.6};
    double default_voltage_v{800.0};
    double connector_derate_start_c{80.0};
    double connector_derate_trip_c{90.0};
    double module_derate_start_c{75.0};
    double module_derate_trip_c{85.0};
    bool allow_cross_slot_islands{false};
    int min_module_hold_ms{1000};
    int max_modules_per_gun{2};
    int min_modules_per_active_gun{1};
    int max_island_radius{6};
    int min_mc_hold_ms{1000};
    int min_gc_hold_ms{500};
    double mc_open_current_a{1.0};
    double gc_open_current_a{1.0};
};

struct GunDispatch {
    int gun_id{0};
    double p_budget_kw{0.0};
    double p_set_kw{0.0};
    int modules_assigned{0};
    double current_limit_a{0.0};
    double voltage_set_v{0.0};
};

struct Plan {
    std::map<std::string, ContactorState> mc_commands;
    std::map<std::string, ContactorState> gc_commands;
    std::map<std::string, ContactorState> mn_commands;
    std::vector<IslandState> islands;
    std::vector<GunDispatch> guns;
};

class PowerManager {
public:
    explicit PowerManager(PlannerConfig cfg);

    void set_slots(std::vector<Slot> slots);
    void update_modules(const std::vector<ModuleState>& modules);
    void update_guns(const std::vector<GunState>& guns);

    Plan compute_plan();

private:
    PlannerConfig cfg_;
    std::vector<Slot> slots_;
    std::map<std::string, ModuleState> modules_;
    std::map<int, GunState> guns_;
    int next_island_id_{1};
    std::map<int, Slot> slot_lookup_;
    std::map<int, int> last_modules_assigned_;
    std::map<int, std::vector<std::string>> last_module_ids_;
    std::map<int, std::chrono::steady_clock::time_point> last_alloc_change_;

    std::vector<int> active_guns() const;
    Plan blank_plan() const;
    const Slot* find_slot(int slot_id) const;
    int count_healthy_modules_in_slot(int slot_id) const;
    int ideal_modules_for_gun(const GunState& g, double p_budget) const;
    std::vector<std::string> select_modules_for_slot(const Slot& slot, int n_needed, Plan& plan,
                                                     const std::vector<std::string>& preferred = {}) const;
    std::vector<int> build_island_slots_for_gun(const GunState& g, int n_needed,
                                                const std::set<int>& active_home_slots,
                                                const std::set<int>& reserved_slots,
                                                std::set<int>& claimed_slots) const;
    std::vector<std::string> assign_modules_for_island(const std::vector<int>& slot_ids, int n_needed, Plan& plan,
                                                       const std::vector<std::string>& preferred = {}) const;
    std::map<int, double> compute_power_budgets(const std::vector<int>& active,
                                                const std::map<int, double>& req_limited,
                                                int healthy_modules) const;
    std::map<int, int> compute_module_allocation(const std::vector<int>& active,
                                                 const std::map<int, double>& budgets,
                                                const std::map<int, int>& ideal,
                                                 int healthy_modules) const;
    Plan build_plan(const std::vector<int>& active, const std::map<int, double>& budgets,
                    const std::map<int, int>& modules_per_gun,
                    const std::set<int>& reserved_slots);
    void apply_hysteresis(Plan& plan, std::chrono::steady_clock::time_point now);
    bool validate_plan(const Plan& plan) const;
};

} // namespace charger


=== include/power_module_controller.hpp ===
// SPDX-License-Identifier: Apache-2.0
#pragma once

#include <array>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

namespace charger {

struct ModuleSpec {
    std::string id;
    int slot_id{0};
    int slot_index{0};
    std::string type;
    std::string can_interface;
    int address{-1};
    int group{0};
    double rated_power_kw{0.0};
    double rated_current_a{0.0};
    int poll_interval_ms{500};
    int cmd_interval_ms{500};
    bool broadcast{false}; // send via broadcast DST (0xFE or extended)
};

struct ModuleCommandRequest {
    int slot_id{0};
    uint8_t mask{0};
    double voltage_v{0.0};
    double current_a{0.0};
    double power_kw{0.0};
    bool enable{false};
};

struct ModuleHealthSnapshot {
    bool valid{false};
    uint8_t healthy_mask{0};
    uint8_t fault_mask{0};
    std::array<double, 2> temperatures_c{{0.0, 0.0}};
};

/// \brief Externalized power-module controller with pluggable module drivers (e.g. Maxwell MXR).
class PowerModuleController {
public:
    PowerModuleController();
    explicit PowerModuleController(const std::vector<ModuleSpec>& specs);
    ~PowerModuleController();

    void set_modules(const std::vector<ModuleSpec>& specs);
    void apply_command(const ModuleCommandRequest& req);
    ModuleHealthSnapshot snapshot_for_slot(int slot_id) const;
    void poll();

private:
    struct Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace charger


=== src/can_plc.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "can_plc.hpp"

#include <algorithm>
#include <chrono>
#include <cstring>
#include <stdexcept>
#include <vector>
#include <cstdlib>
#include <cerrno>
#include <filesystem>
#include <fstream>
#include <mutex>
#include <cstdio>
#include <sstream>
#include <iomanip>
#include <cmath>

#ifdef __linux__
#include <linux/can.h>
#include <linux/can/error.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <unistd.h>
#endif

#include <curl/curl.h>
#include <everest/logging.hpp>

namespace charger {

namespace {
constexpr uint32_t RELAY_STATUS_BASE = 0x160;
constexpr uint32_t SAFETY_STATUS_BASE = 0x190;
constexpr uint32_t ENERGY_METER_BASE = 0x170;
constexpr uint32_t CONFIG_ACK_BASE = 0x1A0;
constexpr uint32_t CONFIG_CMD_BASE = 0x380;
constexpr uint32_t CP_LEVELS_BASE = 0x430;
constexpr uint32_t CHARGING_SESSION_BASE = 0x410;
constexpr uint32_t EVAC_CTRL_BASE = 0x250;
constexpr uint32_t EVDC_MAX_LIMITS_BASE = 0x200;
constexpr uint32_t EVDC_TARGETS_BASE = 0x210;
constexpr uint32_t EVDC_ENERGY_LIMITS_BASE = 0x230;
constexpr uint32_t EV_STATUS_DISPLAY_BASE = 0x220;
constexpr uint32_t CHARGE_INFO_BASE = 0x100;
constexpr uint32_t RFID_EVENT_BASE = 0x180;
constexpr uint32_t EVCCID_BASE = 0x280;
constexpr uint32_t EMAID0_BASE = 0x260;
constexpr uint32_t EMAID1_BASE = 0x270;
constexpr uint32_t EVMAC_BASE = 0x240;
constexpr uint32_t EVSE_DC_MAX_LIMITS_CMD_BASE = 0x300;
constexpr uint32_t EVSE_DC_PRESENT_CMD_BASE = 0x310;
constexpr uint32_t GCMC_STATUS_BASE = 0x150;
constexpr uint32_t HW_STATUS_BASE = 0x130;
constexpr uint32_t DEBUG_INFO_BASE = 0x1B0;
constexpr uint32_t BOOT_CONFIG_BASE = 0x90000;
constexpr uint32_t GCMC_CMD_BASE = 0x390;
constexpr uint32_t RELAY_CMD_BASE = 0x340;
constexpr uint32_t RTEVLOG_BASE = 0x420;
constexpr uint32_t RTTLOG_BASE = 0x400;
constexpr uint32_t SOFTWARE_INFO_BASE = 0x110;
constexpr uint32_t ERROR_CODES_BASE = 0x120;
constexpr uint32_t HW_CONFIG_BASE = 0x306;
constexpr uint8_t CONFIG_PARAM_EVSE_LIMIT_ACK = 90;
constexpr std::chrono::milliseconds RELAY_TIMEOUT_MS(300);
constexpr std::chrono::milliseconds METER_TIMEOUT_MS(2000);
constexpr std::chrono::milliseconds SAFETY_DEBOUNCE_MS(50);
constexpr std::chrono::milliseconds CP_TIMEOUT_MS(1000);
constexpr std::chrono::milliseconds BUS_IDLE_TIMEOUT_MS(1000);
constexpr uint8_t HLC_POWER_DELIVERY_STAGE = 4;
constexpr std::chrono::seconds SEGMENT_TTL(5);
constexpr uint8_t CONFIG_PARAM_AUTH_STATE = 20;
constexpr uint8_t CONFIG_PARAM_AUTH_PENDING = 21;
constexpr std::chrono::milliseconds AUTH_REFRESH_INTERVAL_MS(1000);

uint16_t le_u16(const uint8_t* p) {
    return static_cast<uint16_t>(p[0] | (p[1] << 8));
}

int16_t le_i16(const uint8_t* p) {
    return static_cast<int16_t>(p[0] | (p[1] << 8));
}

uint32_t le_u32(const uint8_t* p) {
    return static_cast<uint32_t>(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
}

std::string bytes_to_hex(const std::vector<uint8_t>& bytes, size_t len) {
    std::ostringstream oss;
    oss << std::uppercase << std::hex;
    for (size_t i = 0; i < len && i < bytes.size(); ++i) {
        oss << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);
    }
    return oss.str();
}

bool cp_state_plugged(char state_char) {
    switch (state_char) {
    case 'B':
    case 'C':
    case 'D':
        return true;
    default:
        return false;
    }
}

std::string bundle_logs(const std::string& prefix) {
    const auto ts = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    const std::string dir = "logs";
    std::filesystem::create_directories(dir);
    const std::string fname = dir + "/" + prefix + "_" + std::to_string(ts) + ".log";
    std::ofstream out(fname, std::ios::out | std::ios::trunc);
    out << "Log bundle generated at " << ts << "\n";
    for (const auto& entry : std::filesystem::directory_iterator(dir)) {
        if (!entry.is_regular_file()) continue;
        if (entry.path().string() == fname) continue;
        out << "\n==== " << entry.path().filename().string() << " ====\n";
        std::ifstream in(entry.path());
        out << in.rdbuf();
    }
    return fname;
}

bool is_http_url(const std::string& target) {
    return target.rfind("http://", 0) == 0 || target.rfind("https://", 0) == 0;
}

bool upload_via_curl(const std::string& source, const std::string& url, bool require_https,
                     int connect_timeout_s, int transfer_timeout_s) {
    if (url.empty()) return false;
    if (require_https && url.rfind("https://", 0) != 0) {
        EVLOG_warning << "Rejecting non-HTTPS upload target " << url;
        return false;
    }
    static std::once_flag curl_once;
    std::call_once(curl_once, []() { curl_global_init(CURL_GLOBAL_DEFAULT); });

    CURL* curl = curl_easy_init();
    if (!curl) return false;

    std::FILE* file = std::fopen(source.c_str(), "rb");
    if (!file) {
        curl_easy_cleanup(curl);
        return false;
    }

    const auto size = std::filesystem::file_size(source);
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
    curl_easy_setopt(curl, CURLOPT_READDATA, file);
    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, static_cast<curl_off_t>(size));
    curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 0L);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, connect_timeout_s > 0 ? connect_timeout_s : 10);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, transfer_timeout_s > 0 ? transfer_timeout_s : 60);

    const CURLcode res = curl_easy_perform(curl);
    std::fclose(file);
    curl_easy_cleanup(curl);
    return res == CURLE_OK;
}

bool upload_file_to_target(const std::string& source,
                           const std::string& target,
                           bool require_https,
                           std::size_t max_bytes,
                           int connect_timeout_s,
                           int transfer_timeout_s,
                           bool allow_file_targets) {
    if (target.empty()) {
        return false;
    }
    std::error_code ec;
    const auto source_size = std::filesystem::file_size(source, ec);
    if (ec || source_size > max_bytes) {
        EVLOG_warning << "Rejecting upload: size exceeds limit or unreadable (" << source << ")";
        return false;
    }
    if (is_http_url(target)) {
        return upload_via_curl(source, target, require_https, connect_timeout_s, transfer_timeout_s);
    }
    if (!allow_file_targets) {
        EVLOG_warning << "File uploads disabled; rejecting target " << target;
        return false;
    }
    std::string path = target;
    const std::string prefix = "file://";
    if (path.rfind(prefix, 0) == 0) {
        path = path.substr(prefix.size());
    }
    const auto canonical_parent = std::filesystem::weakly_canonical(std::filesystem::path(path).parent_path(), ec);
    if (ec) {
        EVLOG_warning << "Rejecting upload: invalid path " << path;
        return false;
    }
    std::filesystem::create_directories(canonical_parent, ec);
    const auto dest_path = std::filesystem::weakly_canonical(path, ec);
    if (ec) {
        EVLOG_warning << "Rejecting upload: invalid destination " << path;
        return false;
    }
    std::filesystem::copy_file(source, dest_path, std::filesystem::copy_options::overwrite_existing, ec);
    return !ec;
}

bool download_via_curl(const std::string& url, const std::string& destination, bool require_https,
                       int connect_timeout_s, int transfer_timeout_s) {
    if (url.empty()) return false;
    if (require_https && url.rfind("https://", 0) != 0) {
        EVLOG_warning << "Rejecting non-HTTPS firmware URL " << url;
        return false;
    }
    static std::once_flag curl_once;
    std::call_once(curl_once, []() { curl_global_init(CURL_GLOBAL_DEFAULT); });
    CURL* curl = curl_easy_init();
    if (!curl) return false;
    std::FILE* file = std::fopen(destination.c_str(), "wb");
    if (!file) {
        curl_easy_cleanup(curl);
        return false;
    }
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, nullptr);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);
    curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, connect_timeout_s > 0 ? connect_timeout_s : 10);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, transfer_timeout_s > 0 ? transfer_timeout_s : 60);
    const CURLcode res = curl_easy_perform(curl);
    std::fclose(file);
    curl_easy_cleanup(curl);
    return res == CURLE_OK;
}

bool fetch_firmware(const std::string& location,
                    std::size_t max_bytes,
                    bool require_https,
                    int connect_timeout_s,
                    int transfer_timeout_s,
                    bool allow_file_targets) {
    if (location.empty()) return false;
    std::error_code ec;
    const std::string dest = "data/firmware/download.bin";
    std::filesystem::create_directories(std::filesystem::path(dest).parent_path(), ec);
    if (is_http_url(location)) {
        if (!download_via_curl(location, dest, require_https, connect_timeout_s, transfer_timeout_s)) {
            return false;
        }
    } else {
        if (!allow_file_targets) return false;
        std::string src = location;
        const std::string prefix = "file://";
        if (src.rfind(prefix, 0) == 0) {
            src = src.substr(prefix.size());
        }
        std::filesystem::copy_file(src, dest, std::filesystem::copy_options::overwrite_existing, ec);
        if (ec) return false;
    }
    const auto size = std::filesystem::file_size(dest, ec);
    if (ec || size > max_bytes) {
        EVLOG_warning << "Firmware download failed size check";
        std::filesystem::remove(dest, ec);
        return false;
    }
    return true;
}

uint16_t clamp_to_deciv(double value) {
    if (value <= 0.0) return 0;
    const double scaled = std::round(value * 10.0);
    if (scaled >= 65535.0) return 65535;
    if (scaled <= 0.0) return 0;
    return static_cast<uint16_t>(scaled);
}

bool crc_expected(uint32_t can_id) {
    const uint32_t masked = can_id & PLC_TX_MASK;
    return masked == (RELAY_STATUS_BASE & PLC_TX_MASK) ||
           masked == (SAFETY_STATUS_BASE & PLC_TX_MASK) ||
           masked == (CONFIG_ACK_BASE & PLC_TX_MASK) ||
           masked == (GCMC_STATUS_BASE & PLC_TX_MASK) ||
           masked == (RELAY_CMD_BASE & PLC_TX_MASK) ||
           masked == (CONFIG_CMD_BASE & PLC_TX_MASK) ||
           masked == (GCMC_CMD_BASE & PLC_TX_MASK);
}
} // namespace

bool PlcHardware::open_socket() {
#ifdef __linux__
    if (sock_ >= 0) {
        ::close(sock_);
        sock_ = -1;
    }
    sock_ = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (sock_ < 0) {
        EVLOG_error << "Failed to open CAN socket on " << iface_ << ": " << std::strerror(errno);
        return false;
    }
    struct ifreq ifr {};
    std::snprintf(ifr.ifr_name, IFNAMSIZ, "%s", iface_.c_str());
    if (ioctl(sock_, SIOCGIFINDEX, &ifr) < 0) {
        EVLOG_error << "CAN interface not found: " << iface_;
        ::close(sock_);
        sock_ = -1;
        return false;
    }

    sockaddr_can addr {};
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    if (bind(sock_, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
        EVLOG_error << "Failed to bind CAN socket on " << iface_ << ": " << std::strerror(errno);
        ::close(sock_);
        sock_ = -1;
        return false;
    }

    const can_err_mask_t err_mask = CAN_ERR_BUSOFF | CAN_ERR_RESTARTED | CAN_ERR_CRTL;
    if (setsockopt(sock_, SOL_CAN_RAW, CAN_RAW_ERR_FILTER, &err_mask, sizeof(err_mask)) < 0) {
        EVLOG_error << "Failed to set CAN error filter: " << std::strerror(errno);
        ::close(sock_);
        sock_ = -1;
        return false;
    }

    std::vector<can_filter> filters;
    for (const auto& kv : plc_to_connector_) {
        const int plc_id = kv.first & 0x0F;
        const PlcFilterSpec relay = make_plc_rx_filter(RELAY_STATUS_BASE, plc_id);
        can_filter f{};
        f.can_id = relay.id;
        f.can_mask = relay.mask;
        filters.push_back(f);
        const PlcFilterSpec safety = make_plc_rx_filter(SAFETY_STATUS_BASE, plc_id);
        f.can_id = safety.id; f.can_mask = safety.mask; filters.push_back(f);
        const PlcFilterSpec energy = make_plc_rx_filter(ENERGY_METER_BASE, plc_id);
        f.can_id = energy.id; f.can_mask = energy.mask; filters.push_back(f);
        const PlcFilterSpec cfgack = make_plc_rx_filter(CONFIG_ACK_BASE, plc_id);
        f.can_id = cfgack.id; f.can_mask = cfgack.mask; filters.push_back(f);
        const PlcFilterSpec cp = make_plc_rx_filter(CP_LEVELS_BASE, plc_id);
        f.can_id = cp.id; f.can_mask = cp.mask; filters.push_back(f);
        const PlcFilterSpec session = make_plc_rx_filter(CHARGING_SESSION_BASE, plc_id);
        f.can_id = session.id; f.can_mask = session.mask; filters.push_back(f);
        const PlcFilterSpec evac = make_plc_rx_filter(EVAC_CTRL_BASE, plc_id);
        f.can_id = evac.id; f.can_mask = evac.mask; filters.push_back(f);
        const PlcFilterSpec max_limits = make_plc_rx_filter(EVDC_MAX_LIMITS_BASE, plc_id);
        f.can_id = max_limits.id; f.can_mask = max_limits.mask; filters.push_back(f);
        const PlcFilterSpec targets = make_plc_rx_filter(EVDC_TARGETS_BASE, plc_id);
        f.can_id = targets.id; f.can_mask = targets.mask; filters.push_back(f);
        const PlcFilterSpec energy_limits = make_plc_rx_filter(EVDC_ENERGY_LIMITS_BASE, plc_id);
        f.can_id = energy_limits.id; f.can_mask = energy_limits.mask; filters.push_back(f);
        const PlcFilterSpec ev_status = make_plc_rx_filter(EV_STATUS_DISPLAY_BASE, plc_id);
        f.can_id = ev_status.id; f.can_mask = ev_status.mask; filters.push_back(f);
        const PlcFilterSpec charge_info = make_plc_rx_filter(CHARGE_INFO_BASE, plc_id);
        f.can_id = charge_info.id; f.can_mask = charge_info.mask; filters.push_back(f);
        const PlcFilterSpec rfid = make_plc_rx_filter(RFID_EVENT_BASE, plc_id);
        f.can_id = rfid.id; f.can_mask = rfid.mask; filters.push_back(f);
        const PlcFilterSpec evccid = make_plc_rx_filter(EVCCID_BASE, plc_id);
        f.can_id = evccid.id; f.can_mask = evccid.mask; filters.push_back(f);
        const PlcFilterSpec emaid0 = make_plc_rx_filter(EMAID0_BASE, plc_id);
        f.can_id = emaid0.id; f.can_mask = emaid0.mask; filters.push_back(f);
        const PlcFilterSpec emaid1 = make_plc_rx_filter(EMAID1_BASE, plc_id);
        f.can_id = emaid1.id; f.can_mask = emaid1.mask; filters.push_back(f);
        const PlcFilterSpec evmac = make_plc_rx_filter(EVMAC_BASE, plc_id);
        f.can_id = evmac.id; f.can_mask = evmac.mask; filters.push_back(f);
        const PlcFilterSpec gcmc_status = make_plc_rx_filter(GCMC_STATUS_BASE, plc_id);
        f.can_id = gcmc_status.id; f.can_mask = gcmc_status.mask; filters.push_back(f);
        const PlcFilterSpec hw_status = make_plc_rx_filter(HW_STATUS_BASE, plc_id);
        f.can_id = hw_status.id; f.can_mask = hw_status.mask; filters.push_back(f);
        const PlcFilterSpec debug_info = make_plc_rx_filter(DEBUG_INFO_BASE, plc_id);
        f.can_id = debug_info.id; f.can_mask = debug_info.mask; filters.push_back(f);
        const PlcFilterSpec boot_cfg = make_plc_rx_filter(BOOT_CONFIG_BASE, plc_id);
        f.can_id = boot_cfg.id; f.can_mask = boot_cfg.mask; filters.push_back(f);
        const PlcFilterSpec rtev = make_plc_rx_filter(RTEVLOG_BASE, plc_id);
        f.can_id = rtev.id; f.can_mask = rtev.mask; filters.push_back(f);
        const PlcFilterSpec rtt = make_plc_rx_filter(RTTLOG_BASE, plc_id);
        f.can_id = rtt.id; f.can_mask = rtt.mask; filters.push_back(f);
        const PlcFilterSpec sw_info = make_plc_rx_filter(SOFTWARE_INFO_BASE, plc_id);
        f.can_id = sw_info.id; f.can_mask = sw_info.mask; filters.push_back(f);
        const PlcFilterSpec err = make_plc_rx_filter(ERROR_CODES_BASE, plc_id);
        f.can_id = err.id; f.can_mask = err.mask; filters.push_back(f);
        const PlcFilterSpec hw_cfg = make_plc_rx_filter(HW_CONFIG_BASE, plc_id);
        f.can_id = hw_cfg.id; f.can_mask = hw_cfg.mask; filters.push_back(f);
    }
    if (!filters.empty()) {
        if (setsockopt(sock_, SOL_CAN_RAW, CAN_RAW_FILTER, filters.data(),
                       sizeof(can_filter) * filters.size()) < 0) {
            EVLOG_error << "Failed to set CAN filters: " << std::strerror(errno);
            ::close(sock_);
            sock_ = -1;
            return false;
        }
    }
    return true;
#else
    (void)iface_;
    return false;
#endif
}

void PlcHardware::restart_can() {
#ifdef __linux__
    std::lock_guard<std::mutex> lock(mtx_);
    if (!running_) return;
    if (open_socket()) {
        restart_requested_ = false;
        EVLOG_warning << "CAN socket reopened on " << iface_;
    } else {
        EVLOG_error << "Failed to reopen CAN socket on " << iface_;
    }
#endif
}

void PlcHardware::ingest_can_frame(uint32_t can_id, const uint8_t* data, size_t len) {
    handle_frame(can_id, data, len);
}

PlcHardware::PlcHardware(const ChargerConfig& cfg, bool open_can) : use_crc8_(cfg.plc_use_crc8),
                                                     module_relays_enabled_(cfg.plc_module_relays_enabled),
                                                     gun_relay_owned_by_plc_(cfg.plc_owns_gun_relay),
                                                     present_warn_ms_(cfg.plc_present_warn_ms),
                                                     limits_warn_ms_(cfg.plc_limits_warn_ms),
                                                     require_https_uploads_(cfg.require_https_uploads),
                                                     upload_max_bytes_(cfg.upload_max_bytes),
                                                     upload_connect_timeout_s_(cfg.upload_connect_timeout_s),
                                                     upload_transfer_timeout_s_(cfg.upload_transfer_timeout_s),
                                                     upload_allow_file_targets_(cfg.upload_allow_file_targets) {
    iface_ = cfg.can_interface.empty() ? "can0" : cfg.can_interface;
    for (const auto& c : cfg.connectors) {
        if (plc_to_connector_.count(c.plc_id)) {
            throw std::runtime_error("Duplicate plc_id " + std::to_string(c.plc_id) + " in PLC driver init");
        }
        Node node{};
        node.cfg = c;
        node.lock_engaged = !c.require_lock;
        node.lock_feedback_engaged = !c.require_lock;
        node.module_mask = 0x00;
        nodes_.emplace(c.id, node);
        plc_to_connector_[c.plc_id] = c.id;
    }
    EVLOG_info << "PLC gun relay ownership: " << (gun_relay_owned_by_plc_ ? "PLC" : "controller");

#ifdef __linux__
    if (open_can) {
        if (!open_socket()) {
            throw std::runtime_error("Failed to open CAN socket");
        }
        running_ = true;
        rx_thread_ = std::thread([this]() { rx_loop(); });
    } else {
        running_ = false;
    }
#else
    if (open_can) {
        throw std::runtime_error("CAN PLC driver requires Linux socketcan support");
    }
#endif
}

PlcHardware::~PlcHardware() {
    running_ = false;
#ifdef __linux__
    if (sock_ >= 0) {
        shutdown(sock_, SHUT_RDWR);
    }
    if (rx_thread_.joinable()) {
        rx_thread_.join();
    }
    if (sock_ >= 0) {
        close(sock_);
    }
#endif
}

PlcHardware::Node* PlcHardware::find_node(std::int32_t connector) {
    auto it = nodes_.find(connector);
    if (it == nodes_.end()) {
        return nullptr;
    }
    return &it->second;
}

PlcHardware::Node* PlcHardware::find_node_by_plc(int plc_id) {
    auto it = plc_to_connector_.find(plc_id);
    if (it == plc_to_connector_.end()) return nullptr;
    return find_node(it->second);
}

bool PlcHardware::enable(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mtx_);
    auto* node = find_node(connector);
    if (!node) return false;
    if (node->cfg.require_lock && !node->lock_engaged) {
        return false;
    }
    return send_relay_command(*node, true, false);
}

bool PlcHardware::disable(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mtx_);
    auto* node = find_node(connector);
    if (!node) return false;
    node->lock_engaged = true; // auto-lock when disabling
    return send_relay_command(*node, false, true);
}

bool PlcHardware::pause_charging(std::int32_t connector) {
    return disable(connector);
}

bool PlcHardware::resume_charging(std::int32_t connector) {
    return enable(connector);
}

bool PlcHardware::stop_transaction(std::int32_t connector, ocpp::v16::Reason /*reason*/) {
    return disable(connector);
}

void PlcHardware::apply_power_command(const PowerCommand& cmd) {
    std::lock_guard<std::mutex> lock(mtx_);
    auto* node = find_node(cmd.connector);
    if (!node) return;
    if (!node->authorization_granted) {
        node->mc_closed_cmd = false;
        node->gc_closed_cmd = false;
        node->module_mask = 0x00;
        send_relay_command(*node, false, true);
        return;
    }
    node->mc_closed_cmd = cmd.mc_closed;
    node->gc_closed_cmd = cmd.gc_closed;
    const bool gc_cmd_allowed = !gun_relay_owned_by_plc_;
    if (!cmd.mc_closed) {
        node->module_mask = 0x00;
        send_relay_command(*node, false, true);
        return;
    }
    uint8_t mask = 0x00;
    if (module_relays_enabled_) {
        // module_mask bit0 -> module0, map to RLY2 (bit1)
        if (cmd.module_mask & 0x01) {
            mask |= 0x02;
        }
        if (cmd.module_mask & 0x02) {
            mask |= 0x04;
        }
        if (cmd.module_mask & 0xFC) {
            EVLOG_warning << "PLC command module mask uses unsupported bits: 0x" << std::hex
                          << static_cast<int>(cmd.module_mask) << std::dec << " (only two modules supported by PLC relays)";
        }
    } else if (!module_relays_disabled_logged_) {
        EVLOG_info << "PLC module relays disabled by config; ignoring module_mask updates";
        module_relays_disabled_logged_ = true;
    }
    if (gc_cmd_allowed && cmd.module_count > 0 && cmd.gc_closed) {
        mask |= 0x01;
    }
    node->module_mask = mask;
    const bool any_relay_cmd = (mask & 0x07) != 0;
    const bool expect_plc_gc = gun_relay_owned_by_plc_ && cmd.module_count > 0 && cmd.gc_closed;
    const bool force_all_off = !any_relay_cmd && !expect_plc_gc;
    send_relay_command(*node, any_relay_cmd, force_all_off);
}

void PlcHardware::apply_power_allocation(std::int32_t connector, int modules) {
    std::lock_guard<std::mutex> lock(mtx_);
    auto* node = find_node(connector);
    if (!node) return;
    if (!node->authorization_granted) {
        node->mc_closed_cmd = false;
        node->gc_closed_cmd = false;
        node->module_mask = 0x00;
        send_relay_command(*node, false, true);
        return;
    }
    const bool gc_cmd_allowed = !gun_relay_owned_by_plc_;
    uint8_t mask = 0x00;
    if (module_relays_enabled_) {
        if (modules >= 1) {
            mask |= 0x02; // module 1
        }
        if (modules >= 2) {
            mask |= 0x04; // module 2
        }
    } else if (!module_relays_disabled_logged_) {
        EVLOG_info << "PLC module relays disabled by config; ignoring module allocation";
        module_relays_disabled_logged_ = true;
    }
    // keep gun relay in sync with module availability
    if (gc_cmd_allowed && modules > 0) {
        mask |= 0x01;
    }
    node->module_mask = mask;
    const bool close = (mask & 0x07) != 0;
    const bool expect_plc_gc = gun_relay_owned_by_plc_ && modules > 0;
    const bool force_all_off = !close && !expect_plc_gc;
    send_relay_command(*node, close, force_all_off);
}

ocpp::v16::UnlockStatus PlcHardware::unlock(std::int32_t /*connector*/) {
    std::lock_guard<std::mutex> lock(mtx_);
    // For hardware integration, drive lock actuator open here. Default to unlocked state.
    for (auto& kv : nodes_) {
        kv.second.lock_engaged = false;
    }
    return ocpp::v16::UnlockStatus::Unlocked;
}

ocpp::v16::ReservationStatus PlcHardware::reserve(std::int32_t /*reservation_id*/, std::int32_t /*connector*/,
                                                  ocpp::DateTime /*expiry*/, const std::string& /*id_tag*/,
                                                  const std::optional<std::string>& /*parent_id*/) {
    return ocpp::v16::ReservationStatus::Accepted;
}

bool PlcHardware::cancel_reservation(std::int32_t /*reservation_id*/) {
    return true;
}

ocpp::v16::GetLogResponse PlcHardware::upload_diagnostics(const ocpp::v16::GetDiagnosticsRequest& request) {
    ocpp::v16::GetLogResponse resp;
    resp.status = ocpp::v16::LogStatusEnumType::Accepted;
    const std::string fname = bundle_logs("diagnostics");
    bool upload_ok = true;
    if (!request.location.empty()) {
        upload_ok = upload_file_to_target(fname, request.location, require_https_uploads_,
                                          upload_max_bytes_, upload_connect_timeout_s_,
                                          upload_transfer_timeout_s_, upload_allow_file_targets_);
        if (!upload_ok) {
            EVLOG_warning << "Diagnostics upload to " << request.location << " failed";
        }
    }
    if (!upload_ok) {
        resp.status = ocpp::v16::LogStatusEnumType::Rejected;
    }
    resp.filename.emplace(fname);
    return resp;
}

ocpp::v16::GetLogResponse PlcHardware::upload_logs(const ocpp::v16::GetLogRequest& request) {
    ocpp::v16::GetLogResponse resp;
    resp.status = ocpp::v16::LogStatusEnumType::Accepted;
    const std::string fname = bundle_logs("logs");
    bool upload_ok = true;
    if (!request.log.remoteLocation.get().empty()) {
        upload_ok = upload_file_to_target(fname, request.log.remoteLocation, require_https_uploads_,
                                          upload_max_bytes_, upload_connect_timeout_s_,
                                          upload_transfer_timeout_s_, upload_allow_file_targets_);
        if (!upload_ok) {
            EVLOG_warning << "Log upload to " << request.log.remoteLocation << " failed";
        }
    }
    if (!upload_ok) {
        resp.status = ocpp::v16::LogStatusEnumType::Rejected;
    }
    resp.filename.emplace(fname);
    return resp;
}

void PlcHardware::update_firmware(const ocpp::v16::UpdateFirmwareRequest& request) {
    const bool ok = fetch_firmware(request.location, upload_max_bytes_, require_https_uploads_,
                                   upload_connect_timeout_s_, upload_transfer_timeout_s_, upload_allow_file_targets_);
    if (!ok) {
        EVLOG_warning << "PLC firmware download failed for " << request.location;
    } else {
        EVLOG_info << "PLC firmware downloaded from " << request.location << " scheduled at "
                   << request.retrieveDate.to_rfc3339();
    }
}

ocpp::v16::UpdateFirmwareStatusEnumType
PlcHardware::update_firmware_signed(const ocpp::v16::SignedUpdateFirmwareRequest& request) {
    const bool ok = fetch_firmware(request.firmware.location, upload_max_bytes_, require_https_uploads_,
                                   upload_connect_timeout_s_, upload_transfer_timeout_s_, upload_allow_file_targets_);
    return ok ? ocpp::v16::UpdateFirmwareStatusEnumType::Accepted
              : ocpp::v16::UpdateFirmwareStatusEnumType::Rejected;
}

void PlcHardware::set_connection_timeout(std::int32_t /*seconds*/) {
}

bool PlcHardware::is_reset_allowed(const ocpp::v16::ResetType& /*reset_type*/) {
    return true;
}

void PlcHardware::reset(const ocpp::v16::ResetType& /*reset_type*/) {
}

void PlcHardware::on_remote_start_token(const std::string& /*id_token*/,
                                        const std::vector<std::int32_t>& /*referenced_connectors*/,
                                        bool /*prevalidated*/) {
}

ocpp::Measurement PlcHardware::sample_meter(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mtx_);
    ocpp::Measurement m{};
    auto* node = find_node(connector);
    if (!node) {
        return m;
    }

    const auto now = std::chrono::steady_clock::now();
    auto& meter = node->status.meter;
    const bool has_rx = node->status.last_meter_rx.time_since_epoch().count() != 0;
    meter.stale = has_rx &&
        (std::chrono::duration_cast<std::chrono::milliseconds>(now - node->status.last_meter_rx) > METER_TIMEOUT_MS);

    const bool prefer_shunt = (node->cfg.meter_source == "shunt");
    // Prefer PLC-provided voltage if present; otherwise reuse last known DC voltage.
    if (meter.voltage_v <= 0.0 && node->status.present_voltage_v > 0.0) {
        meter.voltage_v = node->status.present_voltage_v;
    }
    if (prefer_shunt) {
        // For shunt-mode, rely on present V/I from EVDC telemetry rather than PLC meter counters.
        const double v = node->status.present_voltage_v > 0.0 ? node->status.present_voltage_v : meter.voltage_v;
        const double i = node->status.present_current_a;
        meter.voltage_v = v;
        meter.current_a = i;
        meter.power_w = v * i;
        meter.stale = false;
    }

    const bool meter_ok = !prefer_shunt && meter.ok && !meter.stale;
    double energy_wh = node->energy_fallback_Wh;
    const double power_for_energy_raw = meter_ok ? meter.power_w
        : (prefer_shunt ? meter.power_w : node->status.present_power_w);
    if (meter_ok) {
        node->meter_fallback_active = false;
        energy_wh = meter.energy_Wh;
        node->energy_fallback_Wh = energy_wh;
        node->last_energy_update = now;
    } else {
        node->meter_fallback_active = true;
        if (node->last_energy_update.time_since_epoch().count() == 0) {
            node->last_energy_update = now;
        }
        const auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - node->last_energy_update).count() /
            1000.0;
        const double power_w = power_for_energy_raw * node->cfg.meter_scale;
        if (elapsed > 0) {
            const double delta = (power_w * elapsed) / 3600.0;
            node->energy_fallback_Wh = std::max(0.0, node->energy_fallback_Wh + delta);
        }
        node->last_energy_update = now;
        energy_wh = node->energy_fallback_Wh;
    }

    // Apply calibration scaling
    double power_raw = power_for_energy_raw;
    if (!meter_ok && !prefer_shunt && node->status.present_power_w > 0.0) {
        power_raw = node->status.present_power_w;
    }
    const double power_scaled = power_raw * node->cfg.meter_scale;
    const double current_scaled = meter.current_a * node->cfg.meter_scale;
    const double energy_scaled = energy_wh * node->cfg.meter_scale + node->cfg.meter_offset_wh;
    node->status.present_power_w = power_scaled;
    node->status.present_current_a = current_scaled;

    m.power_meter.timestamp = ocpp::DateTime().to_rfc3339();
    m.power_meter.energy_Wh_import.total = energy_scaled;
    m.power_meter.voltage_V.emplace();
    m.power_meter.voltage_V->DC = static_cast<float>(meter.voltage_v);
    m.power_meter.current_A.emplace();
    m.power_meter.current_A->DC = static_cast<float>(current_scaled);
    m.power_meter.power_W.emplace();
    m.power_meter.power_W->total = static_cast<float>(power_scaled);
    return m;
}

GunStatus PlcHardware::get_status(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mtx_);
    GunStatus st{};
    auto* node = find_node(connector);
    if (!node) return st;
    const auto now = std::chrono::steady_clock::now();
    refresh_authorization_locked(*node, now, false);
    // Timeout detections
    if (node->status.last_relay_status.time_since_epoch().count() &&
        (now - node->status.last_relay_status) > RELAY_TIMEOUT_MS) {
        node->status.safety.comm_fault = true;
        node->status.safety.safety_ok = false;
    }
    if (node->status.last_safety_status.time_since_epoch().count() &&
        (now - node->status.last_safety_status) > RELAY_TIMEOUT_MS) {
        node->status.safety.comm_fault = true;
        node->status.safety.safety_ok = false;
    }
    if (node->awaiting_ack && (now - node->last_cmd_sent) > RELAY_TIMEOUT_MS) {
        if (node->retry_count < 3) {
            // retry last command
            send_relay_command(*node, node->last_cmd_close, node->last_force_all_off);
            node->retry_count++;
        } else {
            node->status.safety.comm_fault = true;
            node->status.safety.safety_ok = false;
        }
    }

    if (node->status.last_any_rx.time_since_epoch().count() &&
        (now - node->status.last_any_rx) > BUS_IDLE_TIMEOUT_MS) {
        node->status.safety.comm_fault = true;
        node->status.safety.safety_ok = false;
    }

    if (node->status.pending_safety_since.time_since_epoch().count()) {
        if ((now - node->status.pending_safety_since) >= SAFETY_DEBOUNCE_MS) {
            node->status.safety = node->status.pending_safety;
            node->status.pending_safety_since = {};
        }
    }

    const bool cp_seen = node->status.cp.last_rx.time_since_epoch().count() != 0;
    const bool cp_stale = cp_seen &&
        (std::chrono::duration_cast<std::chrono::milliseconds>(now - node->status.cp.last_rx) > CP_TIMEOUT_MS);
    const bool plugged = (cp_seen && !cp_stale) ? cp_state_plugged(node->status.cp.state_char) : false;

    st.safety_ok = node->status.safety.safety_ok;
    st.estop = node->status.safety.estop;
    st.earth_fault = node->status.safety.earth_fault;
    st.comm_fault = node->status.safety.comm_fault;
    st.relay_closed = node->status.relay_closed;
    st.meter_stale = node->meter_fallback_active || (node->status.meter.stale && !node->meter_fallback_active);
    st.plugged_in = plugged;
    st.cp_fault = cp_stale;
    st.cp_state = node->status.cp.state_char;
    st.hlc_stage = node->status.hlc_stage;
    st.hlc_cable_check_ok = node->status.hlc_cable_check_ok;
    st.hlc_precharge_active = node->status.hlc_precharge_active;
    st.hlc_charge_complete = node->status.hlc_charge_complete;
    st.hlc_power_ready = node->authorization_granted && node->status.hlc_power_ready;
    st.authorization_granted = node->authorization_granted;
    st.pilot_duty_pct = node->status.cp.duty_pct;
    st.present_voltage_v = node->status.present_voltage_v > 0.0 ? std::optional<double>(node->status.present_voltage_v) : std::nullopt;
    st.present_current_a = std::optional<double>(node->status.present_current_a);
    st.present_power_w = node->status.present_power_w > 0.0 ? std::optional<double>(node->status.present_power_w) : std::nullopt;
    st.target_voltage_v = node->status.target_voltage_v > 0.0 ? std::optional<double>(node->status.target_voltage_v) : std::nullopt;
    st.target_current_a = node->status.target_current_a > 0.0 ? std::optional<double>(node->status.target_current_a) : std::nullopt;
    st.evse_max_voltage_v = node->status.max_voltage_v > 0.0 ? std::optional<double>(node->status.max_voltage_v) : std::nullopt;
    st.evse_max_current_a = node->status.max_current_a > 0.0 ? std::optional<double>(node->status.max_current_a) : std::nullopt;
    st.evse_max_power_kw = node->status.max_power_kw > 0.0 ? std::optional<double>(node->status.max_power_kw) : std::nullopt;
    st.lock_engaged = !node->cfg.require_lock || (node->lock_engaged && node->lock_feedback_engaged);
    if (st.comm_fault && node->cfg.require_lock) {
        st.lock_engaged = false;
    }
    if (node->crc_mode_mismatch) {
        st.safety_ok = false;
        st.comm_fault = true;
    }
    auto choose_limit = [](std::optional<double> telem, double commanded, double cfg) -> std::optional<double> {
        if (telem && *telem > 0.0) return telem;
        if (commanded > 0.0) return commanded;
        if (cfg > 0.0) return cfg;
        return std::nullopt;
    };

    st.evse_max_voltage_v = choose_limit(st.evse_max_voltage_v, node->last_limit_voltage_v, node->cfg.max_voltage_v);
    st.evse_max_current_a = choose_limit(st.evse_max_current_a, node->last_limit_current_a, node->cfg.max_current_a);
    const double cfg_power_kw = node->cfg.max_power_w > 0.0 ? node->cfg.max_power_w / 1000.0 : 0.0;
    st.evse_max_power_kw = choose_limit(st.evse_max_power_kw, node->last_limit_power_kw, cfg_power_kw);
    st.evse_limit_ack_count = node->status.limit_ack_count;
    st.last_evse_limit_ack = node->status.last_limit_ack;
    st.present_stale_events = node->present_stale_events;
    st.limit_stale_events = node->limit_stale_events;
    st.auth_push_count = node->auth_push_count;
    st.last_telemetry = node->status.last_any_rx;
    uint8_t healthy_mask = node->crc_mode_mismatch ? 0x00 : 0x03; // two modules default healthy
    uint8_t fault_mask = node->crc_mode_mismatch ? 0xFF : 0x00;
    if (!node->crc_mode_mismatch) {
        const uint8_t commanded_mask = node->module_mask & 0x06;
        const uint8_t actual_mask = node->status.relay_state_mask & 0x06;
        const bool gun_cmd = gun_relay_owned_by_plc_
                                 ? node->gc_closed_cmd
                                 : ((node->module_mask & 0x01) != 0);
        const bool gun_actual = (node->status.relay_state_mask & 0x01) != 0;
        st.gc_welded = (!gun_relay_owned_by_plc_ && !gun_cmd && gun_actual);
        st.mc_welded = false;
        bool relay_conflict = false;
        if (st.comm_fault || !st.safety_ok || node->status.safety.remote_force_off) {
            healthy_mask = 0x00;
        } else {
            for (int idx = 0; idx < 2; ++idx) {
                const uint8_t bit = static_cast<uint8_t>(1U << (idx + 1));
                const bool commanded_on = (commanded_mask & bit) != 0;
                const bool actual_on = (actual_mask & bit) != 0;
                if (commanded_on && !actual_on) {
                    healthy_mask &= static_cast<uint8_t>(~(1U << idx));
                    fault_mask |= static_cast<uint8_t>(1U << idx);
                    relay_conflict = true;
                } else if (!commanded_on && actual_on) {
                    st.mc_welded = true;
                    healthy_mask &= static_cast<uint8_t>(~(1U << idx));
                    fault_mask |= static_cast<uint8_t>(1U << idx);
                    relay_conflict = true;
                }
            }
        }
        if (relay_conflict) {
            node->relay_conflict_count++;
        }
    }
    st.relay_closed = st.relay_closed && !node->crc_mode_mismatch;
    st.module_healthy_mask = healthy_mask;
    st.module_fault_mask = fault_mask;
    st.present_stale_events = node->present_stale_events;
    st.limit_stale_events = node->limit_stale_events;
    st.auth_push_count = node->auth_push_count;
    st.relay_conflict_count = node->relay_conflict_count;
    return st;
}

void PlcHardware::set_authorization_state(std::int32_t connector, bool authorized) {
    set_authorization_state(connector, authorized ? AuthorizationState::Granted : AuthorizationState::Denied);
}

void PlcHardware::set_authorization_state(std::int32_t connector, AuthorizationState state) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (auto* node = find_node(connector)) {
        node->authorization_state = state;
        node->authorization_granted = (state == AuthorizationState::Granted);
        node->status.hlc_power_ready = derive_hlc_power_ready(node->status, node->authorization_granted);
        const auto now = std::chrono::steady_clock::now();
        refresh_authorization_locked(*node, now, true);
    }
}

std::vector<AuthToken> PlcHardware::poll_auth_tokens() {
    std::lock_guard<std::mutex> lock(mtx_);
    std::vector<AuthToken> tokens;
    tokens.swap(auth_events_);
    return tokens;
}

void PlcHardware::set_evse_limits(std::int32_t connector, const EvseLimits& limits) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (auto* node = find_node(connector)) {
        send_evse_limits(*node, limits);
    }
}

void PlcHardware::publish_evse_present(std::int32_t connector, double voltage_v, double current_a,
                                       double power_kw, bool output_enabled, bool regulating) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (auto* node = find_node(connector)) {
        send_evse_present(*node, voltage_v, current_a, power_kw, output_enabled, regulating);
    }
}

void PlcHardware::publish_fault_state(std::int32_t connector, uint8_t fault_bits) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (auto* node = find_node(connector)) {
        const auto now = std::chrono::steady_clock::now();
        update_fault_bits(*node, fault_bits, now);
    }
}

void PlcHardware::update_fault_bits(Node& node, uint8_t fault_bits,
                                    const std::chrono::steady_clock::time_point& now) {
    node.fault_bits = static_cast<uint8_t>(fault_bits & 0x3F); // 6 bits packed into EVSE_PRESENT flags
    node.last_fault_update = now;
}

void PlcHardware::refresh_authorization_locked(Node& node,
                                               const std::chrono::steady_clock::time_point& now,
                                               bool force) {
    if (node.authorization_state == AuthorizationState::Unknown) {
        return;
    }
    if (!force && node.last_auth_push.time_since_epoch().count() &&
        (now - node.last_auth_push) < AUTH_REFRESH_INTERVAL_MS) {
        return;
    }
    const bool granted = node.authorization_state == AuthorizationState::Granted;
    const bool pending = node.authorization_state == AuthorizationState::Pending;
    send_config_command(node, CONFIG_PARAM_AUTH_STATE, granted ? 1U : 0U);
    send_config_command(node, CONFIG_PARAM_AUTH_PENDING, pending ? 1U : 0U);
    node.last_auth_push = now;
    node.auth_push_count++;
}

bool PlcHardware::send_config_command(Node& node, uint8_t param_id, uint32_t value) {
#ifdef __linux__
    uint8_t data[8] = {};
    data[0] = param_id;
    data[1] = 0x00; // set operation
    data[2] = static_cast<uint8_t>(value & 0xFF);
    data[3] = static_cast<uint8_t>((value >> 8) & 0xFF);
    data[4] = static_cast<uint8_t>((value >> 16) & 0xFF);
    data[5] = static_cast<uint8_t>((value >> 24) & 0xFF);
    data[6] = 0;
    if (use_crc8_) {
        data[7] = plc_crc8(data, 7);
    }
    uint32_t can_id = CONFIG_CMD_BASE | (node.cfg.plc_id & 0x0F);
    return send_frame(can_id | CAN_EFF_FLAG, data, sizeof(data));
#else
    (void)node;
    (void)param_id;
    (void)value;
    return false;
#endif
}

void PlcHardware::send_evse_limits(Node& node, const EvseLimits& limits) {
#ifdef __linux__
    const auto now = std::chrono::steady_clock::now();
    const double cfg_v = node.cfg.max_voltage_v > 0.0 ? node.cfg.max_voltage_v : 0.0;
    const double cfg_i = node.cfg.max_current_a > 0.0 ? node.cfg.max_current_a : 0.0;
    const double cfg_p = node.cfg.max_power_w > 0.0 ? node.cfg.max_power_w / 1000.0 : 0.0;

    const double v = limits.max_voltage_v.value_or(node.last_limit_voltage_v > 0.0 ? node.last_limit_voltage_v : cfg_v);
    const double i = limits.max_current_a.value_or(node.last_limit_current_a > 0.0 ? node.last_limit_current_a : cfg_i);
    const double p = limits.max_power_kw.value_or(node.last_limit_power_kw > 0.0 ? node.last_limit_power_kw : cfg_p);

    uint8_t data[8] = {};
    const uint16_t v_deciv = clamp_to_deciv(v);
    const uint16_t i_deciv = clamp_to_deciv(i);
    const uint16_t p_decik = clamp_to_deciv(p);
    data[0] = static_cast<uint8_t>(v_deciv & 0xFF);
    data[1] = static_cast<uint8_t>((v_deciv >> 8) & 0xFF);
    data[2] = static_cast<uint8_t>(i_deciv & 0xFF);
    data[3] = static_cast<uint8_t>((i_deciv >> 8) & 0xFF);
    data[4] = static_cast<uint8_t>(p_decik & 0xFF);
    data[5] = static_cast<uint8_t>((p_decik >> 8) & 0xFF);
    data[6] = 0;
    if (use_crc8_) {
        data[7] = plc_crc8(data, 7);
    }
    const uint32_t can_id = EVSE_DC_MAX_LIMITS_CMD_BASE | static_cast<uint32_t>(node.cfg.plc_id & 0x0F);
    const bool ok = send_frame(can_id | CAN_EFF_FLAG, data, sizeof(data));
    if (ok) {
        node.limit_tx_count++;
        node.last_limit_voltage_v = v_deciv / 10.0;
        node.last_limit_current_a = i_deciv / 10.0;
        node.last_limit_power_kw = p_decik / 10.0;
        node.status.max_voltage_v = node.last_limit_voltage_v;
        node.status.max_current_a = node.last_limit_current_a;
        node.status.max_power_kw = node.last_limit_power_kw;
        if (node.last_evse_limits_tx.time_since_epoch().count()) {
            const auto gap_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - node.last_evse_limits_tx).count();
            if (gap_ms > limits_warn_ms_) {
                node.limit_stale_events++;
                if (!cadence_warn_logged_) {
                    EVLOG_warning << "EVSE limit publish gap " << gap_ms << "ms to PLC " << node.cfg.plc_id;
                    cadence_warn_logged_ = true;
                }
            }
        }
        node.last_evse_limits_tx = now;
    } else {
        node.limit_tx_fail++;
        EVLOG_warning << "Failed to send EVSE limits to PLC " << node.cfg.plc_id
                      << " (tx_fail=" << node.limit_tx_fail << ", sent=" << node.limit_tx_count << ")";
    }
#else
    (void)node;
    (void)limits;
#endif
}

void PlcHardware::send_evse_present(Node& node, double voltage_v, double current_a, double power_kw,
                                    bool output_enabled, bool regulating) {
#ifdef __linux__
    const auto now = std::chrono::steady_clock::now();
    uint8_t data[8] = {};
    const uint16_t v_deciv = clamp_to_deciv(voltage_v);
    const uint16_t i_deciv = clamp_to_deciv(current_a);
    const uint16_t p_decik = clamp_to_deciv(power_kw);
    data[0] = static_cast<uint8_t>(v_deciv & 0xFF);
    data[1] = static_cast<uint8_t>((v_deciv >> 8) & 0xFF);
    data[2] = static_cast<uint8_t>(i_deciv & 0xFF);
    data[3] = static_cast<uint8_t>((i_deciv >> 8) & 0xFF);
    data[4] = static_cast<uint8_t>(p_decik & 0xFF);
    data[5] = static_cast<uint8_t>((p_decik >> 8) & 0xFF);
    uint8_t flags = 0;
    if (output_enabled) flags |= 0x01;
    if (regulating) flags |= 0x02;
    const uint8_t faults = static_cast<uint8_t>(node.fault_bits & 0x3F);
    flags |= static_cast<uint8_t>(faults << 2);
    data[6] = flags;
    if (use_crc8_) {
        data[7] = plc_crc8(data, 7);
    }
    const uint32_t can_id = EVSE_DC_PRESENT_CMD_BASE | static_cast<uint32_t>(node.cfg.plc_id & 0x0F);
    (void)send_frame(can_id | CAN_EFF_FLAG, data, sizeof(data));
    node.status.present_voltage_v = voltage_v;
    node.status.present_current_a = current_a;
    node.status.present_power_w = power_kw * 1000.0;
    if (node.last_evse_present_tx.time_since_epoch().count()) {
        const auto gap_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - node.last_evse_present_tx).count();
        if (gap_ms > present_warn_ms_) {
            node.present_stale_events++;
            if (!cadence_warn_logged_) {
                EVLOG_warning << "EVSE present publish gap " << gap_ms << "ms to PLC " << node.cfg.plc_id;
                cadence_warn_logged_ = true;
            }
        }
    }
    node.last_evse_present_tx = now;
#else
    (void)node;
    (void)voltage_v;
    (void)current_a;
    (void)power_kw;
    (void)output_enabled;
    (void)regulating;
#endif
}

bool PlcHardware::send_relay_command(Node& node, bool close, bool force_all_off) {
#ifdef __linux__
    uint8_t data[8] = {};
    data[0] = 0;
    if (close) {
        data[0] |= (node.module_mask & 0x07); // RLY1/2/3_CMD bits
    }
    data[0] |= (1 << 3);                 // SYS_ENABLE
    if (force_all_off) data[0] |= (1 << 4);
    const bool clear_faults = node.status.last_fault_reason != 0;
    if (clear_faults) data[0] |= (1 << 5); // CLEAR_FAULTS
    const uint8_t seq = node.cmd_seq++;
    data[1] = seq;
    // Enable mask for relays present
    data[2] = node.module_mask & 0x07; // RLY1/2/3_ENABLE
    // CMD_MODE (steady)
    data[3] = 0x00;
    // PULSE_MS (steady)
    data[4] = 0x00;
    data[5] = 0x00;
    if (use_crc8_) {
        data[7] = plc_crc8(data, 7);
    }
    uint32_t can_id = 0x0300 | ((0x4 << 4) | (node.cfg.plc_id & 0x0F));
    const auto ok = send_frame(can_id | CAN_EFF_FLAG, data, sizeof(data));
    if (ok) {
        node.expected_cmd_seq = seq;
        node.awaiting_ack = true;
        node.last_cmd_sent = std::chrono::steady_clock::now();
        node.retry_count = 0;
        node.last_cmd_close = close;
        node.last_force_all_off = force_all_off;
        // Mirror command on GCMC path for firmware that consumes it.
        if (!send_gcmc_command(node, seq, close, force_all_off)) {
            EVLOG_warning << "Failed to send GCMC command to PLC " << node.cfg.plc_id;
        }
    }
    return ok;
#else
    (void)node;
    (void)close;
    (void)force_all_off;
    return false;
#endif
}

bool PlcHardware::send_frame(uint32_t can_id, const uint8_t* data, size_t len) {
#ifdef __linux__
    if (sock_ < 0) return false;
    struct can_frame frame {};
    frame.can_id = can_id;
    frame.can_dlc = static_cast<uint8_t>(len);
    std::memcpy(frame.data, data, std::min<size_t>(len, sizeof(frame.data)));
    for (int attempt = 0; attempt < 3; ++attempt) {
        const auto written = write(sock_, &frame, sizeof(frame));
        if (written == sizeof(frame)) {
            return true;
        }
        if (errno == ENOBUFS || errno == EAGAIN) {
            std::this_thread::sleep_for(std::chrono::milliseconds(5 * (attempt + 1)));
            continue;
        }
        EVLOG_warning << "CAN write failed (id=0x" << std::hex << can_id << std::dec << "): "
                      << std::strerror(errno);
        break;
    }
    return false;
#else
    (void)can_id;
    (void)data;
    (void)len;
    return false;
#endif
}

void PlcHardware::rx_loop() {
#ifdef __linux__
    while (running_) {
        if (restart_requested_) {
            restart_can();
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
        if (sock_ < 0) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }
        struct can_frame frame {};
        const auto nbytes = read(sock_, &frame, sizeof(frame));
        if (nbytes != sizeof(frame)) {
            continue;
        }
        if (frame.can_id & CAN_ERR_FLAG) {
            handle_error_frame(frame);
            continue;
        }
        if ((frame.can_id & CAN_EFF_FLAG) == 0) {
            continue;
        }
        handle_frame(frame.can_id & CAN_EFF_MASK, frame.data, frame.can_dlc);
    }
#endif
}

void PlcHardware::handle_frame(uint32_t can_id, const uint8_t* data, size_t len) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (nodes_.empty()) return;

    const int plc_id = static_cast<int>(can_id & 0x0F);
    auto* node = find_node_by_plc(plc_id);
    if (!node) return;
    const auto rx_time = std::chrono::steady_clock::now();
    auto mark_crc_mismatch = [&](const char* reason) {
        node->status.safety.comm_fault = true;
        node->status.safety.safety_ok = false;
        node->crc_mode_mismatch = true;
        node->status.pending_safety = node->status.safety;
        node->status.pending_safety_since = rx_time;
        if (!node->crc_mode_mismatch_logged) {
            EVLOG_error << "CRC mode mismatch on PLC " << node->cfg.plc_id << ": " << reason;
            node->crc_mode_mismatch_logged = true;
        }
    };
    auto mark_crc_fault = [&](const char* reason) {
        node->status.safety.comm_fault = true;
        node->status.safety.safety_ok = false;
        node->status.pending_safety = node->status.safety;
        node->status.pending_safety_since = rx_time;
        if (!node->crc_fault_logged) {
            EVLOG_error << "CRC fault on PLC " << node->cfg.plc_id << ": " << reason;
            node->crc_fault_logged = true;
        }
    };

    // CRC check based on DBC (only specific frames carry CRC).
    if (use_crc8_ && crc_expected(can_id)) {
        if (len < 8) {
            mark_crc_mismatch("expected CRC8 byte but frame shorter than 8 bytes");
            return;
        }
        const uint8_t expected = plc_crc8(data, 7);
        if (expected != data[7]) {
            mark_crc_fault("CRC8 verification failed");
            return;
        }
    }
    node->crc_fault_logged = false;
    node->status.last_any_rx = rx_time;
    prune_segment_buffers(*node, rx_time);

    if ((can_id & PLC_TX_MASK) == (RELAY_STATUS_BASE & PLC_TX_MASK)) {
        handle_relay_status(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (SAFETY_STATUS_BASE & PLC_TX_MASK)) {
        handle_safety_status(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (ENERGY_METER_BASE & PLC_TX_MASK)) {
        handle_meter(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (CP_LEVELS_BASE & PLC_TX_MASK)) {
        handle_cp_levels(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (CHARGING_SESSION_BASE & PLC_TX_MASK)) {
        handle_charging_session(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EVAC_CTRL_BASE & PLC_TX_MASK)) {
        handle_evac_control(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EVDC_TARGETS_BASE & PLC_TX_MASK)) {
        handle_evdc_targets(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EVDC_MAX_LIMITS_BASE & PLC_TX_MASK) ||
               (can_id & PLC_TX_MASK) == (EVDC_ENERGY_LIMITS_BASE & PLC_TX_MASK)) {
        handle_evdc_limits(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EV_STATUS_DISPLAY_BASE & PLC_TX_MASK)) {
        handle_ev_status_display(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (CHARGE_INFO_BASE & PLC_TX_MASK)) {
        handle_charge_info(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (GCMC_STATUS_BASE & PLC_TX_MASK)) {
        handle_gcmc_status(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (HW_STATUS_BASE & PLC_TX_MASK)) {
        handle_hw_status(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (DEBUG_INFO_BASE & PLC_TX_MASK)) {
        handle_debug_info(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (BOOT_CONFIG_BASE & PLC_TX_MASK)) {
        handle_boot_config(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (RTEVLOG_BASE & PLC_TX_MASK)) {
        handle_rtev_log(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (RTTLOG_BASE & PLC_TX_MASK)) {
        handle_rtt_log(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (SOFTWARE_INFO_BASE & PLC_TX_MASK)) {
        handle_software_info(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (ERROR_CODES_BASE & PLC_TX_MASK)) {
        handle_error_codes(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (HW_CONFIG_BASE & PLC_TX_MASK)) {
        handle_hw_config(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (RFID_EVENT_BASE & PLC_TX_MASK)) {
        handle_rfid_event(*node, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EVCCID_BASE & PLC_TX_MASK)) {
        handle_identity_segment(*node, node->evccid, AuthTokenSource::Autocharge, data, len);
    } else if ((can_id & PLC_TX_MASK) == (EVMAC_BASE & PLC_TX_MASK)) {
        handle_identity_segment(*node, node->evmac, AuthTokenSource::Autocharge, data, len);
    } else if ((can_id & PLC_TX_MASK) == (CONFIG_ACK_BASE & PLC_TX_MASK)) {
        if (len >= 6) {
            const uint8_t param_id = data[0];
            const uint8_t status = data[1];
            const uint32_t value = le_u32(&data[2]);
            EVLOG_info << "PLC " << node->cfg.plc_id << " ConfigAck param=" << static_cast<int>(param_id)
                       << " status=" << static_cast<int>(status) << " value=0x" << std::hex << value << std::dec;
            if (status == 0 && param_id == CONFIG_PARAM_EVSE_LIMIT_ACK) {
                node->status.limit_ack_count = value;
                node->status.last_limit_ack = rx_time;
            }
        }
    } else {
        if (unknown_can_ids_.insert(can_id).second) {
            EVLOG_debug << "Unhandled PLC CAN frame id=0x" << std::hex << can_id << std::dec
                        << " len=" << static_cast<int>(len);
        }
    }
}

void PlcHardware::handle_relay_status(Node& node, const uint8_t* data, size_t len) {
    if (len < 6) return;
    node.status.relay_state_mask = data[0] & 0x07;
    node.status.relay_closed = (data[0] & 0x01) != 0;
    PlcSafetyStatus s = node.status.safety;
    s.safety_ok = (data[2] & 0x10) != 0;    // bit20
    s.earth_fault = (data[2] & 0x20) != 0;  // bit21
    s.estop = (data[2] & 0x80) != 0;        // bit23
    node.status.last_cmd_seq = data[1];
    s.comm_fault = (data[0] & 0x80) != 0;   // bit7
    s.remote_force_off = false;
    const uint8_t fault_reason = data[3];
    node.status.last_fault_reason = fault_reason;
    if (fault_reason != 0) {
        s.safety_ok = false;
        if (fault_reason == 6 || fault_reason == 5 || fault_reason == 8) {
            s.comm_fault = true; // CAN_BUS_OFF, RELAYCTRL_TIMEOUT, CRC_FAIL
        }
        if (fault_reason == 7) {
            s.remote_force_off = true;
        }
        if (fault_reason == 10 || fault_reason == 12) {
            s.earth_fault = true;
        }
    }
    const bool lock_input = derive_lock_input(node, data[2], true);
    node.lock_feedback_engaged = lock_input;
    node.lock_engaged = node.cfg.require_lock ? lock_input : true;
    // Update pending safety to debounce
    node.status.pending_safety = s;
    node.status.pending_safety_since = std::chrono::steady_clock::now();
    if (node.awaiting_ack && node.expected_cmd_seq == node.status.last_cmd_seq) {
        node.awaiting_ack = false;
        node.retry_count = 0;
    }
    node.status.last_relay_status = std::chrono::steady_clock::now();
}

void PlcHardware::handle_safety_status(Node& node, const uint8_t* data, size_t len) {
    if (len < 2) return;
    PlcSafetyStatus s = node.status.safety;
    s.safety_ok = (data[0] & 0x10) != 0;
    s.earth_fault = (data[0] & 0x20) != 0;
    s.estop = (data[0] & 0x08) != 0;
    s.comm_fault = false; // explicit status frame indicates comm alive
    const bool lock_input = derive_lock_input(node, data[0], false);
    node.lock_feedback_engaged = lock_input;
    node.lock_engaged = node.cfg.require_lock ? lock_input : true;
    node.status.pending_safety = s;
    node.status.pending_safety_since = std::chrono::steady_clock::now();
    node.status.last_safety_status = std::chrono::steady_clock::now();
}

void PlcHardware::handle_meter(Node& node, const uint8_t* data, size_t len) {
    if (len < 8) return;
    const uint8_t mux = data[0];
    auto& meter = node.status.meter;
    const bool meter_ok = (data[1] & 0x01) != 0;
    const bool comm_error = (data[1] & 0x02) != 0;
    const bool data_stale = (data[1] & 0x04) != 0;
    const bool overrange = (data[1] & 0x08) != 0;
    const bool fallback_active = (data[1] & 0x10) != 0;
    if (mux == 0) {
        const uint16_t v = le_u16(&data[2]);
        const int16_t i = le_i16(&data[4]);
        const int16_t p = le_i16(&data[6]);
        meter.voltage_v = v * 0.1;
        meter.current_a = i * 0.01;
        meter.power_w = p * 10.0;
        meter.ok = meter_ok && !overrange && !fallback_active;
        node.status.present_voltage_v = meter.voltage_v;
        node.status.present_current_a = meter.current_a;
        node.status.present_power_w = meter.power_w;
    } else if (mux == 1) {
        const uint32_t e = le_u32(&data[2]);
        const uint16_t f = le_u16(&data[6]);
        meter.energy_Wh = static_cast<double>(e) * 100.0; // 0.1 kWh -> Wh
        meter.freq_hz = f * 0.01;
        meter.ok = meter_ok && !overrange && !fallback_active;
    }
    meter.stale = data_stale || fallback_active;
    node.meter_fallback_active = fallback_active;
    node.status.safety.comm_fault = comm_error;
    node.status.last_meter_rx = std::chrono::steady_clock::now();
    if (comm_error) {
        node.status.safety.safety_ok = false;
    }
}

void PlcHardware::handle_cp_levels(Node& node, const uint8_t* data, size_t len) {
    if (len < 8) return;
    const uint16_t mv_robust = le_u16(&data[0]);
    const char cp_state_char = static_cast<char>(data[2]);
    const uint8_t duty = data[3];
    const uint16_t mv_peak = le_u16(&data[4]);
    const uint16_t mv_min = le_u16(&data[6]);
    update_cp_status(node, cp_state_char, duty, mv_peak, mv_min, true, mv_robust, true);
}

void PlcHardware::handle_charging_session(Node& node, const uint8_t* data, size_t len) {
    if (len < 6) return;
    node.status.session_epoch = le_u32(&data[0]);
    const char cp_state_char = static_cast<char>(data[4]);
    const uint8_t duty = data[5];
    update_cp_status(node, cp_state_char, duty, 0, 0, false, 0, false);
    uint8_t stage = node.status.hlc_stage;
    if (len >= 7) {
        stage = data[6];
    }
    bool auth_pending = false;
    if (len >= 8) {
        auth_pending = (data[7] & 0x01) != 0;
    }
    node.status.auth_pending_flag = auth_pending;
    uint8_t flags = 0;
    if (node.status.hlc_charge_complete) flags |= 0x01;
    if (node.status.hlc_precharge_active) flags |= 0x02;
    if (node.status.hlc_cable_check_ok) flags |= 0x04;
    if (node.authorization_granted) flags |= 0x08;
    if (auth_pending) flags |= 0x10;
    update_hlc_state(node, stage, flags);
}

void PlcHardware::handle_evac_control(Node& node, const uint8_t* data, size_t len) {
    if (len < 2) return;
    const uint8_t duty = data[0];
    const char cp_state_char = static_cast<char>(data[1]);
    uint16_t tgt_v_0p1 = 0;
    uint16_t tgt_i_0p1 = 0;
    uint16_t pres_i_0p1 = 0;
    if (len >= 6) {
        tgt_v_0p1 = le_u16(&data[2]);
        tgt_i_0p1 = le_u16(&data[4]);
    }
    if (len >= 8) {
        pres_i_0p1 = le_u16(&data[6]);
    }
    node.status.target_voltage_v = tgt_v_0p1 * 0.1;
    node.status.target_current_a = tgt_i_0p1 * 0.1;
    node.status.present_current_a = pres_i_0p1 * 0.1;
    update_cp_status(node, cp_state_char, duty, 0, 0, false);
}

void PlcHardware::handle_evdc_targets(Node& node, const uint8_t* data, size_t len) {
    if (len < 8) return;
    const uint16_t tgt_v = le_u16(&data[0]);
    const uint16_t tgt_i = le_u16(&data[2]);
    const uint16_t pres_v = le_u16(&data[4]);
    const uint16_t pres_i = le_u16(&data[6]);
    node.status.target_voltage_v = tgt_v * 0.1;
    node.status.target_current_a = tgt_i * 0.1;
    node.status.present_voltage_v = pres_v * 0.1;
    node.status.present_current_a = pres_i * 0.1;
    node.status.present_power_w = node.status.present_voltage_v * node.status.present_current_a;
}

void PlcHardware::handle_evdc_limits(Node& node, const uint8_t* data, size_t len) {
    if (len < 6) return;
    const uint16_t max_v = le_u16(&data[0]);
    const uint16_t max_i = le_u16(&data[2]);
    const uint16_t max_p = le_u16(&data[4]);
    node.status.max_voltage_v = max_v * 0.1;
    node.status.max_current_a = max_i * 0.1;
    node.status.max_power_kw = max_p * 0.1;
}

void PlcHardware::handle_ev_status_display(Node& node, const uint8_t* data, size_t len) {
    if (len < 6) return;
    const uint16_t pres_v = le_u16(&data[0]);
    const uint16_t pres_i = le_u16(&data[2]);
    const uint8_t stage = data[4];
    const uint8_t duty = data[5];
    const char cp_state_char = (len >= 7) ? static_cast<char>(data[6]) : node.status.cp.state_char;
    node.status.present_voltage_v = pres_v * 0.1;
    node.status.present_current_a = pres_i * 0.1;
    node.status.present_power_w = node.status.present_voltage_v * node.status.present_current_a;
    update_cp_status(node, cp_state_char, duty, 0, 0, false);
    uint8_t flags = 0;
    if (node.status.hlc_charge_complete) flags |= 0x01;
    if (node.status.hlc_precharge_active) flags |= 0x02;
    if (node.status.hlc_cable_check_ok) flags |= 0x04;
    update_hlc_state(node, stage, flags);
}

void PlcHardware::handle_charge_info(Node& node, const uint8_t* data, size_t len) {
    if (len < 2) return;
    const uint8_t stage = data[0];
    const uint8_t flags = data[1];
    const bool auth_granted = (flags & 0x08) != 0;
    const bool auth_pending = (flags & 0x10) != 0;
    const bool lock_engaged = (flags & 0x20) != 0;
    node.authorization_granted = auth_granted;
    node.status.auth_pending_flag = auth_pending;
    node.lock_feedback_engaged = lock_engaged;
    node.lock_engaged = node.cfg.require_lock ? lock_engaged : true;
    update_hlc_state(node, stage, flags);
}

void PlcHardware::handle_gcmc_status(Node& node, const uint8_t* data, size_t len) {
    if (len < 7) return;
    const uint8_t cmd_bits = data[0];
    const uint8_t fb_bits = data[1];
    const uint8_t fault_reason = data[2];
    const uint8_t comm_fault = data[3];
    const uint8_t safety_active = data[4];
    const uint8_t last_applied = data[5];
    const uint8_t cmd_seq_rx = data[6];

    uint8_t mask = 0;
    if (fb_bits & 0x01) mask |= 0x01; // GC
    if (fb_bits & 0x02) mask |= 0x02; // MC
    if (fb_bits & 0x04) mask |= 0x04; // MN0/module
    node.status.relay_state_mask = mask;
    node.status.relay_closed = (mask & 0x01) != 0;
    PlcSafetyStatus s = node.status.safety;
    s.comm_fault = comm_fault != 0;
    s.remote_force_off = false;
    s.safety_ok = !safety_active;
    if (fault_reason != 0) {
        s.safety_ok = false;
        if (fault_reason == 6 || fault_reason == 5 || fault_reason == 8) {
            s.comm_fault = true;
        }
        if (fault_reason == 7) {
            s.remote_force_off = true;
        }
        if (fault_reason == 10 || fault_reason == 12) {
            s.earth_fault = true;
        }
    }
    node.status.last_fault_reason = fault_reason;
    node.status.pending_safety = s;
    node.status.pending_safety_since = std::chrono::steady_clock::now();
    node.status.last_cmd_seq = last_applied;
    node.expected_cmd_seq = cmd_seq_rx;
    node.status.rx_count = std::max<uint32_t>(node.status.rx_count, static_cast<uint32_t>(cmd_seq_rx));
    if (node.awaiting_ack && node.expected_cmd_seq == node.status.last_cmd_seq) {
        node.awaiting_ack = false;
        node.retry_count = 0;
    }
    node.status.last_any_rx = std::chrono::steady_clock::now();
    (void)cmd_bits;
}

void PlcHardware::handle_hw_status(Node& node, const uint8_t* data, size_t len) {
    if (len < 7) return;
    const uint8_t tec = data[0];
    const uint8_t rec = data[1];
    const bool bus_off = data[2] != 0;
    node.status.uptime_s = static_cast<uint32_t>(le_u16(&data[5]));
    node.status.rx_count = static_cast<uint32_t>(data[3]);
    node.status.tx_count = static_cast<uint32_t>(data[4]);
    if (bus_off) {
        node.status.safety.comm_fault = true;
        node.status.safety.safety_ok = false;
        node.status.relay_closed = false;
        if (!node.bus_off_logged) {
            EVLOG_error << "CAN controller bus-off (TEC=" << static_cast<int>(tec)
                        << ", REC=" << static_cast<int>(rec) << ") on PLC " << node.cfg.plc_id;
            node.bus_off_logged = true;
        }
    } else {
        node.bus_off_logged = false;
    }
    node.status.last_any_rx = std::chrono::steady_clock::now();
    if (bus_off) {
        restart_requested_ = true;
    }
}

void PlcHardware::handle_debug_info(Node& node, const uint8_t* data, size_t len) {
    if (len < 4) return;
    const uint8_t cmd_seq_tx = data[0];
    const uint8_t last_applied = data[1];
    const uint8_t relay_fault = data[2];
    const bool bus_off = data[3] != 0;
    if (bus_off) {
        node.status.safety.comm_fault = true;
        node.status.safety.safety_ok = false;
    }
    node.status.last_cmd_seq = last_applied;
    node.status.rx_count = std::max<uint32_t>(node.status.rx_count, static_cast<uint32_t>(cmd_seq_tx));
    if (node.awaiting_ack && node.expected_cmd_seq == node.status.last_cmd_seq) {
        node.awaiting_ack = false;
        node.retry_count = 0;
    }
    if (relay_fault != 0) {
        node.status.last_fault_reason = relay_fault;
        node.status.safety.safety_ok = false;
    }
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_boot_config(Node& node, const uint8_t* data, size_t len) {
    if (len < 4) return;
    const uint8_t fw_major = data[0];
    const uint8_t fw_minor = data[1];
    const uint8_t fw_patch = data[2];
    const uint8_t features = data[3];
    const bool relays = (features & 0x01) != 0;
    const bool safety = (features & 0x02) != 0;
    if (!relays || !safety) {
        EVLOG_warning << "PLC " << node.cfg.plc_id << " reports missing features (relays=" << relays
                      << ", safety=" << safety << ") fw=" << static_cast<int>(fw_major) << "."
                      << static_cast<int>(fw_minor) << "." << static_cast<int>(fw_patch);
    }
    node.status.fw_major = fw_major;
    node.status.fw_minor = fw_minor;
    node.status.fw_patch = fw_patch;
    node.status.feature_flags = features;
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_rtev_log(Node& node, const uint8_t* data, size_t len) {
    if (len < 8) return;
    node.status.rx_count = le_u32(&data[0]);
    node.status.tx_count = le_u32(&data[4]);
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_rtt_log(Node& node, const uint8_t* data, size_t len) {
    if (len < 4) return;
    node.status.uptime_s = le_u32(&data[0]);
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_software_info(Node& node, const uint8_t* data, size_t len) {
    if (len < 8) return;
    node.status.fw_major = data[5];
    node.status.fw_minor = data[6];
    node.status.fw_patch = data[7];
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_error_codes(Node& node, const uint8_t* data, size_t len) {
    if (len < 1) return;
    node.status.error_code = data[0];
    if (node.status.error_code != 0) {
        EVLOG_error << "PLC " << node.cfg.plc_id << " error code " << static_cast<int>(node.status.error_code);
        node.status.safety.safety_ok = false;
    }
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::handle_hw_config(Node& node, const uint8_t* data, size_t len) {
    (void)data;
    (void)len;
    node.status.last_any_rx = std::chrono::steady_clock::now();
}

void PlcHardware::prune_segment_buffers(Node& node, const std::chrono::steady_clock::time_point& now) {
    auto stale = [&](const SegmentBuffer& buf) {
        return buf.last_rx.time_since_epoch().count() != 0 && (now - buf.last_rx) > SEGMENT_TTL;
    };
    for (auto it = node.rfid_events.begin(); it != node.rfid_events.end();) {
        if (stale(it->second)) {
            it = node.rfid_events.erase(it);
        } else {
            ++it;
        }
    }
    auto prune_single = [&](SegmentBuffer& buf) {
        if (stale(buf)) {
            buf = SegmentBuffer{};
        }
    };
    prune_single(node.evccid);
    prune_single(node.emaid0);
    prune_single(node.emaid1);
    prune_single(node.evmac);
}

void PlcHardware::handle_rfid_event(Node& node, const uint8_t* data, size_t len) {
    if (len < 3) return;
    const uint8_t len_nibble = static_cast<uint8_t>(data[0] & 0x0F);
    const uint8_t event_type = static_cast<uint8_t>((data[0] >> 4) & 0x0F);
    // Only handle UID events (type=0)
    if (event_type != 0 || len_nibble == 0) {
        return;
    }
    const uint8_t event_id = data[1];
    const uint8_t seg_idx = static_cast<uint8_t>(data[2] & 0x0F);
    const uint8_t seg_cnt_raw = static_cast<uint8_t>((data[2] >> 4) & 0x0F);
    const uint8_t expected_segments = std::max<uint8_t>(static_cast<uint8_t>(1), seg_cnt_raw);
    const auto now = std::chrono::steady_clock::now();
    auto& buf = node.rfid_events[event_id];
    const bool need_reset = buf.total_len != len_nibble || buf.expected_segments != expected_segments ||
        seg_idx == 0 || buf.data.size() < len_nibble;
    if (need_reset) {
        buf.reset(len_nibble, expected_segments, now);
    } else {
        buf.last_rx = now;
    }
    if (seg_idx >= buf.expected_segments) {
        buf.received.resize(seg_idx + 1, false);
    }
    const size_t payload_len = len > 3 ? std::min<size_t>(5, len - 3) : 0;
    const size_t offset = static_cast<size_t>(seg_idx) * 5;
    if (buf.data.size() < buf.total_len) {
        buf.data.resize(buf.total_len, 0);
    }
    for (size_t i = 0; i < payload_len && (offset + i) < buf.data.size(); ++i) {
        buf.data[offset + i] = data[3 + i];
    }
    if (seg_idx < buf.received.size()) {
        buf.received[seg_idx] = true;
    }
    if (buf.complete()) {
        AuthToken token;
        token.id_token = bytes_to_hex(buf.data, buf.total_len);
        token.source = AuthTokenSource::RFID;
        token.connector_hint = node.cfg.id;
        token.received_at = now;
        auth_events_.push_back(std::move(token));
        node.rfid_events.erase(event_id);
    }
}

void PlcHardware::handle_identity_segment(Node& node, SegmentBuffer& buffer, AuthTokenSource source,
                                          const uint8_t* data, size_t len) {
    if (len < 3) return;
    const uint8_t total_len = data[0];
    const uint8_t seg_cnt = data[1];
    const uint8_t seg_idx = data[2];
    if (total_len == 0) {
        return;
    }
    const auto now = std::chrono::steady_clock::now();
    const uint8_t expected_segments = std::max<uint8_t>(static_cast<uint8_t>(1), seg_cnt);
    const bool need_reset = buffer.total_len != total_len || buffer.expected_segments != expected_segments ||
        seg_idx == 0 || buffer.data.size() < total_len;
    if (need_reset) {
        buffer.reset(total_len, expected_segments, now);
    } else {
        buffer.last_rx = now;
    }
    if (seg_idx >= buffer.expected_segments) {
        buffer.received.resize(seg_idx + 1, false);
    }
    const size_t payload_len = len > 3 ? std::min<size_t>(5, len - 3) : 0;
    const size_t offset = static_cast<size_t>(seg_idx) * 5;
    if (buffer.data.size() < buffer.total_len) {
        buffer.data.resize(buffer.total_len, 0);
    }
    for (size_t i = 0; i < payload_len && (offset + i) < buffer.data.size(); ++i) {
        buffer.data[offset + i] = data[3 + i];
    }
    if (seg_idx < buffer.received.size()) {
        buffer.received[seg_idx] = true;
    }
    if (buffer.complete()) {
        AuthToken token;
        token.id_token = bytes_to_hex(buffer.data, buffer.total_len);
        token.source = source;
        token.connector_hint = node.cfg.id;
        token.received_at = now;
        auth_events_.push_back(std::move(token));
        buffer = SegmentBuffer{};
    }
}

bool PlcHardware::derive_lock_input(const Node& node, uint8_t sw_mask_byte, bool relay_status_frame) const {
    const int idx = node.cfg.lock_input_switch;
    if (idx < 1 || idx > 4) return true;
    (void)relay_status_frame;
    const int bit = (idx == 4) ? 6 : (idx - 1);
    return (sw_mask_byte & (1 << bit)) != 0;
}

bool PlcHardware::derive_hlc_power_ready(const PlcStatus& status, bool authorized) const {
    if (!authorized) {
        return false;
    }
    if (status.hlc_charge_complete) {
        return false;
    }
    if (status.hlc_stage >= HLC_POWER_DELIVERY_STAGE && (status.hlc_cable_check_ok || !status.hlc_precharge_active)) {
        return true;
    }
    return false;
}

void PlcHardware::update_hlc_state(Node& node, uint8_t stage, uint8_t flags) {
    node.status.hlc_stage = stage;
    node.status.hlc_charge_complete = (flags & 0x01) != 0;
    node.status.hlc_precharge_active = (flags & 0x02) != 0;
    node.status.hlc_cable_check_ok = (flags & 0x04) != 0;
    const bool auth_granted = (flags & 0x08) != 0;
    const bool auth_pending = (flags & 0x10) != 0;
    const bool lock_feedback = (flags & 0x20) != 0;
    node.authorization_granted = auth_granted;
    node.status.auth_pending_flag = auth_pending;
    node.lock_feedback_engaged = lock_feedback;
    node.lock_engaged = node.cfg.require_lock ? lock_feedback : true;
    node.status.hlc_power_ready = derive_hlc_power_ready(node.status, node.authorization_granted);
}

bool PlcHardware::supports_cross_slot_islands() const {
    return false;
}

void PlcHardware::update_cp_status(Node& node, char cp_state_char, uint8_t duty_pct, uint16_t mv_peak,
                                   uint16_t mv_min, bool has_mv, uint16_t mv_robust, bool has_robust) {
    auto& cp = node.status.cp;
    if (cp_state_char == 0) {
        cp_state_char = 'U';
    }
    cp.state_char = cp_state_char;
    cp.duty_pct = static_cast<double>(duty_pct);
    if (has_mv) {
        cp.mv_peak = mv_peak;
        cp.mv_min = mv_min;
    }
    if (has_robust) {
        cp.mv_robust = mv_robust;
    }
    cp.valid = true;
    cp.last_rx = std::chrono::steady_clock::now();
}

#ifdef __linux__
void PlcHardware::handle_error_frame(const struct can_frame& frame) {
    const uint32_t err = frame.can_id & CAN_ERR_MASK;
    const bool bus_off = (err & CAN_ERR_BUSOFF) != 0;
    const bool restarted = (err & CAN_ERR_RESTARTED) != 0;
    const bool ctrl_err = (err & CAN_ERR_CRTL) != 0;

    if (bus_off || ctrl_err) {
        EVLOG_error << "CAN error frame received (bus_off=" << bus_off << ", ctrl=" << ctrl_err << ")";
        for (auto& kv : nodes_) {
            kv.second.status.safety.comm_fault = true;
            kv.second.status.safety.safety_ok = false;
            kv.second.status.relay_closed = false;
        }
    }
    if (restarted) {
        EVLOG_info << "CAN controller restarted, clearing comm faults";
        for (auto& kv : nodes_) {
            kv.second.status.safety.comm_fault = false;
        }
    }
}
#endif

bool PlcHardware::send_gcmc_command(Node& node, uint8_t seq, bool close, bool force_all_off) {
#ifdef __linux__
    uint8_t data[8] = {};
    uint8_t cmd_bits = 0;
    if (close && (node.module_mask & 0x01)) cmd_bits |= 0x01; // GC_CMD
    if (node.mc_closed_cmd) cmd_bits |= 0x02;                 // MC_CMD
    if (close && (node.module_mask & 0x02)) cmd_bits |= 0x04; // MN0_CMD (module 1)
    if (close && (node.module_mask & 0x04)) cmd_bits |= 0x08; // MN1_CMD (module 2)
    data[0] = cmd_bits;
    data[1] = seq;
    data[2] = 0;
    data[3] = 0;
    data[4] = 0;
    data[5] = 0;
    data[6] = 0;
    data[7] = 0;
    if (force_all_off) data[0] |= (1 << 7);
    const bool clear_faults = node.status.last_fault_reason != 0;
    if (clear_faults) data[0] |= (1 << 6);
    if (use_crc8_) {
        data[7] = plc_crc8(data, 7);
    }
    uint32_t can_id = GCMC_CMD_BASE | static_cast<uint32_t>(node.cfg.plc_id & 0x0F);
    return send_frame(can_id | CAN_EFF_FLAG, data, sizeof(data));
#else
    (void)node;
    (void)seq;
    (void)close;
    (void)force_all_off;
    return false;
#endif
}

} // namespace charger


=== src/charger_config.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "charger_config.hpp"

#include <fstream>
#include <stdexcept>
#include <set>
#include <algorithm>
#include <cctype>
#include <limits>
#include <type_traits>
#include <cstddef>

#include <nlohmann/json.hpp>

namespace charger {

namespace {
fs::path make_absolute(const fs::path& base, const fs::path& relative_or_absolute) {
    if (relative_or_absolute.is_absolute()) {
        return relative_or_absolute;
    }
    return fs::weakly_canonical(base / relative_or_absolute);
}

void ensure_parent_dir(const fs::path& file_path) {
    const auto parent = file_path.parent_path();
    if (!parent.empty()) {
        fs::create_directories(parent);
    }
}

ConnectorConfig parse_connector(const nlohmann::json& connector_json, int default_interval) {
    ConnectorConfig connector;
    connector.id = connector_json.value("id", 1);
    connector.label = connector_json.value("label", "");
    connector.plc_id = connector_json.value("plcId", connector.id - 1);
    connector.can_interface = connector_json.value("canInterface", "");
    connector.max_current_a = connector_json.value("maxCurrentA", 0.0);
    connector.max_power_w = connector_json.value("maxPowerW", 0.0);
    connector.max_voltage_v = connector_json.value("maxVoltageV", 0.0);
    connector.min_voltage_v = connector_json.value("minVoltageV", 0.0);
    connector.meter_sample_interval_s = connector_json.value("meterSampleIntervalSeconds", default_interval);
    connector.require_lock = connector_json.value("requireLock", true);
    connector.lock_input_switch = connector_json.value("lockInputSwitch", 3);
    connector.meter_source = connector_json.value("meterSource", "plc");
    std::transform(connector.meter_source.begin(), connector.meter_source.end(), connector.meter_source.begin(),
                   [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
    connector.meter_scale = connector_json.value("meterScale", 1.0);
    connector.meter_offset_wh = connector_json.value("meterOffsetWh", 0.0);
    return connector;
}

SlotMapping parse_slot_mapping(const nlohmann::json& slot_json, int idx_fallback) {
    SlotMapping slot;
    slot.id = slot_json.value("id", idx_fallback);
    slot.gun_id = slot_json.value("gunId", slot.id);
    slot.gc_id = slot_json.value("gc", "GC_" + std::to_string(slot.id));
    slot.mc_id = slot_json.value("mc", "MC_" + std::to_string(slot.id));
    slot.cw_id = slot_json.value("cw", slot.id % 12 + 1);
    slot.ccw_id = slot_json.value("ccw", slot.id == 1 ? 12 : slot.id - 1);
    if (slot_json.contains("modules") && slot_json["modules"].is_array()) {
        for (const auto& m : slot_json["modules"]) {
            ModuleConfig mc;
            mc.id = m.value("id", "");
            mc.mn_id = m.value("mn", "");
            mc.type = m.value("type", "");
            mc.can_interface = m.value("canInterface", "");
            mc.address = m.value("address", -1);
            mc.group = m.value("group", 0);
            mc.rated_power_kw = m.value("ratedPowerKW", 0.0);
            mc.rated_current_a = m.value("ratedCurrentA", 0.0);
            mc.poll_interval_ms = m.value("pollMs", 500);
            mc.cmd_interval_ms = m.value("cmdIntervalMs", 500);
            mc.broadcast = m.value("broadcast", false);
            slot.modules.push_back(mc);
        }
    }
    if (slot.modules.empty()) {
        ModuleConfig m0{"M" + std::to_string(slot.id) + "_0", "MN_" + std::to_string(slot.id) + "_0"};
        ModuleConfig m1{"M" + std::to_string(slot.id) + "_1", "MN_" + std::to_string(slot.id) + "_1"};
        slot.modules = {m0, m1};
    }
    return slot;
}

nlohmann::json load_ocpp_base_config(const ChargerConfig& cfg) {
    if (!cfg.ocpp_config_inline.empty()) {
        return nlohmann::json::parse(cfg.ocpp_config_inline);
    }
    if (!cfg.ocpp_config.empty()) {
        if (!fs::exists(cfg.ocpp_config)) {
            throw std::runtime_error("OCPP base config missing: " + cfg.ocpp_config.string());
        }
        std::ifstream file(cfg.ocpp_config);
        return nlohmann::json::parse(file);
    }
    throw std::runtime_error("OCPP base config missing: provide an inline 'ocpp' block in charger.json");
}
} // namespace

ChargerConfig load_charger_config(const fs::path& config_path) {
    if (!fs::exists(config_path)) {
        throw std::runtime_error("Config file not found: " + config_path.string());
    }

    std::ifstream file(config_path);
    const auto json = nlohmann::json::parse(file);
    const auto base_dir = config_path.parent_path().empty() ? fs::current_path() : config_path.parent_path();

    ChargerConfig cfg{};
    const auto cp = json.value("chargePoint", nlohmann::json::object());
    cfg.charge_point_id = cp.value("id", "chargepoint-1");
    cfg.vendor = cp.value("vendor", "UnknownVendor");
    cfg.model = cp.value("model", "UnknownModel");
    cfg.firmware_version = cp.value("firmwareVersion", "0.0.0");
    cfg.central_system_uri = cp.value("centralSystemURI", "");
    cfg.use_plc = cp.value("usePLC", false);
    cfg.simulation_mode = cp.value("simulationMode", false);
    cfg.can_interface = cp.value("canInterface", "can0");
    const auto plc_cfg = json.value("plc", nlohmann::json::object());
    cfg.plc_use_crc8 = plc_cfg.value("useCRC8", true);
    cfg.plc_owns_gun_relay = plc_cfg.value("gunRelayOwnedByPlc", true);
    cfg.plc_module_relays_enabled = plc_cfg.value("moduleRelaysEnabled", true);
    cfg.require_https_uploads = plc_cfg.value("requireHttpsUploads", true);
    const auto uploads = json.value("uploads", nlohmann::json::object());
    cfg.upload_max_bytes = uploads.value("maxBytes", cfg.upload_max_bytes);
    cfg.upload_connect_timeout_s = uploads.value("connectTimeoutSeconds", cfg.upload_connect_timeout_s);
    cfg.upload_transfer_timeout_s = uploads.value("transferTimeoutSeconds", cfg.upload_transfer_timeout_s);
    cfg.upload_allow_file_targets = uploads.value("allowFileTargets", cfg.upload_allow_file_targets);
    const auto site_limits = json.value("siteLimits", nlohmann::json::object());
    cfg.module_power_kw = json.value("modulePowerKW", 30.0);
    cfg.grid_limit_kw = json.value("gridLimitKW", site_limits.value("gridPowerLimitKW", 1000.0));
    cfg.default_voltage_v = json.value("defaultVoltageV", site_limits.value("defaultVoltageV", 800.0));
    const auto planner = json.value("planner", nlohmann::json::object());
    auto planner_value = [&](const char* key, auto default_value) {
        using T = std::decay_t<decltype(default_value)>;
        if (planner.contains(key)) {
            return planner.value(key, default_value);
        }
        return json.value<T>(key, default_value);
    };
    const auto timeouts = json.value("timeouts", nlohmann::json::object());
    cfg.auth_wait_timeout_s = timeouts.value("authorizationSeconds", cfg.auth_wait_timeout_s);
    cfg.power_request_timeout_s = timeouts.value("powerRequestSeconds", cfg.power_request_timeout_s);
    cfg.evse_limit_ack_timeout_ms = timeouts.value("evseLimitAckMs", cfg.evse_limit_ack_timeout_ms);
    cfg.telemetry_timeout_ms = timeouts.value("telemetryTimeoutMs", cfg.telemetry_timeout_ms);
    cfg.plc_present_warn_ms = timeouts.value("plcPresentWarnMs", cfg.plc_present_warn_ms);
    cfg.plc_limits_warn_ms = timeouts.value("plcLimitsWarnMs", cfg.plc_limits_warn_ms);
    cfg.allow_cross_slot_islands = planner_value("allowCrossSlotIslands", cfg.allow_cross_slot_islands);
    cfg.max_modules_per_gun = planner_value("maxModulesPerGun", cfg.max_modules_per_gun);
    cfg.min_modules_per_active_gun = planner_value("minModulesPerActiveGun", cfg.min_modules_per_active_gun);
    cfg.max_island_radius = planner_value("maxIslandRadius", cfg.max_island_radius);
    cfg.min_module_hold_ms = planner_value("minModuleHoldMs", cfg.min_module_hold_ms);
    cfg.min_mc_hold_ms = planner_value("minMcHoldMs", cfg.min_mc_hold_ms);
    cfg.min_gc_hold_ms = planner_value("minGcHoldMs", cfg.min_gc_hold_ms);
    cfg.mc_open_current_a = planner_value("mcOpenCurrentA", cfg.mc_open_current_a);
    cfg.gc_open_current_a = planner_value("gcOpenCurrentA", cfg.gc_open_current_a);
    cfg.precharge_voltage_tolerance_v = planner_value("prechargeVoltageToleranceV", cfg.precharge_voltage_tolerance_v);
    cfg.precharge_timeout_ms = planner_value("prechargeTimeoutMs", cfg.precharge_timeout_ms);
    if (cfg.module_power_kw <= 0.0) {
        cfg.module_power_kw = 30.0;
    }
    if (cfg.grid_limit_kw <= 0.0) {
        cfg.grid_limit_kw = std::numeric_limits<double>::max();
    }
    if (cfg.default_voltage_v <= 0.0) {
        cfg.default_voltage_v = 800.0;
    }
    if (cfg.auth_wait_timeout_s <= 0) {
        cfg.auth_wait_timeout_s = 1800;
    }
    if (cfg.power_request_timeout_s <= 0) {
        cfg.power_request_timeout_s = 60;
    }
    if (cfg.evse_limit_ack_timeout_ms <= 0) {
        cfg.evse_limit_ack_timeout_ms = 1500;
    }
    if (cfg.telemetry_timeout_ms <= 0) {
        cfg.telemetry_timeout_ms = 2000;
    }

    if (json.contains("ocpp") && json["ocpp"].is_object()) {
        cfg.ocpp_config_inline = json["ocpp"].dump();
        const auto& ocpp_obj = json["ocpp"];
        if (ocpp_obj.contains("Core") && ocpp_obj["Core"].is_object()) {
            const auto& core = ocpp_obj["Core"];
            cfg.meter_sample_interval_s = core.value("MeterValueSampleInterval", cfg.meter_sample_interval_s);
            cfg.minimum_status_duration_s = core.value("MinimumStatusDuration", cfg.minimum_status_duration_s);
        }
    }

    const auto ocpp_config_path = json.value("ocppConfig", "");
    if (!ocpp_config_path.empty()) {
        cfg.ocpp_config = make_absolute(base_dir, ocpp_config_path);
    }
    cfg.share_path = make_absolute(base_dir, json.value("sharePath", "libocpp/config/v16"));
    cfg.user_config = make_absolute(base_dir, json.value("userConfig", "data/user_config.json"));
    cfg.database_dir = make_absolute(base_dir, json.value("databaseDir", "data/db"));
    cfg.sql_migrations = make_absolute(base_dir, json.value("sqlMigrationsPath", "libocpp/config/v16/core_migrations"));
    cfg.message_log_path = make_absolute(base_dir, json.value("messageLogPath", "logs"));
    cfg.logging_config = make_absolute(base_dir, json.value("loggingConfig", "libocpp/config/logging.ini"));

    cfg.meter_sample_interval_s = json.value("meterSampleIntervalSeconds", 30);
    cfg.meter_keepalive_s = json.value("meterKeepAliveSeconds", cfg.meter_keepalive_s);
    cfg.minimum_status_duration_s = json.value("minimumStatusDurationSeconds", cfg.minimum_status_duration_s);

    const auto security = json.value("security", nlohmann::json::object());
    cfg.security.csms_ca_bundle = make_absolute(base_dir, security.value("csmsCaBundle", "data/certs/ca/csms/CSMS_ROOT_CA.pem"));
    cfg.security.mo_ca_bundle = make_absolute(base_dir, security.value("moCaBundle", "data/certs/ca/mo/MO_ROOT_CA.pem"));
    cfg.security.v2g_ca_bundle = make_absolute(base_dir, security.value("v2gCaBundle", "data/certs/ca/v2g/V2G_ROOT_CA.pem"));
    cfg.security.client_cert_dir = make_absolute(base_dir, security.value("clientCertDir", "data/certs/client/csms"));
    cfg.security.client_key_dir = make_absolute(base_dir, security.value("clientKeyDir", "data/certs/client/csms"));
    cfg.security.secc_cert_dir = make_absolute(base_dir, security.value("seccCertDir", "data/certs/client/cso"));
    cfg.security.secc_key_dir = make_absolute(base_dir, security.value("seccKeyDir", "data/certs/client/cso"));

    if (json.contains("connectors") && json["connectors"].is_array()) {
        for (const auto& connector_json : json["connectors"]) {
            cfg.connectors.push_back(parse_connector(connector_json, cfg.meter_sample_interval_s));
        }
    }
    if (json.contains("slots") && json["slots"].is_array()) {
        int idx = 1;
        for (const auto& slot_json : json["slots"]) {
            cfg.slots.push_back(parse_slot_mapping(slot_json, idx++));
        }
    }

    for (auto& c : cfg.connectors) {
        if (c.can_interface.empty()) {
            c.can_interface = cfg.can_interface;
        }
        if (c.lock_input_switch < 1 || c.lock_input_switch > 4) {
            c.lock_input_switch = 3;
        }
        if (c.meter_scale <= 0.0) {
            c.meter_scale = 1.0;
        }
        if (c.meter_source != "plc" && c.meter_source != "shunt") {
            c.meter_source = "plc";
        }
        if (c.min_voltage_v < 0.0) {
            c.min_voltage_v = 0.0;
        }
        if (c.max_voltage_v > 0.0 && c.min_voltage_v > c.max_voltage_v) {
            c.min_voltage_v = c.max_voltage_v * 0.5;
        }
    }

    if (cfg.connectors.empty()) {
        // Provide at least connector 1 to keep libocpp happy
        cfg.connectors.push_back(ConnectorConfig{});
    }

    if (cfg.slots.empty()) {
        for (std::size_t i = 0; i < cfg.connectors.size(); ++i) {
            const auto& conn = cfg.connectors[i];
            SlotMapping sm;
            sm.id = conn.id;
            sm.gun_id = conn.id;
            sm.gc_id = "GC_" + std::to_string(conn.id);
            sm.mc_id = "MC_" + std::to_string(conn.id);
            sm.cw_id = cfg.connectors[(i + 1) % cfg.connectors.size()].id;
            sm.ccw_id = cfg.connectors[(i + cfg.connectors.size() - 1) % cfg.connectors.size()].id;
            ModuleConfig m0{"M" + std::to_string(conn.id) + "_0", "MN_" + std::to_string(conn.id) + "_0"};
            ModuleConfig m1{"M" + std::to_string(conn.id) + "_1", "MN_" + std::to_string(conn.id) + "_1"};
            sm.modules = {m0, m1};
            cfg.slots.push_back(sm);
        }
    }

    // Normalize and validate module metadata for plugin drivers.
    {
        std::set<std::tuple<std::string, int, int>> seen_addresses;
        for (auto& slot : cfg.slots) {
            for (auto& m : slot.modules) {
                if (m.can_interface.empty()) {
                    m.can_interface = cfg.can_interface;
                }
                if (m.group < 0) {
                    m.group = 0;
                }
                if (m.group > 60) {
                    m.group = 60;
                }
                if (!m.type.empty()) {
                    std::transform(m.type.begin(), m.type.end(), m.type.begin(),
                                   [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
                    if (!m.broadcast) {
                        if (m.address < 0 || m.address > 63) {
                            throw std::runtime_error("Module " + m.id + " has invalid address (expected 0-63)");
                        }
                    } else {
                        // Broadcast allows 0xFE (group broadcast) or 0xFF (global)
                        if (m.address < 0) m.address = 0xFE;
                    }
                    if (m.rated_power_kw <= 0.0) {
                        m.rated_power_kw = cfg.module_power_kw;
                    }
                    if (m.rated_current_a < 0.0) {
                        m.rated_current_a = 0.0;
                    }
                    m.poll_interval_ms = std::max(100, m.poll_interval_ms);
                    m.cmd_interval_ms = std::max(100, m.cmd_interval_ms);
                    const auto key = std::make_tuple(m.can_interface, m.group, m.address);
                    if (!m.broadcast) {
                        if (!seen_addresses.insert(key).second) {
                            throw std::runtime_error("Duplicate module CAN address " + std::to_string(m.address) +
                                                     " on interface " + m.can_interface + " group " +
                                                     std::to_string(m.group));
                        }
                    }
                }
            }
        }
    }

    // PLC validation: unique PLC IDs and single CAN interface (current driver uses one socket)
    if (cfg.use_plc) {
        std::set<int> plc_ids;
        std::set<std::string> ifaces;
        for (const auto& c : cfg.connectors) {
            if (plc_ids.count(c.plc_id)) {
                throw std::runtime_error("Duplicate PLC id " + std::to_string(c.plc_id) +
                                         " across connectors. Use unique plcId per connector.");
            }
            plc_ids.insert(c.plc_id);
            ifaces.insert(c.can_interface);
        }
        if (ifaces.size() > 1) {
            throw std::runtime_error("PLC config invalid: multiple CAN interfaces defined. Current host driver opens a "
                                     "single SocketCAN interface; set the same canInterface for all connectors.");
        }
        if (!ifaces.empty()) {
            cfg.can_interface = *ifaces.begin();
        }
    }

    // Prepare filesystem locations early so libocpp can open them
    ensure_parent_dir(cfg.user_config);
    if (!fs::exists(cfg.user_config)) {
        std::ofstream out(cfg.user_config);
        out << "{}";
    }
    fs::create_directories(cfg.database_dir);
    fs::create_directories(cfg.message_log_path);
    fs::create_directories(cfg.security.client_cert_dir);
    fs::create_directories(cfg.security.client_key_dir);
    fs::create_directories(cfg.security.secc_cert_dir);
    fs::create_directories(cfg.security.secc_key_dir);
    fs::create_directories(cfg.security.csms_ca_bundle.parent_path());
    fs::create_directories(cfg.security.mo_ca_bundle.parent_path());
    fs::create_directories(cfg.security.v2g_ca_bundle.parent_path());

    return cfg;
}

std::string load_and_patch_ocpp_config(const ChargerConfig& cfg) {
    auto json = load_ocpp_base_config(cfg);

    json["Internal"]["ChargePointId"] = cfg.charge_point_id;
    json["Internal"]["ChargeBoxSerialNumber"] = cfg.charge_point_id;
    json["Internal"]["ChargePointModel"] = cfg.model;
    json["Internal"]["ChargePointVendor"] = cfg.vendor;
    json["Internal"]["FirmwareVersion"] = cfg.firmware_version;
    if (!cfg.central_system_uri.empty()) {
        json["Internal"]["CentralSystemURI"] = cfg.central_system_uri;
    }

    const auto connector_count = static_cast<int>(cfg.connectors.size());
    json["Core"]["NumberOfConnectors"] = connector_count;
    if (cfg.minimum_status_duration_s > 0) {
        json["Core"]["MinimumStatusDuration"] = cfg.minimum_status_duration_s;
    }
    if (cfg.meter_sample_interval_s > 0) {
        json["Core"]["MeterValueSampleInterval"] = cfg.meter_sample_interval_s;
    }

    return json.dump();
}

} // namespace charger


=== src/hardware_sim.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "hardware_sim.hpp"

#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <cstdio>
#include <mutex>
#include <utility>
#include <curl/curl.h>
#include <everest/logging.hpp>
#include <ocpp/v16/ocpp_enums.hpp>

namespace {

std::string bundle_logs(const std::string& prefix) {
    const auto ts = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    const std::string dir = "logs";
    std::filesystem::create_directories(dir);
    const std::string fname = dir + "/" + prefix + "_" + std::to_string(ts) + ".log";
    std::ofstream out(fname, std::ios::out | std::ios::trunc);
    out << "Log bundle generated at " << ts << "\n";
    for (const auto& entry : std::filesystem::directory_iterator(dir)) {
        if (!entry.is_regular_file()) continue;
        if (entry.path().string() == fname) continue;
        out << "\n==== " << entry.path().filename().string() << " ====\n";
        std::ifstream in(entry.path());
        out << in.rdbuf();
    }
    return fname;
}

bool is_http_url(const std::string& target) {
    return target.rfind("http://", 0) == 0 || target.rfind("https://", 0) == 0;
}

bool upload_via_curl(const std::string& source, const std::string& url, bool require_https,
                     int connect_timeout_s, int transfer_timeout_s) {
    if (url.empty()) return false;
    if (require_https && url.rfind("https://", 0) != 0) {
        EVLOG_warning << "Rejecting non-HTTPS upload target " << url;
        return false;
    }
    static std::once_flag curl_once;
    std::call_once(curl_once, []() { curl_global_init(CURL_GLOBAL_DEFAULT); });

    CURL* curl = curl_easy_init();
    if (!curl) return false;

    std::FILE* file = std::fopen(source.c_str(), "rb");
    if (!file) {
        curl_easy_cleanup(curl);
        return false;
    }
    const auto size = std::filesystem::file_size(source);
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
    curl_easy_setopt(curl, CURLOPT_READDATA, file);
    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, static_cast<curl_off_t>(size));
    curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 0L);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, connect_timeout_s > 0 ? connect_timeout_s : 10);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, transfer_timeout_s > 0 ? transfer_timeout_s : 60);

    const CURLcode res = curl_easy_perform(curl);
    std::fclose(file);
    curl_easy_cleanup(curl);
    return res == CURLE_OK;
}

bool upload_file_to_target(const std::string& source,
                           const std::string& target,
                           bool require_https,
                           std::size_t max_bytes,
                           int connect_timeout_s,
                           int transfer_timeout_s,
                           bool allow_file_targets) {
    if (target.empty()) return false;

    std::error_code ec;
    const auto source_size = std::filesystem::file_size(source, ec);
    if (ec || source_size > max_bytes) {
        EVLOG_warning << "Rejecting upload: size exceeds limit or unreadable (" << source << ")";
        return false;
    }

    if (is_http_url(target)) {
        return upload_via_curl(source, target, require_https, connect_timeout_s, transfer_timeout_s);
    }
    if (!allow_file_targets) {
        EVLOG_warning << "File uploads disabled; rejecting target " << target;
        return false;
    }
    std::string path = target;
    const std::string prefix = "file://";
    if (path.rfind(prefix, 0) == 0) {
        path = path.substr(prefix.size());
    }
    const auto canonical_parent = std::filesystem::weakly_canonical(std::filesystem::path(path).parent_path(), ec);
    if (ec) {
        EVLOG_warning << "Rejecting upload: invalid path " << path;
        return false;
    }
    std::filesystem::create_directories(canonical_parent, ec);
    const auto dest_path = std::filesystem::weakly_canonical(path, ec);
    if (ec) {
        EVLOG_warning << "Rejecting upload: invalid destination " << path;
        return false;
    }
    std::filesystem::copy_file(source, dest_path, std::filesystem::copy_options::overwrite_existing, ec);
    return !ec;
}

bool download_via_curl(const std::string& url, const std::string& destination, bool require_https,
                       int connect_timeout_s, int transfer_timeout_s) {
    if (url.empty()) return false;
    if (require_https && url.rfind("https://", 0) != 0) {
        EVLOG_warning << "Rejecting non-HTTPS firmware URL " << url;
        return false;
    }
    static std::once_flag curl_once;
    std::call_once(curl_once, []() { curl_global_init(CURL_GLOBAL_DEFAULT); });
    CURL* curl = curl_easy_init();
    if (!curl) return false;

    std::FILE* file = std::fopen(destination.c_str(), "wb");
    if (!file) {
        curl_easy_cleanup(curl);
        return false;
    }

    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, nullptr);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);
    curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, connect_timeout_s > 0 ? connect_timeout_s : 10);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, transfer_timeout_s > 0 ? transfer_timeout_s : 60);

    const CURLcode res = curl_easy_perform(curl);
    std::fclose(file);
    curl_easy_cleanup(curl);
    return res == CURLE_OK;
}

bool fetch_firmware(const std::string& location,
                    std::size_t max_bytes,
                    bool require_https,
                    int connect_timeout_s,
                    int transfer_timeout_s,
                    bool allow_file_targets) {
    if (location.empty()) return false;
    std::error_code ec;
    const std::string dest = "data/firmware/download.bin";
    std::filesystem::create_directories(std::filesystem::path(dest).parent_path(), ec);
    if (is_http_url(location)) {
        if (!download_via_curl(location, dest, require_https, connect_timeout_s, transfer_timeout_s)) {
            return false;
        }
    } else {
        if (!allow_file_targets) return false;
        std::string src = location;
        const std::string prefix = "file://";
        if (src.rfind(prefix, 0) == 0) {
            src = src.substr(prefix.size());
        }
        std::filesystem::copy_file(src, dest, std::filesystem::copy_options::overwrite_existing, ec);
        if (ec) return false;
    }
    const auto size = std::filesystem::file_size(dest, ec);
    if (ec || size > max_bytes) {
        EVLOG_warning << "Firmware download failed size check";
        std::filesystem::remove(dest, ec);
        return false;
    }
    return true;
}

} // namespace

namespace charger {

SimulatedHardware::SimulatedHardware(const ChargerConfig& cfg) {
    require_https_uploads_ = cfg.require_https_uploads;
    upload_max_bytes_ = cfg.upload_max_bytes;
    upload_connect_timeout_s_ = cfg.upload_connect_timeout_s;
    upload_transfer_timeout_s_ = cfg.upload_transfer_timeout_s;
    upload_allow_file_targets_ = cfg.upload_allow_file_targets;
    const auto now = std::chrono::steady_clock::now();
    for (const auto& conn_cfg : cfg.connectors) {
        ConnectorState state{};
        state.config = conn_cfg;
        state.enabled = true;
        state.charging = false;
        state.reserved = false;
        state.target_power_w = conn_cfg.max_power_w;
        state.energy_Wh = 0.0;
        state.plugged_in = false;
        state.request_power = false;
        state.authorized = false;
        state.auth_state = AuthorizationState::Unknown;
        state.last_update = now;
        connectors_.emplace(conn_cfg.id, state);
    }
}

SimulatedHardware::ConnectorState& SimulatedHardware::get_state(std::int32_t connector) {
    auto it = connectors_.find(connector);
    if (it == connectors_.end()) {
        throw std::runtime_error("Unknown connector id " + std::to_string(connector));
    }
    return it->second;
}

void SimulatedHardware::update_energy(ConnectorState& state) {
    const auto now = std::chrono::steady_clock::now();
    const auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - state.last_update).count() / 1000.0;
    if (elapsed > 0 && state.charging) {
        const auto energy_added_Wh = (state.target_power_w * elapsed) / 3600.0;
        state.energy_Wh += energy_added_Wh;
    }
    state.last_update = now;
}

bool SimulatedHardware::enable(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    if (!state.lock_engaged && state.config.require_lock) {
        return false;
    }
    state.enabled = true;
    return true;
}

bool SimulatedHardware::disable(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    state.enabled = false;
    state.charging = false;
    state.request_power = false;
    state.authorized = false;
    state.auth_state = AuthorizationState::Denied;
    state.lock_engaged = true;
    return true;
}

bool SimulatedHardware::pause_charging(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    update_energy(state);
    state.charging = false;
    return true;
}

bool SimulatedHardware::resume_charging(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    update_energy(state);
    state.charging = state.enabled;
    return state.enabled;
}

bool SimulatedHardware::stop_transaction(std::int32_t connector, ocpp::v16::Reason /*reason*/) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    update_energy(state);
    state.charging = false;
    state.request_power = false;
    state.reserved = false;
    state.reservation_id.reset();
    state.authorized = false;
    state.auth_state = AuthorizationState::Unknown;
    return true;
}

ocpp::v16::UnlockStatus SimulatedHardware::unlock(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    state.lock_engaged = false;
    return ocpp::v16::UnlockStatus::Unlocked;
}

ocpp::v16::ReservationStatus SimulatedHardware::reserve(std::int32_t reservation_id, std::int32_t connector,
                                                        ocpp::DateTime /*expiry*/, const std::string& /*id_tag*/,
                                                        const std::optional<std::string>& /*parent_id*/) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    if (state.reserved) {
        return ocpp::v16::ReservationStatus::Rejected;
    }
    state.reserved = true;
    state.reservation_id = reservation_id;
    return ocpp::v16::ReservationStatus::Accepted;
}

bool SimulatedHardware::cancel_reservation(std::int32_t reservation_id) {
    std::lock_guard<std::mutex> lock(mutex_);
    for (auto& [id, state] : connectors_) {
        if (state.reservation_id && state.reservation_id.value() == reservation_id) {
            state.reservation_id.reset();
            state.reserved = false;
            return true;
        }
    }
    return false;
}

ocpp::v16::GetLogResponse SimulatedHardware::upload_diagnostics(const ocpp::v16::GetDiagnosticsRequest& request) {
    ocpp::v16::GetLogResponse response;
    response.status = ocpp::v16::LogStatusEnumType::Accepted;
    const std::string fname = bundle_logs("diagnostics");
    {
        std::ofstream out(fname, std::ios::app);
        out << "Diagnostics request location: " << request.location << "\n";
    }
    bool upload_ok = true;
    if (!request.location.empty()) {
        upload_ok = upload_file_to_target(fname, request.location, require_https_uploads_,
                                          upload_max_bytes_, upload_connect_timeout_s_,
                                          upload_transfer_timeout_s_, upload_allow_file_targets_);
        if (!upload_ok) {
            EVLOG_warning << "Diagnostics upload to " << request.location << " failed";
        }
    }
    if (!upload_ok) {
        response.status = ocpp::v16::LogStatusEnumType::Rejected;
    }
    response.filename.emplace(fname);
    return response;
}

ocpp::v16::GetLogResponse SimulatedHardware::upload_logs(const ocpp::v16::GetLogRequest& request) {
    ocpp::v16::GetLogResponse response;
    response.status = ocpp::v16::LogStatusEnumType::Accepted;
    const std::string fname = bundle_logs("logs");
    {
        std::ofstream out(fname, std::ios::app);
        out << "Log upload target: " << request.log.remoteLocation << "\n";
    }
    bool upload_ok = true;
    if (!request.log.remoteLocation.get().empty()) {
        upload_ok = upload_file_to_target(fname, request.log.remoteLocation, require_https_uploads_,
                                          upload_max_bytes_, upload_connect_timeout_s_,
                                          upload_transfer_timeout_s_, upload_allow_file_targets_);
        if (!upload_ok) {
            EVLOG_warning << "Log upload to " << request.log.remoteLocation << " failed";
        }
    }
    if (!upload_ok) {
        response.status = ocpp::v16::LogStatusEnumType::Rejected;
    }
    response.filename.emplace(fname);
    return response;
}

void SimulatedHardware::update_firmware(const ocpp::v16::UpdateFirmwareRequest& request) {
    const bool ok = fetch_firmware(request.location, upload_max_bytes_, require_https_uploads_,
                                   upload_connect_timeout_s_, upload_transfer_timeout_s_, upload_allow_file_targets_);
    if (!ok) {
        EVLOG_warning << "Simulated firmware download failed for " << request.location;
    } else {
        EVLOG_info << "Simulated firmware downloaded from " << request.location << " scheduled at "
                   << request.retrieveDate.to_rfc3339();
    }
}

ocpp::v16::UpdateFirmwareStatusEnumType
SimulatedHardware::update_firmware_signed(const ocpp::v16::SignedUpdateFirmwareRequest& request) {
    const bool ok = fetch_firmware(request.firmware.location, upload_max_bytes_, require_https_uploads_,
                                   upload_connect_timeout_s_, upload_transfer_timeout_s_, upload_allow_file_targets_);
    return ok ? ocpp::v16::UpdateFirmwareStatusEnumType::Accepted
              : ocpp::v16::UpdateFirmwareStatusEnumType::Rejected;
}

void SimulatedHardware::set_connection_timeout(std::int32_t seconds) {
    EVLOG_debug << "Connection timeout set to " << seconds << " seconds";
}

bool SimulatedHardware::is_reset_allowed(const ocpp::v16::ResetType& /*reset_type*/) {
    return true;
}

void SimulatedHardware::reset(const ocpp::v16::ResetType& reset_type) {
    EVLOG_info << "Simulated reset of type " << ocpp::v16::conversions::reset_type_to_string(reset_type);
}

void SimulatedHardware::on_remote_start_token(const std::string& id_token,
                                              const std::vector<std::int32_t>& referenced_connectors,
                                              bool prevalidated) {
    EVLOG_info << "Remote start token received: " << id_token << " (prevalidated=" << std::boolalpha << prevalidated
               << ") for connectors " << referenced_connectors.size();
}

ocpp::Measurement SimulatedHardware::sample_meter(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    update_energy(state);

    ocpp::Measurement measurement{};
    measurement.power_meter.timestamp = ocpp::DateTime().to_rfc3339();
    const double scale = state.config.meter_scale;
    measurement.power_meter.energy_Wh_import.total =
        state.energy_Wh * scale + state.config.meter_offset_wh;
    measurement.power_meter.power_W.emplace();
    measurement.power_meter.power_W->total =
        static_cast<float>((state.charging ? state.target_power_w : 0.0) * scale);
    measurement.power_meter.current_A.emplace();
    measurement.power_meter.current_A->DC =
        state.charging ? std::optional<float>(static_cast<float>((state.target_power_w / 400.0) * scale))
                       : std::nullopt;
    measurement.power_meter.voltage_V.emplace();
    measurement.power_meter.voltage_V->DC = 400.0F;
    return measurement;
}

GunStatus SimulatedHardware::get_status(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (status_override_.count(connector) && status_override_[connector].has_value()) {
        return status_override_[connector].value();
    }
    auto& state = get_state(connector);
    const auto fault_it = fault_overrides_.find(connector);
    const FaultOverride* fault = fault_it != fault_overrides_.end() ? &fault_it->second : nullptr;
    GunStatus st{};
    st.safety_ok = true;
    st.relay_closed = state.enabled && state.charging;
    st.meter_stale = false;
    const bool ev_connected = state.plugged_in;
    const bool ev_requests_power = state.request_power || state.charging;
    st.plugged_in = ev_connected;
    st.cp_fault = false;
    st.cp_state = ev_connected ? (ev_requests_power ? 'C' : 'B') : 'U';
    st.pilot_duty_pct = ev_connected ? 100.0 : 0.0;
    st.hlc_stage = st.relay_closed ? 5 : (ev_connected ? 4 : 0);
    st.hlc_cable_check_ok = ev_connected;
    st.hlc_precharge_active = false;
    st.hlc_charge_complete = false;
    st.hlc_power_ready = state.auth_state == AuthorizationState::Granted && (st.relay_closed || ev_requests_power);
    st.lock_engaged = state.lock_engaged || !state.config.require_lock;
    st.authorization_granted = state.auth_state == AuthorizationState::Granted;
    st.module_healthy_mask = fault && fault->healthy_mask ? *fault->healthy_mask : 0x03;
    st.module_fault_mask = fault && fault->fault_mask ? *fault->fault_mask : 0x00;
    st.gc_welded = fault ? fault->gc_welded : false;
    st.mc_welded = fault ? fault->mc_welded : false;
    const double present_voltage = 400.0;
    const double present_current = state.charging ? state.target_power_w / present_voltage : 0.0;
    const double present_power_w = state.charging ? state.target_power_w : 0.0;
    st.present_voltage_v = present_voltage;
    st.present_current_a = present_current;
    st.present_power_w = present_power_w;
    st.target_voltage_v = present_voltage;
    st.target_current_a = present_current;
    const auto apply_limit = [](std::optional<double> primary, double fallback) -> std::optional<double> {
        if (primary && *primary > 0.0) return primary;
        if (fallback > 0.0) return std::optional<double>(fallback);
        return std::nullopt;
    };
    st.evse_max_power_kw = apply_limit(state.evse_limits.max_power_kw, state.config.max_power_w > 0.0
                                                                    ? state.config.max_power_w / 1000.0
                                                                    : 0.0);
    st.evse_max_voltage_v = apply_limit(state.evse_limits.max_voltage_v, state.config.max_voltage_v);
    st.evse_max_current_a = apply_limit(state.evse_limits.max_current_a, state.config.max_current_a);
    st.module_temp_c = fault ? fault->module_temp_c : std::array<double, 2>{{40.0, 40.0}};
    st.connector_temp_c = fault && fault->connector_temp_c ? *fault->connector_temp_c : 40.0;
    st.last_telemetry = std::chrono::steady_clock::now();
    st.estop = fault ? fault->estop : false;
    st.earth_fault = fault ? fault->earth_fault : false;
    st.isolation_fault = fault ? fault->isolation_fault : false;
    st.overtemp_fault = fault ? fault->overtemp_fault : false;
    st.overcurrent_fault = fault ? fault->overcurrent_fault : false;
    st.comm_fault = fault ? fault->comm_fault : false;
    if (fault && fault->disabled) {
        st.safety_ok = false;
    }
    if (st.estop || st.earth_fault || st.isolation_fault || st.overtemp_fault || st.overcurrent_fault ||
        st.comm_fault) {
        st.safety_ok = false;
    }
    return st;
}

void SimulatedHardware::apply_power_command(const PowerCommand& cmd) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(cmd.connector);
    const auto fault_it = fault_overrides_.find(cmd.connector);
    const FaultOverride* fault = fault_it != fault_overrides_.end() ? &fault_it->second : nullptr;
    update_energy(state);
    const bool disabled = fault && fault->disabled;
    const bool paused = fault && fault->paused;
    const bool enable = cmd.module_count > 0 && cmd.gc_closed && !disabled &&
        state.auth_state == AuthorizationState::Granted;
    state.enabled = enable;
    state.charging = enable && !paused;
    double target_power_w = cmd.power_kw * 1000.0;
    if (cmd.current_limit_a > 0.0 && cmd.voltage_set_v > 0.0) {
        const double current_limited = cmd.current_limit_a * cmd.voltage_set_v;
        if (target_power_w <= 0.0) {
            target_power_w = current_limited;
        } else {
            target_power_w = std::min(target_power_w, current_limited);
        }
    }
    if (target_power_w <= 0.0 && enable) {
        target_power_w = state.target_power_w > 0.0 ? state.target_power_w : state.config.max_power_w;
    }
    if (state.config.max_power_w > 0.0 && target_power_w > 0.0) {
        target_power_w = std::min(target_power_w, state.config.max_power_w);
    }
    if (!enable || paused) {
        target_power_w = 0.0;
    }
    state.target_power_w = std::max(0.0, target_power_w);
}

void SimulatedHardware::apply_power_allocation(std::int32_t connector, int modules) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    state.enabled = modules > 0;
    if (!state.enabled) {
        state.charging = false;
    }
}

void SimulatedHardware::set_fault_override(std::int32_t connector, const FaultOverride& fault) {
    std::lock_guard<std::mutex> lock(mutex_);
    fault_overrides_[connector] = fault;
}

void SimulatedHardware::clear_fault_override(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    fault_overrides_.erase(connector);
}

void SimulatedHardware::set_paused(std::int32_t connector, bool paused) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& fo = fault_overrides_[connector];
    fo.paused = paused;
}

void SimulatedHardware::set_disabled(std::int32_t connector, bool disabled) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& fo = fault_overrides_[connector];
    fo.disabled = disabled;
}

void SimulatedHardware::set_authorization_state(std::int32_t connector, bool authorized) {
    set_authorization_state(connector, authorized ? AuthorizationState::Granted : AuthorizationState::Denied);
}

void SimulatedHardware::set_authorization_state(std::int32_t connector, AuthorizationState state) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& st = get_state(connector);
    st.auth_state = state;
    st.authorized = (state == AuthorizationState::Granted);
    if (state != AuthorizationState::Granted) {
        st.charging = false;
        st.request_power = false;
    }
}

void SimulatedHardware::set_plugged_in(std::int32_t connector, bool plugged, bool lock_engaged) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    update_energy(state);
    state.plugged_in = plugged;
    state.lock_engaged = lock_engaged || !state.config.require_lock;
    if (!plugged) {
        state.request_power = false;
        state.charging = false;
        state.enabled = false;
        state.target_power_w = 0.0;
        state.authorized = false;
        state.auth_state = AuthorizationState::Unknown;
    }
}

void SimulatedHardware::set_ev_power_request(std::int32_t connector, bool request) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    state.request_power = request;
}

void SimulatedHardware::set_evse_limits(std::int32_t connector, const EvseLimits& limits) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto& state = get_state(connector);
    state.evse_limits = limits;
}

void SimulatedHardware::publish_fault_state(std::int32_t connector, uint8_t fault_bits) {
    (void)connector;
    (void)fault_bits;
}

std::vector<AuthToken> SimulatedHardware::poll_auth_tokens() {
    std::lock_guard<std::mutex> lock(mutex_);
    std::vector<AuthToken> tokens;
    tokens.swap(auth_events_);
    return tokens;
}

void SimulatedHardware::inject_auth_token(const AuthToken& token) {
    std::lock_guard<std::mutex> lock(mutex_);
    AuthToken t = token;
    t.received_at = std::chrono::steady_clock::now();
    auth_events_.push_back(std::move(t));
}

void SimulatedHardware::set_status_override(std::int32_t connector, const GunStatus& status) {
    std::lock_guard<std::mutex> lock(mutex_);
    status_override_[connector] = status;
}

void SimulatedHardware::clear_status_override(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(mutex_);
    status_override_.erase(connector);
}

bool SimulatedHardware::supports_cross_slot_islands() const {
    return false;
}

} // namespace charger


=== src/island_manager.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "island_manager.hpp"

#include <queue>

namespace charger {

IslandManager::IslandManager(std::vector<Slot> slots) {
    set_slots(std::move(slots));
}

void IslandManager::set_slots(std::vector<Slot> slots) {
    slots_ = std::move(slots);
    slot_lookup_.clear();
    for (const auto& s : slots_) {
        slot_lookup_[s.id] = s;
    }
}

void IslandManager::set_mc_states(const std::map<std::string, ContactorState>& mc_states) {
    mc_states_ = mc_states;
}

std::vector<IslandInfo> IslandManager::compute_islands() const {
    std::vector<IslandInfo> islands;
    if (slots_.empty()) return islands;

    // Build adjacency based on closed MC boundaries. MC open breaks the edge from slot -> cw neighbor.
    std::map<int, std::set<int>> adj;
    for (const auto& s : slots_) {
        bool mc_closed = true;
        auto it = mc_states_.find(s.mc_id);
        if (it != mc_states_.end()) {
            mc_closed = (it->second == ContactorState::Closed);
        }
        if (mc_closed) {
            adj[s.id].insert(s.cw_id);
            adj[s.cw_id].insert(s.id);
        }
    }

    std::set<int> visited;
    for (const auto& s : slots_) {
        if (visited.count(s.id)) continue;
        IslandInfo isl;
        std::queue<int> q;
        q.push(s.id);
        visited.insert(s.id);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            isl.slots.push_back(cur);
            for (int nb : adj[cur]) {
                if (!visited.count(nb)) {
                    visited.insert(nb);
                    q.push(nb);
                }
            }
        }
        // Collect open MCs that bound this island.
        for (int sid : isl.slots) {
            const auto it_slot = slot_lookup_.find(sid);
            if (it_slot == slot_lookup_.end()) continue;
            const auto& slot = it_slot->second;
            auto it_state = mc_states_.find(slot.mc_id);
            bool mc_closed = !(it_state != mc_states_.end() && it_state->second == ContactorState::Open);
            if (!mc_closed) {
                isl.open_mcs.push_back(slot.mc_id);
            }
        }
        islands.push_back(isl);
    }
    return islands;
}

} // namespace charger


=== src/main.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "charger_config.hpp"
#include "can_plc.hpp"
#include "hardware_sim.hpp"
#include "ocpp_adapter.hpp"

#include <atomic>
#include <csignal>
#include <iostream>
#include <chrono>
#include <thread>

namespace {
std::atomic<bool> keep_running{true};

void handle_signal(int) {
    keep_running = false;
}

std::string parse_config_path(int argc, char* argv[]) {
    std::string path = "configs/charger.json";
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if ((arg == "--config" || arg == "-c") && i + 1 < argc) {
            path = argv[i + 1];
        }
    }
    return path;
}
} // namespace

int main(int argc, char* argv[]) {
    const auto config_path = parse_config_path(argc, argv);

    charger::ChargerConfig cfg;
    try {
        cfg = charger::load_charger_config(config_path);
    } catch (const std::exception& e) {
        std::cerr << "Failed to load config: " << e.what() << std::endl;
        return 1;
    }

    std::shared_ptr<charger::HardwareInterface> hardware;
    bool plc_available = false;
    try {
        if (cfg.use_plc) {
            hardware = std::make_shared<charger::PlcHardware>(cfg);
            plc_available = true;
        }
    } catch (const std::exception& e) {
        std::cerr << "PLC hardware init failed (" << e.what() << "), falling back to simulation." << std::endl;
    }
    if (!hardware) {
        hardware = std::make_shared<charger::SimulatedHardware>(cfg);
    }
    cfg.plc_backend_available = plc_available;
    charger::OcppAdapter adapter(cfg, hardware);

    if (!adapter.start()) {
        std::cerr << "Failed to start OCPP adapter" << std::endl;
        return 1;
    }

    std::signal(SIGINT, handle_signal);
    std::signal(SIGTERM, handle_signal);

    while (keep_running) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    adapter.stop();
    return 0;
}


=== src/ocpp_adapter.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "ocpp_adapter.hpp"

#include <algorithm>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <map>
#include <set>
#include <random>
#include <sstream>
#include <thread>
#include <cmath>
#include <limits>
#include <type_traits>
#include <cstddef>
#include <nlohmann/json.hpp>

#include <everest/logging.hpp>
#include <ocpp/common/evse_security_impl.hpp>
#include <ocpp/v16/ocpp_enums.hpp>

namespace charger {

namespace fs = std::filesystem;

namespace {

constexpr uint8_t HLC_MIN_POWER_STAGE = 4;
constexpr std::chrono::milliseconds MC_OPEN_TIMEOUT_MS(2000);
constexpr std::chrono::milliseconds GC_OPEN_TIMEOUT_MS(2000);
constexpr std::chrono::seconds LOCAL_AUTH_CACHE_TTL(24 * 3600);
constexpr std::chrono::seconds RECENT_TOKEN_DEDUP_WINDOW(10);
constexpr std::chrono::milliseconds SEAMLESS_RETRY_GRACE_MS(8000);
constexpr std::chrono::milliseconds CP_FAULT_GRACE_MS(3000);

std::chrono::milliseconds evse_limit_ack_timeout(const ChargerConfig& cfg) {
    return std::chrono::milliseconds(std::max(1, cfg.evse_limit_ack_timeout_ms));
}

std::chrono::milliseconds telemetry_timeout(const ChargerConfig& cfg) {
    return std::chrono::milliseconds(std::max(1, cfg.telemetry_timeout_ms));
}

const Slot* find_slot(const std::vector<Slot>& slots, int id) {
    auto it = std::find_if(slots.begin(), slots.end(), [&](const Slot& s) { return s.id == id; });
    return it == slots.end() ? nullptr : &(*it);
}

const Slot* find_slot_for_gun(const std::vector<Slot>& slots, int gun_id) {
    auto it = std::find_if(slots.begin(), slots.end(), [&](const Slot& s) { return s.gun_id == gun_id; });
    if (it != slots.end()) {
        return &(*it);
    }
    return find_slot(slots, gun_id);
}

struct SlotModuleSelection {
    int gun_id{0};
    uint8_t mask{0};
    int module_count{0};
    bool in_island{false};
};

SlotModuleSelection compute_slot_module_selection(const Plan& plan, const Slot& slot) {
    SlotModuleSelection sel{};
    for (const auto& island : plan.islands) {
        const bool slot_in_island = std::find(island.slot_ids.begin(), island.slot_ids.end(), slot.id) != island.slot_ids.end();
        if (!slot_in_island) {
            continue;
        }
        sel.in_island = true;
        sel.gun_id = island.gun_id.value_or(0);
        for (std::size_t idx = 0; idx < slot.modules.size(); ++idx) {
            const auto& module_id = slot.modules[idx];
            if (std::find(island.module_ids.begin(), island.module_ids.end(), module_id) != island.module_ids.end()) {
                sel.mask |= static_cast<uint8_t>(1U << idx);
                sel.module_count++;
            }
        }
        break;
    }
    return sel;
}

bool power_delivery_requested(const GunStatus& status, bool lock_required) {
    if (!status.plugged_in || status.comm_fault || status.cp_fault) {
        return false;
    }
    if (status.hlc_charge_complete) {
        return false;
    }
    if (lock_required && !status.lock_engaged) {
        return false;
    }
    const bool cp_ready = status.cp_state == 'C' || status.cp_state == 'D';
    const bool targets_present =
        status.target_current_a.has_value() || status.target_voltage_v.has_value();
    const bool measured_present =
        status.present_voltage_v.has_value() || status.present_current_a.has_value() ||
        status.present_power_w.has_value();
    bool hlc_ready = status.hlc_power_ready;
    if (!hlc_ready && status.hlc_stage >= HLC_MIN_POWER_STAGE && status.hlc_cable_check_ok &&
        !status.hlc_charge_complete) {
        hlc_ready = true;
    }
    if (!hlc_ready && status.hlc_precharge_active && (targets_present || measured_present)) {
        hlc_ready = true;
    }
    return cp_ready && (hlc_ready || targets_present || measured_present);
}

int popcount(uint8_t mask) {
    int count = 0;
    while (mask) {
        count += (mask & 0x1);
        mask >>= 1U;
    }
    return count;
}

template <typename T> struct is_optional : std::false_type {};
template <typename U> struct is_optional<std::optional<U>> : std::true_type {};

template <typename T, typename = void>
struct has_total : std::false_type {};
template <typename T>
struct has_total<T, std::void_t<decltype(std::declval<T>().total)>> : std::true_type {};

template <typename T, typename = void>
struct has_dc : std::false_type {};
template <typename T>
struct has_dc<T, std::void_t<decltype(std::declval<T>().DC)>> : std::true_type {};

template <typename T>
double extract_total_value(const T& v) {
    if constexpr (is_optional<T>::value) {
        return v ? extract_total_value(*v) : 0.0;
    } else if constexpr (has_total<T>::value) {
        return static_cast<double>(v.total);
    } else {
        return static_cast<double>(v);
    }
}

template <typename T>
std::optional<double> extract_dc_value(const T& v) {
    if constexpr (is_optional<T>::value) {
        if (!v) return std::nullopt;
        return extract_dc_value(*v);
    } else if constexpr (has_dc<T>::value) {
        if constexpr (is_optional<decltype(v.DC)>::value) {
            return v.DC ? std::optional<double>(*v.DC) : std::nullopt;
        } else {
            return std::optional<double>(v.DC);
        }
    } else {
        return std::nullopt;
    }
}

} // namespace

OcppAdapter::OcppAdapter(ChargerConfig cfg, std::shared_ptr<HardwareInterface> hardware) :
    cfg_(std::move(cfg)),
    hardware_(std::move(hardware)),
    planner_cfg_{},
    power_manager_(planner_cfg_) {
    simulation_mode_ = cfg_.simulation_mode;
    force_comm_fault_ = cfg_.use_plc && !cfg_.simulation_mode && !cfg_.plc_backend_available;
    if (force_comm_fault_) {
        EVLOG_warning << "PLC communication not established; marking connectors as Fault. "
                      << "Enable chargePoint.simulationMode=true to suppress comm faults for simulation.";
    }
    pending_token_store_ = cfg_.database_dir / "pending_tokens.json";
    local_auth_cache_store_ = cfg_.database_dir / "local_auth_cache.json";
    for (const auto& c : cfg_.connectors) {
        connector_faulted_[c.id] = false;
        connector_state_[c.id] = ConnectorState::Available;
        evse_disabled_[c.id] = false;
        reserved_connectors_[c.id] = false;
        power_constrained_[c.id] = false;
        paused_evse_[c.id] = false;
        plugged_in_state_[c.id] = false;
        plug_event_time_[c.id] = std::chrono::steady_clock::time_point{};
        auth_state_cache_[c.id] = AuthorizationState::Unknown;
        post_stop_plugged_[c.id] = false;
        post_stop_time_[c.id] = std::chrono::steady_clock::time_point{};
        reservation_required_tag_.erase(c.id);
        reservation_parent_tag_.erase(c.id);
        connector_meter_intervals_[c.id] = c.meter_sample_interval_s > 0 ? c.meter_sample_interval_s
                                                                         : cfg_.meter_sample_interval_s;
    }
    load_pending_tokens_from_disk();
    load_local_auth_cache_from_disk();
    initialize_slots();
}

OcppAdapter::~OcppAdapter() {
    stop();
}

void OcppAdapter::prepare_security_files() const {
    auto touch = [](const fs::path& path) {
        if (!path.empty() && !fs::exists(path)) {
            std::ofstream out(path);
            out << "";
        }
    };

    touch(cfg_.security.csms_ca_bundle);
    touch(cfg_.security.mo_ca_bundle);
    touch(cfg_.security.v2g_ca_bundle);
}

void OcppAdapter::seed_default_evse_limits() {
    for (const auto& c : cfg_.connectors) {
        EvseLimits limits{};
        if (c.max_voltage_v > 0.0) {
            limits.max_voltage_v = c.max_voltage_v;
        }
        if (c.max_current_a > 0.0) {
            limits.max_current_a = c.max_current_a;
        }
        if (c.max_power_w > 0.0) {
            limits.max_power_kw = c.max_power_w / 1000.0;
        }
        hardware_->set_evse_limits(c.id, limits);
    }
}

const Slot* OcppAdapter::find_slot_for_gun(int gun_id) const {
    return charger::find_slot_for_gun(slots_, gun_id);
}

void OcppAdapter::initialize_slots() {
    if (slots_initialized_) return;

    if (cfg_.allow_cross_slot_islands && hardware_ && !hardware_->supports_cross_slot_islands()) {
        EVLOG_warning << "Cross-slot islands requested in config but hardware does not support it; disabling.";
        cfg_.allow_cross_slot_islands = false;
    }

    PlannerConfig pcfg;
    pcfg.module_power_kw = cfg_.module_power_kw > 0.0 ? cfg_.module_power_kw : 30.0;
    pcfg.grid_limit_kw = cfg_.grid_limit_kw > 0.0 ? cfg_.grid_limit_kw : 1000.0;
    pcfg.default_voltage_v = cfg_.default_voltage_v > 0.0 ? cfg_.default_voltage_v : 800.0;
    pcfg.allow_cross_slot_islands = cfg_.allow_cross_slot_islands;
    pcfg.max_modules_per_gun = std::max(1, cfg_.max_modules_per_gun);
    pcfg.min_modules_per_active_gun = std::max(0, cfg_.min_modules_per_active_gun);
    pcfg.max_island_radius = std::max(1, cfg_.max_island_radius);
    pcfg.min_module_hold_ms = std::max(0, cfg_.min_module_hold_ms);
    pcfg.min_mc_hold_ms = std::max(0, cfg_.min_mc_hold_ms);
    pcfg.min_gc_hold_ms = std::max(0, cfg_.min_gc_hold_ms);
    pcfg.mc_open_current_a = cfg_.mc_open_current_a;
    pcfg.gc_open_current_a = cfg_.gc_open_current_a;
    planner_cfg_ = pcfg;
    power_manager_ = PowerManager(planner_cfg_);

    std::vector<Slot> slots;
    if (!cfg_.slots.empty()) {
        for (const auto& sm : cfg_.slots) {
            Slot s;
            s.id = sm.id;
            s.gun_id = sm.gun_id;
            s.gc_id = sm.gc_id.empty() ? "GC_" + std::to_string(sm.id) : sm.gc_id;
            s.mc_id = sm.mc_id.empty() ? "MC_" + std::to_string(sm.id) : sm.mc_id;
            s.cw_id = sm.cw_id;
            s.ccw_id = sm.ccw_id;
            int mod_idx = 0;
            for (const auto& m : sm.modules) {
                s.modules.push_back(m.id);
                ModuleState ms;
                ms.id = m.id;
                ms.slot_id = sm.id;
                ms.mn_id = m.mn_id.empty() ? "MN_" + std::to_string(sm.id) + "_0" : m.mn_id;
                ms.slot_index = mod_idx++;
                ms.type = m.type;
                ms.can_interface = !m.can_interface.empty() ? m.can_interface : cfg_.can_interface;
                ms.address = m.address;
                ms.group = m.group;
                ms.rated_power_kw = m.rated_power_kw;
                ms.rated_current_a = m.rated_current_a;
                ms.poll_interval_ms = m.poll_interval_ms;
                ms.cmd_interval_ms = m.cmd_interval_ms;
                module_states_.push_back(ms);
            }
            slots.push_back(s);
        }
    } else {
        for (std::size_t i = 0; i < cfg_.connectors.size(); ++i) {
            const auto& c = cfg_.connectors[i];
            Slot s;
            s.id = c.id;
            s.gun_id = c.id;
            s.gc_id = "GC_" + std::to_string(c.id);
            s.mc_id = "MC_" + std::to_string(c.id);
            s.cw_id = cfg_.connectors[(i + 1) % cfg_.connectors.size()].id;
            s.ccw_id = cfg_.connectors[(i + cfg_.connectors.size() - 1) % cfg_.connectors.size()].id;
            s.modules.push_back("M" + std::to_string(c.id) + "_0");
            s.modules.push_back("M" + std::to_string(c.id) + "_1");
            slots.push_back(s);

            ModuleState m0;
            m0.id = s.modules[0];
            m0.slot_id = s.id;
            m0.mn_id = "MN_" + std::to_string(s.id) + "_0";
            m0.can_interface = cfg_.can_interface;
            m0.slot_index = 0;
            module_states_.push_back(m0);

            ModuleState m1;
            m1.id = s.modules[1];
            m1.slot_id = s.id;
            m1.mn_id = "MN_" + std::to_string(s.id) + "_1";
            m1.can_interface = cfg_.can_interface;
            m1.slot_index = 1;
            module_states_.push_back(m1);
        }
    }

    slots_ = slots;
    power_manager_.set_slots(slots);

    std::vector<ModuleSpec> module_specs;
    for (const auto& ms : module_states_) {
        if (ms.type.empty()) {
            continue;
        }
        ModuleSpec spec;
        spec.id = ms.id;
        spec.slot_id = ms.slot_id;
        spec.slot_index = ms.slot_index;
        spec.type = ms.type;
        spec.can_interface = !ms.can_interface.empty() ? ms.can_interface : cfg_.can_interface;
        spec.address = ms.address;
        spec.group = ms.group;
        spec.rated_power_kw = ms.rated_power_kw > 0.0 ? ms.rated_power_kw : cfg_.module_power_kw;
        spec.rated_current_a = ms.rated_current_a;
        spec.poll_interval_ms = ms.poll_interval_ms;
        spec.cmd_interval_ms = ms.cmd_interval_ms;
        module_specs.push_back(spec);
    }
    if (!module_specs.empty()) {
        module_controller_ = std::make_unique<PowerModuleController>(module_specs);
    }

    slots_initialized_ = true;
}

bool OcppAdapter::start() {
    prepare_security_files();
    Everest::Logging::init(cfg_.logging_config.string(), "dc-ocpp");

    const auto config_str = load_and_patch_ocpp_config(cfg_);

    ocpp::SecurityConfiguration security_cfg{};
    security_cfg.csms_ca_bundle = cfg_.security.csms_ca_bundle;
    security_cfg.mf_ca_bundle = cfg_.security.mo_ca_bundle;
    security_cfg.mo_ca_bundle = cfg_.security.mo_ca_bundle;
    security_cfg.v2g_ca_bundle = cfg_.security.v2g_ca_bundle;
    security_cfg.csms_leaf_cert_directory = cfg_.security.client_cert_dir;
    security_cfg.csms_leaf_key_directory = cfg_.security.client_key_dir;
    security_cfg.secc_leaf_cert_directory = cfg_.security.secc_cert_dir;
    security_cfg.secc_leaf_key_directory = cfg_.security.secc_key_dir;

    charge_point_ = std::make_unique<ocpp::v16::ChargePoint>(config_str, cfg_.share_path, cfg_.user_config,
                                                             cfg_.database_dir, cfg_.sql_migrations,
                                                             cfg_.message_log_path, nullptr, security_cfg);

    register_callbacks();

    std::map<int, ocpp::v16::ChargePointStatus> connector_status_map;
    connector_status_map.emplace(0, ocpp::v16::ChargePointStatus::Available);
    for (const auto& connector : cfg_.connectors) {
        connector_status_map.emplace(connector.id, ocpp::v16::ChargePointStatus::Available);
    }

    if (!charge_point_->start(connector_status_map, ocpp::v16::BootReasonEnum::PowerUp)) {
        EVLOG_error << "Failed to start charge point";
        return false;
    }

    refresh_charging_profile_limits();
    seed_default_evse_limits();

    running_ = true;
    start_metering_threads();
    planner_thread_running_ = true;
    planner_thread_ = std::thread([this]() {
        while (running_ && planner_thread_running_) {
            try {
                const auto now = std::chrono::steady_clock::now();
                bool refresh_due = false;
                {
                    std::lock_guard<std::mutex> lock(plan_mutex_);
                    refresh_due = profile_next_refresh_.has_value() && now >= *profile_next_refresh_;
                }
                if (refresh_due) {
                    refresh_charging_profile_limits();
                }
                apply_power_plan();
            } catch (const std::exception& e) {
                EVLOG_warning << "Planner thread error: " << e.what();
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });
    return true;
}

void OcppAdapter::stop() {
    if (!running_) {
        return;
    }
    running_ = false;
    planner_thread_running_ = false;
    if (planner_thread_.joinable()) {
        planner_thread_.join();
    }
    for (auto& thread : meter_threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    meter_threads_.clear();
    if (charge_point_) {
        charge_point_->stop();
    }
}

void OcppAdapter::register_callbacks() {
    charge_point_->register_enable_evse_callback([this](std::int32_t connector) {
        {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            evse_disabled_[connector] = false;
        }
        const bool ok = hardware_->enable(connector);
        if (ok) {
            charge_point_->on_enabled(connector);
        } else {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            evse_disabled_[connector] = true;
        }
        return ok;
    });

    charge_point_->register_disable_evse_callback([this](std::int32_t connector) {
        {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            evse_disabled_[connector] = true;
        }
        bool had_session = false;
        {
            std::lock_guard<std::mutex> lock(session_mutex_);
            had_session = sessions_.count(connector) > 0;
        }
        if (had_session) {
            finish_transaction(connector, ocpp::v16::Reason::Other, std::nullopt);
        }
        const bool ok = hardware_->disable(connector);
        if (ok) {
            charge_point_->on_disabled(connector);
        }
        return ok;
    });

    charge_point_->register_pause_charging_callback([this](std::int32_t connector) {
        {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            paused_evse_[connector] = true;
        }
        charge_point_->on_suspend_charging_evse(connector);
        return true;
    });

    charge_point_->register_resume_charging_callback([this](std::int32_t connector) {
        {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            paused_evse_[connector] = false;
        }
        charge_point_->on_resume_charging(connector);
        return true;
    });

    charge_point_->register_stop_transaction_callback([this](std::int32_t connector, ocpp::v16::Reason reason) {
        const bool ok = hardware_->stop_transaction(connector, reason);
        if (ok) {
            finish_transaction(connector, reason);
            const auto status = hardware_->get_status(connector);
            std::lock_guard<std::mutex> lock(state_mutex_);
            if (status.plugged_in) {
                post_stop_plugged_[connector] = true;
                post_stop_time_[connector] = std::chrono::steady_clock::now();
            } else {
                post_stop_plugged_[connector] = false;
                post_stop_time_[connector] = std::chrono::steady_clock::time_point{};
            }
        }
        return ok;
    });

    charge_point_->register_provide_token_callback(
        [this](const std::string& id_token, std::vector<std::int32_t> referenced_connectors, bool prevalidated) {
            hardware_->on_remote_start_token(id_token, referenced_connectors, prevalidated);
            AuthToken token;
            token.id_token = id_token;
            token.source = AuthTokenSource::RemoteStart;
            token.prevalidated = prevalidated;
            token.connector_hint = referenced_connectors.empty() ? 0 : referenced_connectors.front();
            token.received_at = std::chrono::steady_clock::now();
            std::optional<std::string> required_tag;
            std::optional<std::string> parent_tag;
            if (token.connector_hint > 0) {
                std::lock_guard<std::mutex> plan_lock(plan_mutex_);
                if (reservation_required_tag_.count(token.connector_hint)) {
                    required_tag = reservation_required_tag_[token.connector_hint];
                }
                if (reservation_parent_tag_.count(token.connector_hint)) {
                    parent_tag = reservation_parent_tag_[token.connector_hint];
                }
            }
            if (token.connector_hint > 0 && required_tag) {
                if (!token_matches_reservation(token.connector_hint, token.id_token, parent_tag)) {
                    EVLOG_warning << "RemoteStart token does not match reservation on connector "
                                  << token.connector_hint << "; ignoring remote start token";
                    return;
                }
            }
            if (token.connector_hint > 0 && required_tag) {
                std::lock_guard<std::mutex> plan_lock(plan_mutex_);
                reserved_connectors_[token.connector_hint] = false;
                reservation_required_tag_.erase(token.connector_hint);
                reservation_parent_tag_.erase(token.connector_hint);
                for (auto it = reservation_lookup_.begin(); it != reservation_lookup_.end();) {
                    if (it->second == token.connector_hint) {
                        it = reservation_lookup_.erase(it);
                    } else {
                        ++it;
                    }
                }
            }
            ingest_auth_tokens({token}, token.received_at);
        });


    charge_point_->register_reserve_now_callback(
        [this](std::int32_t reservation_id, std::int32_t connector, ocpp::DateTime expiryDate,
               ocpp::CiString<20> idTag, std::optional<ocpp::CiString<20>> parent_id) {
            const auto status = hardware_->reserve(reservation_id, connector, expiryDate, idTag.get(),
                                                   parent_id ? std::optional<std::string>(parent_id->get()) : std::nullopt);
            if (status == ocpp::v16::ReservationStatus::Accepted) {
                charge_point_->on_reservation_start(connector);
                std::lock_guard<std::mutex> lock(plan_mutex_);
                reserved_connectors_[connector] = true;
                reservation_lookup_[reservation_id] = connector;
                reservation_required_tag_[connector] = idTag.get();
                reservation_parent_tag_[connector] = parent_id ? std::optional<std::string>(parent_id->get())
                                                               : std::optional<std::string>{};
            }
            return status;
        });

    charge_point_->register_cancel_reservation_callback([this](std::int32_t reservation_id) {
        const bool ok = hardware_->cancel_reservation(reservation_id);
        if (ok) {
            std::lock_guard<std::mutex> lock(plan_mutex_);
            auto it = reservation_lookup_.find(reservation_id);
            if (it != reservation_lookup_.end()) {
                reserved_connectors_[it->second] = false;
                reservation_lookup_.erase(it);
                reservation_required_tag_.erase(it->second);
                reservation_parent_tag_.erase(it->second);
            }
        }
        return ok;
    });

    charge_point_->register_unlock_connector_callback(
        [this](std::int32_t connector) { return hardware_->unlock(connector); });

    charge_point_->register_upload_diagnostics_callback(
        [this](const ocpp::v16::GetDiagnosticsRequest& request) {
            charge_point_->on_log_status_notification(-1, "Uploading");
            try {
                auto resp = hardware_->upload_diagnostics(request);
                charge_point_->on_log_status_notification(-1, resp.status == ocpp::v16::LogStatusEnumType::Accepted
                                                                    ? "Uploaded"
                                                                    : "UploadFailed");
                return resp;
            } catch (const std::exception& e) {
                EVLOG_error << "Diagnostics upload failed: " << e.what();
                ocpp::v16::GetLogResponse resp;
                resp.status = ocpp::v16::LogStatusEnumType::Rejected;
                charge_point_->on_log_status_notification(-1, "UploadFailed");
                return resp;
            }
        });

    charge_point_->register_upload_logs_callback(
        [this](const ocpp::v16::GetLogRequest& request) {
            const int req_id = request.requestId;
            charge_point_->on_log_status_notification(req_id, "Uploading");
            try {
                auto resp = hardware_->upload_logs(request);
                charge_point_->on_log_status_notification(req_id, resp.status == ocpp::v16::LogStatusEnumType::Accepted
                                                                      ? "Uploaded"
                                                                      : "UploadFailed");
                return resp;
            } catch (const std::exception& e) {
                EVLOG_error << "Log upload failed: " << e.what();
                ocpp::v16::GetLogResponse resp;
                resp.status = ocpp::v16::LogStatusEnumType::Rejected;
                charge_point_->on_log_status_notification(req_id, "UploadFailed");
                return resp;
            }
        });

    charge_point_->register_update_firmware_callback(
        [this](const ocpp::v16::UpdateFirmwareRequest msg) {
            charge_point_->on_firmware_update_status_notification(-1, ocpp::FirmwareStatusNotification::Downloading);
            try {
                hardware_->update_firmware(msg);
                charge_point_->on_firmware_update_status_notification(-1, ocpp::FirmwareStatusNotification::Installing);
                charge_point_->on_firmware_update_status_notification(-1, ocpp::FirmwareStatusNotification::Installed);
            } catch (const std::exception& e) {
                EVLOG_error << "Firmware update failed: " << e.what();
                charge_point_->on_firmware_update_status_notification(
                    -1, ocpp::FirmwareStatusNotification::InstallationFailed);
            }
        });

    charge_point_->register_signed_update_firmware_callback(
        [this](const ocpp::v16::SignedUpdateFirmwareRequest msg) {
            charge_point_->on_firmware_update_status_notification(-1, ocpp::FirmwareStatusNotification::Downloading);
            charge_point_->on_firmware_update_status_notification(-1, ocpp::FirmwareStatusNotification::Installing);
            try {
                const auto status = hardware_->update_firmware_signed(msg);
                if (status == ocpp::v16::UpdateFirmwareStatusEnumType::Accepted) {
                    charge_point_->on_firmware_update_status_notification(
                        -1, ocpp::FirmwareStatusNotification::Installed);
                } else {
                    charge_point_->on_firmware_update_status_notification(
                        -1, ocpp::FirmwareStatusNotification::InstallationFailed);
                }
                return status;
            } catch (const std::exception& e) {
                EVLOG_error << "Signed firmware update failed: " << e.what();
                charge_point_->on_firmware_update_status_notification(
                    -1, ocpp::FirmwareStatusNotification::InstallationFailed);
                return ocpp::v16::UpdateFirmwareStatusEnumType::Rejected;
            }
        });

    charge_point_->register_set_connection_timeout_callback(
        [this](std::int32_t connection_timeout) { hardware_->set_connection_timeout(connection_timeout); });

    charge_point_->register_is_reset_allowed_callback(
        [this](const ocpp::v16::ResetType& reset_type) { return hardware_->is_reset_allowed(reset_type); });

    charge_point_->register_reset_callback(
        [this](const ocpp::v16::ResetType& reset_type) { hardware_->reset(reset_type); });

    charge_point_->register_data_transfer_callback(
        [this](const ocpp::v16::DataTransferRequest& request) { return handle_data_transfer_request(request); });

    charge_point_->register_is_token_reserved_for_connector_callback(
        [this](const std::int32_t connector, const std::string& id_token) {
            std::optional<std::string> parent;
            bool reserved = false;
            {
                std::lock_guard<std::mutex> lock(plan_mutex_);
                if (reservation_parent_tag_.count(connector)) {
                    parent = reservation_parent_tag_[connector];
                }
                reserved = reserved_connectors_.count(connector) ? reserved_connectors_[connector] : false;
            }
            const bool matches = token_matches_reservation(connector, id_token, parent);
            if (!reserved) {
                return ocpp::ReservationCheckStatus::NotReserved;
            }
            if (matches) {
                return ocpp::ReservationCheckStatus::ReservedForToken;
            }
            if (parent && !parent->empty()) {
                return ocpp::ReservationCheckStatus::ReservedForOtherTokenAndHasParentToken;
            }
            return ocpp::ReservationCheckStatus::ReservedForOtherToken;
        });

    charge_point_->register_generic_configuration_key_changed_callback(
        [this](const ocpp::v16::KeyValue& key_value) { handle_configuration_key_change(key_value); });

    charge_point_->register_set_system_time_callback(
        [](const std::string& system_time) { EVLOG_info << "CSMS provided system time: " << system_time; });

    charge_point_->register_boot_notification_response_callback(
        [](const ocpp::v16::BootNotificationResponse& resp) {
            std::stringstream ss;
            ss << resp.currentTime;
            EVLOG_info << "BootNotification response status=" << resp.status << " interval=" << resp.interval
                       << " currentTime=" << ss.str();
        });

    charge_point_->register_connection_state_changed_callback([](bool is_connected) {
        EVLOG_info << "CSMS websocket state changed: " << (is_connected ? "connected" : "disconnected");
    });

    charge_point_->register_signal_set_charging_profiles_callback([this]() { refresh_charging_profile_limits(); });

    charge_point_->register_all_connectors_unavailable_callback(
        []() { EVLOG_info << "All connectors unavailable; safe for maintenance/firmware actions."; });

    charge_point_->register_security_event_callback(
        [](const std::string& type, const std::string& tech_info) {
            EVLOG_warning << "Security event: " << type << " details=" << tech_info;
        });
}

void OcppAdapter::start_metering_threads() {
    for (const auto& connector : cfg_.connectors) {
        meter_threads_.emplace_back([this, connector_id = connector.id]() { metering_loop(connector_id); });
    }
}

void OcppAdapter::metering_loop(std::int32_t connector) {
    int current_interval_s = meter_interval_seconds_for_connector(connector);
    auto meter_period = std::chrono::seconds(std::max(1, current_interval_s));
    const auto control_tick = std::chrono::milliseconds(50);
    auto next_meter_push = std::chrono::steady_clock::now();

    while (running_) {
        try {
            const auto loop_start = std::chrono::steady_clock::now();
            const auto now = loop_start;
            const int desired_interval = meter_interval_seconds_for_connector(connector);
            if (desired_interval != current_interval_s) {
                current_interval_s = desired_interval;
                meter_period = std::chrono::seconds(std::max(1, current_interval_s));
                next_meter_push = now + meter_period;
            }
            const bool push_meter_now = loop_start >= next_meter_push;
            const bool auth_timeout_enabled = cfg_.auth_wait_timeout_s > 0;
            const bool power_request_timeout_enabled = cfg_.power_request_timeout_s > 0;
            const auto auth_wait_timeout = std::chrono::seconds(auth_timeout_enabled
                                                                     ? std::max(1, cfg_.auth_wait_timeout_s)
                                                                     : 0);
            const auto power_request_timeout = std::chrono::seconds(power_request_timeout_enabled
                                                                         ? std::max(1, cfg_.power_request_timeout_s)
                                                                         : 0);
            auto hw_tokens = hardware_->poll_auth_tokens();
            if (!hw_tokens.empty()) {
                ingest_auth_tokens(hw_tokens, now);
            }
            auto status = hardware_->get_status(connector);
            bool comm_fault = status.comm_fault || force_comm_fault_;
            if (simulation_mode_) {
                comm_fault = false;
            }
            status.comm_fault = comm_fault;
            record_presence_state(connector, status.plugged_in, now);
            auto mark_post_stop = [&](bool active) {
                std::lock_guard<std::mutex> lock(state_mutex_);
                post_stop_plugged_[connector] = active;
                post_stop_time_[connector] = active ? now : std::chrono::steady_clock::time_point{};
            };
            bool post_stop_plugged = false;
            {
                std::lock_guard<std::mutex> lock(state_mutex_);
                if (!status.plugged_in) {
                    post_stop_plugged_[connector] = false;
                    post_stop_time_[connector] = std::chrono::steady_clock::time_point{};
                }
                post_stop_plugged = post_stop_plugged_[connector];
            }

            auto finish_and_mark = [&](ocpp::v16::Reason reason,
                                       std::optional<ocpp::CiString<20>> id_tag_end = std::nullopt) {
                finish_transaction(connector, reason, id_tag_end);
                if (status.plugged_in) {
                    mark_post_stop(true);
                }
            };

            ActiveSession session{};
            bool had_session = false;
            bool pending_changed = false;
            bool fault = false;
            bool was_faulted = false;
            {
                std::lock_guard<std::mutex> lock(state_mutex_);
                was_faulted = connector_faulted_[connector];
            }

            auto measurement = hardware_->sample_meter(connector);
            // Check measurement vs reported telemetry for consistency.
            auto dc_voltage = extract_dc_value(measurement.power_meter.voltage_V);
            auto dc_current = extract_dc_value(measurement.power_meter.current_A);
            auto dc_power = extract_dc_value(measurement.power_meter.power_W);
            const auto has_measured = dc_voltage || dc_current || dc_power;
            const bool has_status = status.present_voltage_v || status.present_current_a || status.present_power_w;
            if (has_measured && has_status) {
                double v_meas = dc_voltage.value_or(status.present_voltage_v.value_or(0.0));
                double i_meas = dc_current.value_or(status.present_current_a.value_or(0.0));
                double p_meas = dc_power.value_or(status.present_power_w.value_or(0.0));
                double v_stat = status.present_voltage_v.value_or(v_meas);
                double i_stat = status.present_current_a.value_or(i_meas);
                double p_stat = status.present_power_w.value_or(p_meas);
                auto within = [](double a, double b, double rel, double abs_tol) {
                    const double diff = std::fabs(a - b);
                    return diff <= abs_tol || diff <= std::max(std::fabs(a), std::fabs(b)) * rel;
                };
                const bool v_ok = within(v_meas, v_stat, 0.05, 20.0);
                const bool i_ok = within(i_meas, i_stat, 0.10, 2.0);
                const bool p_ok = within(p_meas, p_stat, 0.10, 500.0);
                if (!(v_ok && i_ok && p_ok)) {
                    telemetry_mismatch_count_[connector]++;
                } else {
                    telemetry_mismatch_count_[connector] = 0;
                }
                if (telemetry_mismatch_count_[connector] >= 5) {
                    EVLOG_error << "Telemetry mismatch on connector " << connector
                                << " meas(V=" << v_meas << " I=" << i_meas << " P=" << p_meas << ")"
                                << " status(V=" << v_stat << " I=" << i_stat << " P=" << p_stat << ")";
                    finish_and_mark(ocpp::v16::Reason::PowerLoss, std::nullopt);
                    hardware_->disable(connector);
                    had_session = false;
                    fault = true;
                    telemetry_mismatch_count_[connector] = 0;
                }
            } else {
                telemetry_mismatch_count_[connector] = 0;
            }
            bool constrained = false;
            bool paused = false;
            bool disabled = false;
            bool reserved = false;
            std::string required_tag;
            std::optional<std::string> parent_tag;
            {
                std::lock_guard<std::mutex> plan_lock(plan_mutex_);
                constrained = power_constrained_[connector];
                paused = paused_evse_[connector];
                disabled = evse_disabled_[connector];
                reserved = reserved_connectors_[connector];
                if (reservation_required_tag_.count(connector)) {
                    required_tag = reservation_required_tag_[connector];
                }
                if (reservation_parent_tag_.count(connector)) {
                    parent_tag = reservation_parent_tag_[connector];
                }
            }

            {
                std::lock_guard<std::mutex> lock(session_mutex_);
                auto qit = pending_tokens_.find(connector);
                if (qit != pending_tokens_.end()) {
                    for (auto pit = qit->second.begin(); pit != qit->second.end();) {
                        if (pit->expires_at <= now) {
                            pending_changed = true;
                            pit = qit->second.erase(pit);
                        } else {
                            ++pit;
                        }
                    }
                }
                auto it = sessions_.find(connector);
                const std::optional<std::string> reservation_required =
                    (reserved && !required_tag.empty()) ? std::optional<std::string>(required_tag) : std::nullopt;
                const auto reservation_parent = reserved ? parent_tag : std::optional<std::string>{};
                const bool blocked_for_session = !status.safety_ok || status.estop || status.earth_fault ||
                    status.comm_fault || status.cp_fault || status.hlc_charge_complete || post_stop_plugged;
                bool create_session = !disabled && status.plugged_in && it == sessions_.end() && !blocked_for_session;
                if (create_session) {
                    ActiveSession s{};
                    s.session_id = make_session_id();
                    s.meter_start_wh = measurement.power_meter.energy_Wh_import.total;
                    s.connected_at = now;
                    s.ev_connected = true;
                    s.pending_started = now;
                    s.last_seen_plugged = status.plugged_in ? now : std::chrono::steady_clock::time_point{};
                    bool have_token = false;
                    if (auto pending = pop_next_pending_token(connector, now, reservation_required, reservation_parent)) {
                        try_authorize_with_token(connector, s, *pending);
                        have_token = true;
                    } else if (!reserved) {
                        set_auth_state(connector, AuthorizationState::Pending);
                        have_token = true;
                    }
                    if (reserved && !have_token) {
                        create_session = false;
                        EVLOG_info << "Connector " << connector << " reserved, waiting for matching token before starting session";
                        set_auth_state(connector, AuthorizationState::Pending);
                    } else {
                        sessions_[connector] = s;
                        const auto reason = s.authorized ? ocpp::SessionStartedReason::Authorized
                                                         : ocpp::SessionStartedReason::EVConnected;
                        charge_point_->on_session_started(connector, s.session_id, reason, std::nullopt);
                        it = sessions_.find(connector);
                        mark_post_stop(false);
                        if (reserved) {
                            std::lock_guard<std::mutex> plan_lock(plan_mutex_);
                            reserved_connectors_[connector] = false;
                            reservation_required_tag_.erase(connector);
                            reservation_parent_tag_.erase(connector);
                            for (auto rit = reservation_lookup_.begin(); rit != reservation_lookup_.end();) {
                                if (rit->second == connector) {
                                    rit = reservation_lookup_.erase(rit);
                                } else {
                                    ++rit;
                                }
                            }
                        }
                    }
                } else if (it != sessions_.end()) {
                    it->second.ev_connected = status.plugged_in;
                    if (!it->second.pending_started.time_since_epoch().count()) {
                        it->second.pending_started = now;
                    }
                    if (status.plugged_in) {
                        it->second.last_seen_plugged = now;
                    }
                    if (!it->second.authorized) {
                        if (auto pending = pop_next_pending_token(connector, now)) {
                            try_authorize_with_token(connector, it->second, *pending);
                        } else {
                            set_auth_state(connector, AuthorizationState::Pending);
                        }
                    }
                    mark_post_stop(false);
                }

                if (it != sessions_.end()) {
                    session = it->second;
                    had_session = true;
                }
                if (!status.plugged_in && it == sessions_.end()) {
                    set_auth_state(connector, AuthorizationState::Unknown);
                }
                if (pending_changed) {
                    persist_pending_tokens_locked();
                }
            }
            const auto cfg_it = std::find_if(cfg_.connectors.begin(), cfg_.connectors.end(),
                                             [&](const ConnectorConfig& c) { return c.id == connector; });
            const bool lock_required = cfg_it != cfg_.connectors.end() ? cfg_it->require_lock : true;
            bool cp_fault_grace = false;
            if (status.cp_fault) {
                {
                    std::lock_guard<std::mutex> lock(state_mutex_);
                    auto& since = cp_fault_since_[connector];
                    if (since.time_since_epoch().count() == 0) {
                        since = now;
                    }
                    if ((now - since) < CP_FAULT_GRACE_MS) {
                        cp_fault_grace = true;
                    }
                }
                if (cp_fault_grace) {
                    hardware_->disable(connector);
                }
            } else {
                std::lock_guard<std::mutex> lock(state_mutex_);
                cp_fault_since_[connector] = std::chrono::steady_clock::time_point{};
            }
            if (status.cp_fault && !cp_fault_grace) {
                ocpp::v16::ErrorInfo err("cp_fault", ocpp::v16::ChargePointErrorCode::OtherError, true);
                report_fault(connector, err);
                bool already_faulted = false;
                {
                    std::lock_guard<std::mutex> lock(state_mutex_);
                    already_faulted = connector_faulted_[connector];
                    connector_faulted_[connector] = true;
                }
                if (had_session) {
                    finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                    hardware_->disable(connector);
                    had_session = false;
                } else if (!already_faulted) {
                    hardware_->disable(connector);
                }
                fault = true;
            }
            if (!status.safety_ok || status.estop || status.earth_fault || status.comm_fault) {
                ocpp::v16::ErrorInfo err("safety", ocpp::v16::ChargePointErrorCode::GroundFailure, true);
                ocpp::v16::Reason stop_reason = ocpp::v16::Reason::EmergencyStop;
                if (status.estop) {
                    err = ocpp::v16::ErrorInfo("estop", ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
                    stop_reason = ocpp::v16::Reason::EmergencyStop;
                } else if (status.comm_fault) {
                    err = ocpp::v16::ErrorInfo("comm", ocpp::v16::ChargePointErrorCode::InternalError, true);
                    stop_reason = ocpp::v16::Reason::PowerLoss;
                } else if (status.earth_fault) {
                    err = ocpp::v16::ErrorInfo("earth", ocpp::v16::ChargePointErrorCode::GroundFailure, true);
                    stop_reason = ocpp::v16::Reason::Other;
                }
                report_fault(connector, err);
                bool already_faulted = false;
                {
                    std::lock_guard<std::mutex> lock(state_mutex_);
                    already_faulted = connector_faulted_[connector];
                    connector_faulted_[connector] = true;
                }
                if (!already_faulted) {
                    finish_and_mark(stop_reason, std::nullopt);
                    hardware_->disable(connector);
                    had_session = false;
                }
                fault = true;
            }
            if (!fault && status.isolation_fault) {
                ocpp::v16::ErrorInfo err("isolation_fault",
                                         ocpp::v16::ChargePointErrorCode::GroundFailure, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            if (!fault && status.overtemp_fault) {
                ocpp::v16::ErrorInfo err("overtemp",
                                         ocpp::v16::ChargePointErrorCode::HighTemperature, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            if (!fault && status.overcurrent_fault) {
                ocpp::v16::ErrorInfo err("overcurrent",
                                         ocpp::v16::ChargePointErrorCode::OverCurrentFailure, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            if (!fault && status.gc_welded) {
                ocpp::v16::ErrorInfo err("gc_welded",
                                         ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            if (!fault && status.mc_welded) {
                ocpp::v16::ErrorInfo err("mc_welded",
                                         ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            const uint8_t usable_modules =
                static_cast<uint8_t>(status.module_healthy_mask &
                                     static_cast<uint8_t>(~status.module_fault_mask));
            if (!fault && usable_modules == 0) {
                ocpp::v16::ErrorInfo err("module_fault",
                                         ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
                report_fault(connector, err);
                finish_transaction(connector, ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            } else if (!fault && status.module_fault_mask != 0) {
                ocpp::v16::ErrorInfo err("module_degraded",
                                         ocpp::v16::ChargePointErrorCode::OtherError, false);
                report_fault(connector, err);
            }
            // Lock fault: if lock disengaged while plug-in/session active, treat as fault
            if (!fault && lock_required && !status.lock_engaged && (status.plugged_in || had_session)) {
                ocpp::v16::ErrorInfo err("lock_fault",
                                         ocpp::v16::ChargePointErrorCode::ConnectorLockFailure, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }
            if (!fault && status.cp_state == 'D') {
                ocpp::v16::ErrorInfo err("ventilation_required",
                                         ocpp::v16::ChargePointErrorCode::OtherError, true);
                report_fault(connector, err);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                fault = true;
            }

            if (push_meter_now) {
                bool send_meter = false;
                const auto keepalive = std::chrono::seconds(std::max(1, cfg_.meter_keepalive_s));
                {
                    std::lock_guard<std::mutex> lock(meter_mutex_);
                    const double energy_wh = measurement.power_meter.energy_Wh_import.total;
                    const double last_sent_wh = last_meter_sent_wh_[connector];
                    const auto last_sent_time_it = last_meter_sent_time_.find(connector);
                    const auto last_sent_time =
                        last_sent_time_it != last_meter_sent_time_.end()
                            ? last_sent_time_it->second
                            : std::chrono::steady_clock::time_point{};
                    const bool tx_active = had_session && session.transaction_started;
                    const bool changed = std::fabs(energy_wh - last_sent_wh) > 0.1;
                    const bool stale = last_sent_time.time_since_epoch().count() == 0 ||
                        (now - last_sent_time) >= keepalive;
                    send_meter = tx_active || changed || stale;
                    if (send_meter) {
                        last_meter_sent_wh_[connector] = energy_wh;
                        last_meter_sent_time_[connector] = now;
                    }
                }
                if (send_meter) {
                    push_meter_values(connector, measurement);
                }
                while (next_meter_push <= loop_start) {
                    next_meter_push += meter_period;
                }
            }
            {
                std::lock_guard<std::mutex> plan_lock(plan_mutex_);
                const auto v_dc = extract_dc_value(measurement.power_meter.voltage_V);
                if (v_dc) {
                    last_voltage_v_[connector] = *v_dc;
                }
                const double p_total = extract_total_value(measurement.power_meter.power_W);
                if (p_total > 0.0) {
                    last_power_w_[connector] = p_total;
                } else {
                    const auto i_dc = extract_dc_value(measurement.power_meter.current_A);
                    if (v_dc && i_dc) {
                        last_power_w_[connector] = (*v_dc) * (*i_dc);
                    }
                }
            }
            if (status.meter_stale) {
                ocpp::v16::ErrorInfo err("meter_stale", ocpp::v16::ChargePointErrorCode::PowerMeterFailure, false);
                report_fault(connector, err);
                fault = true;
            } else if (!fault) {
                if (was_faulted) {
                    charge_point_->on_all_errors_cleared(connector);
                }
                std::lock_guard<std::mutex> lock(state_mutex_);
                connector_faulted_[connector] = false;
            }

            if (!fault && had_session && session.transaction_started &&
                status.last_evse_limit_ack.time_since_epoch().count() != 0) {
                const auto age = now - status.last_evse_limit_ack;
                const auto ack_timeout = evse_limit_ack_timeout(cfg_);
                if (age > ack_timeout) {
                    EVLOG_error << "EVSE limit ACK stale on connector " << connector << " age=" << age.count()
                                << "ms ack_count=" << status.evse_limit_ack_count
                                << " -- stopping session for safety";
                    finish_and_mark(ocpp::v16::Reason::PowerLoss, std::nullopt);
                    hardware_->disable(connector);
                    had_session = false;
                    fault = true;
                }
            }

            if (!fault && cfg_.telemetry_timeout_ms > 0 &&
                status.last_telemetry.time_since_epoch().count() != 0) {
                const auto age = now - status.last_telemetry;
                if (age > telemetry_timeout(cfg_)) {
                    EVLOG_error << "Telemetry stale on connector " << connector << " age=" << age.count()
                                << "ms -- forcing stop for safety";
                    if (had_session) {
                        finish_and_mark(ocpp::v16::Reason::PowerLoss, std::nullopt);
                        had_session = false;
                    }
                    hardware_->disable(connector);
                    fault = true;
                }
            }

            if (!fault && had_session && session.transaction_started && status.hlc_charge_complete) {
                EVLOG_info << "Charge complete reported on connector " << connector << ", ending session";
                finish_and_mark(ocpp::v16::Reason::EVDisconnected, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
                session = ActiveSession{};
            }

            bool seamless_retry_active = false;
            const bool power_ready = had_session && session.authorized &&
                (status.relay_closed || power_delivery_requested(status, lock_required)) && !disabled;
            if (had_session && status.cp_state != 'U' && !status.plugged_in) {
                const auto last_plug = session.last_seen_plugged;
                if (last_plug.time_since_epoch().count() != 0 &&
                    (now - last_plug) < SEAMLESS_RETRY_GRACE_MS) {
                    seamless_retry_active = true;
                    hardware_->disable(connector);
                } else {
                    finish_and_mark(ocpp::v16::Reason::EVDisconnected, std::nullopt);
                    hardware_->disable(connector);
                    had_session = false;
                }
            } else if (had_session && !session.authorized && session.connected_at.time_since_epoch().count() &&
                       auth_timeout_enabled && (now - session.connected_at) > auth_wait_timeout) {
                EVLOG_warning << "Session on connector " << connector
                              << " timed out waiting for authorization, stopping session";
                set_auth_state(connector, AuthorizationState::Denied);
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
            } else if (had_session && session.authorized && !power_ready && session.authorized_at &&
                       power_request_timeout_enabled && !constrained && !paused &&
                       (now - *session.authorized_at) > power_request_timeout) {
                EVLOG_warning << "Session on connector " << connector
                              << " timed out waiting for EV power request after authorization";
                finish_and_mark(ocpp::v16::Reason::Other, std::nullopt);
                hardware_->disable(connector);
                had_session = false;
            } else if (had_session && power_ready && !session.transaction_started) {
                // Start OCPP transaction aligned to power delivery readiness
                std::lock_guard<std::mutex> lock(session_mutex_);
                auto it = sessions_.find(connector);
                if (it != sessions_.end() && !it->second.transaction_started && it->second.authorized &&
                    it->second.id_token.has_value()) {
                    charge_point_->on_transaction_started(connector, it->second.session_id, it->second.id_token.value(),
                                                          it->second.meter_start_wh, std::nullopt, ocpp::DateTime(),
                                                          std::nullopt);
                    it->second.transaction_started = true;
                    it->second.power_requested_at = now;
                    session = it->second;
                }
            }

            {
                std::lock_guard<std::mutex> lock(state_mutex_);
                post_stop_plugged = post_stop_plugged_[connector];
            }
            if (!had_session) {
                session = ActiveSession{};
            }
            update_connector_state(connector, status, had_session, session.transaction_started, session.authorized,
                                   fault, disabled, post_stop_plugged, seamless_retry_active);
        } catch (const std::exception& e) {
            EVLOG_warning << "Metering loop error on connector " << connector << ": " << e.what();
        }
        std::this_thread::sleep_for(control_tick);
    }
}

bool OcppAdapter::begin_transaction(std::int32_t connector, const std::string& id_token, bool prevalidated,
                                    ocpp::SessionStartedReason reason) {
    (void)reason;
    AuthToken token;
    token.id_token = id_token;
    token.source = AuthTokenSource::RemoteStart;
    token.connector_hint = connector;
    token.prevalidated = prevalidated;
    token.received_at = std::chrono::steady_clock::now();
    ingest_auth_tokens({token}, token.received_at);
    return true;
}

void OcppAdapter::finish_transaction(std::int32_t connector, ocpp::v16::Reason reason,
                                     std::optional<ocpp::CiString<20>> id_tag_end) {
    std::lock_guard<std::mutex> lock(session_mutex_);
    const auto it = sessions_.find(connector);
    if (it == sessions_.end()) {
        return;
    }

    const bool can_start = it->second.authorized && it->second.id_token.has_value();
    const auto pending_started = it->second.pending_started;
    const auto authorized_at = it->second.authorized_at;
    if (!it->second.transaction_started && can_start) {
        charge_point_->on_transaction_started(connector, it->second.session_id, it->second.id_token.value(),
                                               it->second.meter_start_wh, std::nullopt, ocpp::DateTime(),
                                               std::nullopt);
        it->second.transaction_started = true;
    }

    const auto session_id = it->second.session_id;
    if (it->second.transaction_started) {
        const auto measurement = hardware_->sample_meter(connector);
        const auto energy_wh = measurement.power_meter.energy_Wh_import.total;
        charge_point_->on_transaction_stopped(connector, session_id, reason, ocpp::DateTime(),
                                              static_cast<float>(energy_wh), id_tag_end, std::nullopt);
    }
    if (pending_started.time_since_epoch().count()) {
        const auto now = std::chrono::steady_clock::now();
        const auto auth_elapsed = authorized_at ? (authorized_at.value() - pending_started) : std::chrono::steady_clock::duration::zero();
        EVLOG_info << "Session " << session_id << " stop reason=" << static_cast<int>(reason)
                   << " auth_wait_ms=" << std::chrono::duration_cast<std::chrono::milliseconds>(auth_elapsed).count();
    }
    pending_tokens_.erase(connector);
    persist_pending_tokens_locked();
    set_auth_state(connector, AuthorizationState::Unknown);
    charge_point_->on_session_stopped(connector, session_id);
    sessions_.erase(it);
}

void OcppAdapter::push_meter_values(std::int32_t connector, const ocpp::Measurement& measurement) {
    if (charge_point_) {
        ocpp::Measurement adjusted = measurement;
        if (adjusted.power_meter.energy_Wh_import.total < 0.0) {
            adjusted.power_meter.energy_Wh_import.total = 0.0;
        }
        {
            std::lock_guard<std::mutex> lock(meter_mutex_);
            const double current = adjusted.power_meter.energy_Wh_import.total;
            const double last = last_energy_wh_[connector];
            if (current + 1e-3 < last) {
                EVLOG_warning << "Energy counter regression on connector " << connector << " (last=" << last
                              << "Wh, current=" << current << "Wh); clamping to monotonic";
                adjusted.power_meter.energy_Wh_import.total = last;
            } else {
                last_energy_wh_[connector] = current;
            }
        }
        charge_point_->on_meter_values(connector, adjusted);
    }
}

void OcppAdapter::report_fault(std::int32_t connector, const ocpp::v16::ErrorInfo& info) {
    if (charge_point_) {
        charge_point_->on_error(connector, info);
    }
}

void OcppAdapter::clear_faults(std::int32_t connector) {
    if (charge_point_) {
        charge_point_->on_all_errors_cleared(connector);
    }
}

void OcppAdapter::record_presence_state(std::int32_t connector, bool plugged_in,
                                        const std::chrono::steady_clock::time_point& now) {
    std::lock_guard<std::mutex> lock(session_mutex_);
    const auto it = plugged_in_state_.find(connector);
    const bool prev = it != plugged_in_state_.end() ? it->second : false;
    if (plugged_in && !prev) {
        plug_event_time_[connector] = now;
    }
    plugged_in_state_[connector] = plugged_in;
}

void OcppAdapter::ingest_auth_tokens(const std::vector<AuthToken>& tokens,
                                     const std::chrono::steady_clock::time_point& now) {
    if (tokens.empty()) {
        return;
    }
    const auto ttl = std::chrono::seconds(std::max(1, cfg_.auth_wait_timeout_s));
    std::lock_guard<std::mutex> lock(session_mutex_);
    for (auto token : tokens) {
        const auto dedup_it = recent_token_cache_.find(token.id_token);
        if (dedup_it != recent_token_cache_.end() && (now - dedup_it->second) < RECENT_TOKEN_DEDUP_WINDOW) {
            continue;
        }
        recent_token_cache_[token.id_token] = now;
        PendingToken pending;
        pending.token = token;
        if (pending.token.received_at.time_since_epoch().count() == 0) {
            pending.token.received_at = now;
        }
        pending.expires_at = pending.token.received_at + ttl;
        const int target = select_connector_for_token(pending.token);
        pending_tokens_[target].push_back(std::move(pending));
    }
    persist_pending_tokens_locked();
}

int OcppAdapter::select_connector_for_token(const AuthToken& token) const {
    if (token.connector_hint > 0) {
        const bool exists = std::any_of(cfg_.connectors.begin(), cfg_.connectors.end(),
                                        [&](const ConnectorConfig& c) { return c.id == token.connector_hint; });
        if (exists) {
            return token.connector_hint;
        }
    }
    int best = cfg_.connectors.empty() ? 1 : cfg_.connectors.front().id;
    auto latest = std::chrono::steady_clock::time_point{};
    for (const auto& kv : plug_event_time_) {
        const bool plugged = plugged_in_state_.count(kv.first) ? plugged_in_state_.at(kv.first) : false;
        if (!plugged) continue;
        if (latest.time_since_epoch().count() == 0 || kv.second > latest) {
            latest = kv.second;
            best = kv.first;
        }
    }
    return best;
}

std::optional<OcppAdapter::PendingToken>
OcppAdapter::pop_next_pending_token(std::int32_t connector, const std::chrono::steady_clock::time_point& now,
                                    const std::optional<std::string>& required_token,
                                    const std::optional<std::string>& parent_token) {
    auto it = pending_tokens_.find(connector);
    if (it == pending_tokens_.end()) {
        return std::nullopt;
    }
    auto& queue = it->second;
    auto priority = [](AuthTokenSource src) {
        switch (src) {
        case AuthTokenSource::RemoteStart:
            return 0;
        case AuthTokenSource::RFID:
            return 1;
        case AuthTokenSource::Autocharge:
            return 2;
        default:
            return 3;
        }
    };
    for (auto qit = queue.begin(); qit != queue.end();) {
        if (qit->expires_at <= now) {
            qit = queue.erase(qit);
        } else {
            ++qit;
        }
    }
    if (queue.empty()) {
        return std::nullopt;
    }
    auto matches_reservation = [&](const PendingToken& p) {
        if (!required_token) return true;
        const auto trimmed = clamp_id_token(p.token.id_token);
        if (trimmed == *required_token) return true;
        if (parent_token && trimmed == *parent_token) return true;
        return false;
    };
    std::optional<std::size_t> best_idx;
    int best_prio = std::numeric_limits<int>::max();
    for (std::size_t idx = 0; idx < queue.size(); ++idx) {
        if (!matches_reservation(queue[idx])) continue;
        const int prio = priority(queue[idx].token.source);
        if (!best_idx || prio < best_prio ||
            (prio == best_prio && queue[idx].token.received_at < queue[*best_idx].token.received_at)) {
            best_prio = prio;
            best_idx = idx;
        }
    }
    if (!best_idx) {
        return std::nullopt;
    }
    PendingToken selected = queue[*best_idx];
    queue.erase(queue.begin() + static_cast<std::ptrdiff_t>(*best_idx));
    persist_pending_tokens_locked();
    return selected;
}

AuthorizationState OcppAdapter::try_authorize_with_token(std::int32_t connector, ActiveSession& session,
                                                         const PendingToken& pending) {
    if (session.authorized) {
        return AuthorizationState::Granted;
    }
    const auto trimmed = clamp_id_token(pending.token.id_token);
    bool accepted = false;
    if (pending.token.prevalidated || authorize_from_cache(trimmed)) {
        accepted = true;
    } else if (charge_point_) {
        const auto info = charge_point_->authorize_id_token(ocpp::CiString<20>(trimmed));
        accepted = (info.id_tag_info.status == ocpp::v16::AuthorizationStatus::Accepted);
        if (accepted) {
            update_local_auth_cache(trimmed);
        }
    }
    if (accepted) {
        session.authorized = true;
        session.id_token = trimmed;
        session.authorized_at = std::chrono::steady_clock::now();
        session.token_source = pending.token.source;
        set_auth_state(connector, AuthorizationState::Granted);
        persist_pending_tokens_locked();
        return AuthorizationState::Granted;
    } else {
        const bool keep_waiting = (pending.token.source == AuthTokenSource::Autocharge);
        const auto state = keep_waiting ? AuthorizationState::Pending : AuthorizationState::Denied;
        set_auth_state(connector, state);
        persist_pending_tokens_locked();
        return state;
    }
}

bool OcppAdapter::authorize_from_cache(const std::string& token) {
    std::lock_guard<std::mutex> lock(session_mutex_);
    const auto it = local_auth_cache_.find(token);
    if (it == local_auth_cache_.end()) {
        return false;
    }
    const auto now = std::chrono::steady_clock::now();
    if ((now - it->second) > LOCAL_AUTH_CACHE_TTL) {
        local_auth_cache_.erase(it);
        persist_local_auth_cache_locked();
        return false;
    }
    EVLOG_info << "Authorizing via local cache for token " << token;
    return true;
}

void OcppAdapter::update_local_auth_cache(const std::string& token) {
    std::lock_guard<std::mutex> lock(session_mutex_);
    local_auth_cache_[token] = std::chrono::steady_clock::now();
    persist_local_auth_cache_locked();
}

std::string OcppAdapter::clamp_id_token(const std::string& raw) const {
    constexpr std::size_t kMaxLen = 20;
    if (raw.size() <= kMaxLen) {
        return raw;
    }
    return raw.substr(0, kMaxLen);
}

bool OcppAdapter::has_active_session(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(session_mutex_);
    return sessions_.find(connector) != sessions_.end();
}

void OcppAdapter::apply_power_plan() {
    std::lock_guard<std::mutex> plan_lock(plan_mutex_);
    const auto now = std::chrono::steady_clock::now();
    if (module_controller_) {
        module_controller_->poll();
    }
    auto enforce_hold = [&](const std::string& id, ContactorState desired,
                            std::map<std::string, ContactorState>& last_state,
                            std::map<std::string, std::chrono::steady_clock::time_point>& last_change,
                            int hold_ms, bool prefer_open) -> ContactorState {
        const auto prev_it = last_state.find(id);
        const ContactorState prev = prev_it != last_state.end() ? prev_it->second : ContactorState::Open;
        const auto ts_it = last_change.find(id);
        const bool in_hold = ts_it != last_change.end() &&
            (now - ts_it->second) < std::chrono::milliseconds(std::max(0, hold_ms));
        if (in_hold && desired != prev) {
            if (prefer_open && desired == ContactorState::Open) {
                last_change[id] = now;
                last_state[id] = desired;
                return desired;
            }
            return prev;
        }
        if (desired != prev) {
            last_change[id] = now;
        }
        last_state[id] = desired;
        return desired;
    };
    std::vector<GunState> guns;
    guns.reserve(cfg_.connectors.size());
    std::map<int, GunState> gun_lookup;
    struct ConnSnapshot {
        GunStatus status;
        double measured_power_kw{0.0};
        double measured_current_a{0.0};
    };
    std::map<int, ConnSnapshot> snapshots;
    bool trip_global = false;
    std::string global_reason;
    auto derate_linear = [](double value, double temp_c, double start_c, double trip_c) {
        if (value <= 0.0) return 0.0;
        if (trip_c <= start_c) return value;
        if (temp_c >= trip_c) return 0.0;
        if (temp_c <= start_c) return value;
        const double scale = 1.0 - ((temp_c - start_c) / (trip_c - start_c));
        return value * std::max(0.0, scale);
    };
    for (const auto& c : cfg_.connectors) {
        power_constrained_[c.id] = false;
    }

    for (const auto& c : cfg_.connectors) {
        GunStatus st = hardware_->get_status(c.id);
        const uint64_t prev_present_stale = last_present_stale_counts_[c.id];
        const uint64_t prev_limit_stale = last_limit_stale_counts_[c.id];
        if (st.present_stale_events > prev_present_stale) {
            EVLOG_warning << "Connector " << c.id << " EVSE_PRESENT cadence stale events observed ("
                          << st.present_stale_events << "); treating as comm fault";
            st.comm_fault = true;
            power_constrained_[c.id] = true;
            last_present_stale_counts_[c.id] = st.present_stale_events;
        }
        if (st.limit_stale_events > prev_limit_stale) {
            EVLOG_warning << "Connector " << c.id << " EVSE_LIMIT cadence stale events observed ("
                          << st.limit_stale_events << "); constraining power";
            power_constrained_[c.id] = true;
            last_limit_stale_counts_[c.id] = st.limit_stale_events;
        }
        static std::map<int, uint64_t> last_relay_conflict;
        const uint64_t prev_relay_conflict = last_relay_conflict[c.id];
        if (st.relay_conflict_count > prev_relay_conflict) {
            last_relay_conflict[c.id] = st.relay_conflict_count;
            EVLOG_error << "Connector " << c.id << " relay conflict/weld detected; halting charging";
            st.comm_fault = true;
            power_constrained_[c.id] = true;
        }
        const Slot* slot_for_conn = find_slot_for_gun(c.id);
        if (module_controller_ && slot_for_conn) {
            auto snap = module_controller_->snapshot_for_slot(slot_for_conn->id);
            if (snap.valid) {
                st.module_healthy_mask = snap.healthy_mask;
                st.module_fault_mask = snap.fault_mask;
                for (std::size_t i = 0; i < snap.temperatures_c.size() && i < st.module_temp_c.size(); ++i) {
                    st.module_temp_c[i] = snap.temperatures_c[i];
                }
            }
        }
        if (safety_trip_needed(st)) {
            trip_global = true;
            if (global_reason.empty()) {
                if (st.estop) {
                    global_reason = "estop";
                } else if (st.earth_fault) {
                    global_reason = "earth_fault";
                } else {
                    global_reason = "safety";
                }
            }
        }

        GunState g{};
        g.id = c.id;
        g.slot_id = slot_for_conn ? slot_for_conn->id : c.id;
        g.gc_id = slot_for_conn ? slot_for_conn->gc_id : "GC_" + std::to_string(c.id);
        g.gun_power_limit_kw = c.max_power_w > 0 ? c.max_power_w / 1000.0 : 0.0;
        g.gun_current_limit_a = c.max_current_a > 0 ? c.max_current_a : 0.0;
        g.max_voltage_v = c.max_voltage_v > 0.0 ? c.max_voltage_v : 0.0;
        g.min_voltage_v = c.min_voltage_v > 0.0 ? c.min_voltage_v : planner_cfg_.min_voltage_v_for_div;
        g.priority = 0;
        g.i_set_a = last_current_limit_a_[c.id];
        g.connector_temp_c = st.connector_temp_c;
        g.gc_welded = st.gc_welded;
        g.mc_welded = st.mc_welded;
        g.safety_ok = st.safety_ok && !st.estop && !st.earth_fault && !st.isolation_fault &&
                      !st.overtemp_fault && !st.overcurrent_fault && !st.comm_fault;
        g.plugged_in = st.plugged_in;
        g.reserved = reserved_connectors_[c.id];
        if (planner_cfg_.connector_derate_trip_c > 0.0 &&
            st.connector_temp_c >= planner_cfg_.connector_derate_trip_c) {
            g.safety_ok = false;
        }

        const bool lock_required = c.require_lock;
        bool session_present = false;
        bool session_authorized = false;
        {
            std::lock_guard<std::mutex> lock(session_mutex_);
            auto sit = sessions_.find(c.id);
            if (sit != sessions_.end()) {
                session_present = true;
                session_authorized = sit->second.authorized;
            }
        }
        const bool disabled_by_csms = evse_disabled_.count(c.id) ? evse_disabled_[c.id] : false;
        const bool paused_by_csms = paused_evse_.count(c.id) ? paused_evse_[c.id] : false;
        const bool session_ready = session_present && session_authorized && !disabled_by_csms && !paused_by_csms;
        const bool power_ready = session_ready &&
            (st.relay_closed || power_delivery_requested(st, lock_required));
        if (session_present) {
            g.reserved = false;
            reserved_connectors_[c.id] = false;
        }

        if (st.evse_max_current_a) {
            g.gun_current_limit_a = g.gun_current_limit_a > 0.0
                                        ? std::min(g.gun_current_limit_a, st.evse_max_current_a.value())
                                        : st.evse_max_current_a.value();
        }
        if (st.evse_max_power_kw) {
            g.gun_power_limit_kw = g.gun_power_limit_kw > 0.0
                                       ? std::min(g.gun_power_limit_kw, st.evse_max_power_kw.value())
                                       : st.evse_max_power_kw.value();
        }
        if (profile_current_limit_a_.count(c.id) && profile_current_limit_a_[c.id] > 0.0) {
            g.gun_current_limit_a = g.gun_current_limit_a > 0.0
                                        ? std::min(g.gun_current_limit_a, profile_current_limit_a_[c.id])
                                        : profile_current_limit_a_[c.id];
        }
        if (profile_power_limit_kw_.count(c.id) && profile_power_limit_kw_[c.id] > 0.0) {
            g.gun_power_limit_kw = g.gun_power_limit_kw > 0.0
                                       ? std::min(g.gun_power_limit_kw, profile_power_limit_kw_[c.id])
                                       : profile_power_limit_kw_[c.id];
        }

        double measured_v = st.present_voltage_v ? st.present_voltage_v.value()
                                                 : (last_voltage_v_[c.id] > 50.0 ? last_voltage_v_[c.id]
                                                                                  : planner_cfg_.default_voltage_v);
        if (measured_v > 0.0) {
            last_voltage_v_[c.id] = measured_v;
        }
        double measured_i =
            st.present_current_a ? st.present_current_a.value()
                                 : (last_power_w_[c.id] > 0 && measured_v > 0.0 ? last_power_w_[c.id] / measured_v
                                                                                : 0.0);
        double measured_power_kw =
            st.present_power_w ? st.present_power_w.value() / 1000.0
                               : (last_power_w_[c.id] > 0 ? last_power_w_[c.id] / 1000.0 : 0.0);
        if (st.present_power_w) {
            last_power_w_[c.id] = st.present_power_w.value();
        }
        const bool welded = st.gc_welded || st.mc_welded;
        const bool isolation_fault = st.isolation_fault || st.earth_fault || st.estop;
        const bool comm_fault = st.comm_fault;
        const bool thermal_fault = st.overtemp_fault;
        const bool overcurrent_fault = st.overcurrent_fault;
        const bool general_fault = !st.safety_ok || st.cp_fault || st.meter_stale || welded || isolation_fault ||
                                   thermal_fault || overcurrent_fault || comm_fault;
        uint8_t fault_bits = 0;
        if (general_fault) fault_bits |= 0x01;
        if (comm_fault) fault_bits |= 0x02;
        if (isolation_fault) fault_bits |= 0x04;
        if (thermal_fault) fault_bits |= 0x08;
        if (overcurrent_fault) fault_bits |= 0x10;
        if (welded) fault_bits |= 0x20;
        if (hardware_) {
            const bool output_enabled = st.relay_closed;
            const bool regulating = power_ready;
            hardware_->publish_fault_state(c.id, fault_bits);
            hardware_->publish_evse_present(c.id, measured_v, measured_i, measured_power_kw, output_enabled,
                                            regulating);
        }

        const uint8_t healthy_mask = st.module_healthy_mask;
        const uint8_t fault_mask = st.module_fault_mask;
        const uint8_t usable_mask = static_cast<uint8_t>(healthy_mask & static_cast<uint8_t>(~fault_mask));
        const int healthy_modules = popcount(usable_mask);
        const bool modules_ok = healthy_modules > 0;

        double req_kw = 0.0;
        if (power_ready && g.safety_ok && modules_ok && !st.gc_welded && !st.mc_welded) {
            if (st.target_voltage_v && st.target_current_a) {
                req_kw = (st.target_voltage_v.value() * st.target_current_a.value()) / 1000.0;
            } else if (st.target_current_a) {
                req_kw = (measured_v > 0.0 ? measured_v : 800.0) * st.target_current_a.value() / 1000.0;
            } else if (st.evse_max_power_kw) {
                req_kw = st.evse_max_power_kw.value();
            } else if (last_requested_power_kw_[c.id] > 0.0) {
                req_kw = last_requested_power_kw_[c.id];
            } else if (g.gun_power_limit_kw > 0.0) {
                req_kw = g.gun_power_limit_kw;
            }
            if (req_kw <= 0.0) {
                req_kw = g.gun_power_limit_kw;
            }
        }
        g.ev_req_power_kw = std::max(0.0, req_kw);
        g.ev_req_voltage_v = st.target_voltage_v ? st.target_voltage_v.value()
                                                 : (st.present_voltage_v ? st.present_voltage_v.value() : measured_v);
        if (g.ev_req_voltage_v <= 0.0) {
            g.ev_req_voltage_v = measured_v > 0.0 ? measured_v : planner_cfg_.default_voltage_v;
        }
        double max_voltage_v = std::numeric_limits<double>::max();
        if (c.max_voltage_v > 0.0) {
            max_voltage_v = c.max_voltage_v;
        }
        if (st.evse_max_voltage_v) {
            max_voltage_v = std::min(max_voltage_v, st.evse_max_voltage_v.value());
        }
        if (g.min_voltage_v > 0.0 && g.ev_req_voltage_v < g.min_voltage_v) {
            g.ev_req_voltage_v = g.min_voltage_v;
        }
        g.ev_req_voltage_v = std::min(g.ev_req_voltage_v, max_voltage_v);
        g.i_meas_a = measured_i;

        // Update module health by slot
        if (slot_for_conn) {
            for (std::size_t idx = 0; idx < slot_for_conn->modules.size(); ++idx) {
                const auto& module_id = slot_for_conn->modules[idx];
                for (auto& mod : module_states_) {
                    if (mod.id == module_id) {
                        const uint8_t bit = static_cast<uint8_t>(1U << idx);
                        const bool healthy_bit = (st.module_healthy_mask & bit) != 0;
                        const bool fault_bit = (st.module_fault_mask & bit) != 0;
                        const double module_temp = st.module_temp_c[idx];
                        mod.temperature_c = module_temp;
                        bool healthy = healthy_bit && g.safety_ok && !fault_bit;
                        if (planner_cfg_.module_derate_trip_c > 0.0 &&
                            module_temp >= planner_cfg_.module_derate_trip_c) {
                            healthy = false;
                        }
                        mod.healthy = healthy;
                        break;
                    }
                }
            }
        }
        int runtime_healthy_modules = healthy_modules;
        if (slot_for_conn) {
            runtime_healthy_modules = 0;
            for (const auto& mod : module_states_) {
                if (mod.slot_id == slot_for_conn->id && mod.healthy) {
                    runtime_healthy_modules++;
                }
            }
        }
        const bool blocked = !g.safety_ok || runtime_healthy_modules <= 0 || st.gc_welded || st.mc_welded;
        g.ev_session_active = session_ready;
        const bool ready_for_power = power_ready && !blocked;

        if (blocked) {
            g.fsm_state = GunFsmState::Fault;
        } else if (st.relay_closed) {
            g.fsm_state = GunFsmState::Charging;
        } else if (ready_for_power) {
            g.fsm_state = GunFsmState::Ready;
        } else if (session_present) {
            g.fsm_state = GunFsmState::EvDetected;
        } else {
            g.fsm_state = GunFsmState::Idle;
        }
        // EVSE limit watchdog: if we have offered limits recently but PLC hasn't ACKed, constrain power.
        if (st.last_evse_limit_ack.time_since_epoch().count() > 0) {
            const auto age = now - st.last_evse_limit_ack;
            const auto warn_threshold = std::max(std::chrono::milliseconds(500),
                                                 evse_limit_ack_timeout(cfg_) / 2);
            if (age > warn_threshold && ready_for_power) {
                power_constrained_[c.id] = true;
                EVLOG_warning << "Connector " << c.id << " EVSE limit ACK stale (" << age.count()
                              << "ms); constraining power";
            }
        }
        guns.push_back(g);
        gun_lookup[g.id] = g;

        snapshots[c.id] = ConnSnapshot{st, measured_power_kw, measured_i};
        if (g.connector_temp_c > 0.0) {
            g.gun_current_limit_a = derate_linear(g.gun_current_limit_a, g.connector_temp_c,
                                                  planner_cfg_.connector_derate_start_c,
                                                  planner_cfg_.connector_derate_trip_c);
            g.gun_power_limit_kw = derate_linear(g.gun_power_limit_kw, g.connector_temp_c,
                                                 planner_cfg_.connector_derate_start_c,
                                                 planner_cfg_.connector_derate_trip_c);
            if (g.gun_current_limit_a <= 0.0) {
                g.safety_ok = false;
            }
        }
    }

    if (!trip_global && global_fault_latched_) {
        global_fault_latched_ = false;
        global_fault_reason_.clear();
        EVLOG_info << "Global fault cleared";
    }

    if (trip_global || global_fault_latched_) {
        enter_global_fault(global_reason.empty() ? "safety" : global_reason, ocpp::v16::Reason::EmergencyStop);
        apply_zero_power_plan();
        return;
    }

    power_manager_.update_modules(module_states_);
    power_manager_.update_guns(guns);
    const auto plan = power_manager_.compute_plan();

    // Update module enabled flags from MN commands
    for (auto& m : module_states_) {
        const auto it = plan.mn_commands.find(m.mn_id);
        if (it != plan.mn_commands.end()) {
            m.enabled = (it->second == ContactorState::Closed);
        } else {
            m.enabled = false;
        }
    }

    // Build dispatch lookup
    std::map<int, GunDispatch> gun_dispatch;
    for (const auto& d : plan.guns) {
        gun_dispatch[d.gun_id] = d;
    }
    {
        std::ostringstream os;
        os << "Planner summary";
        for (const auto& d : plan.guns) {
            os << " [g" << d.gun_id << " m=" << d.modules_assigned << " i_lim=" << d.current_limit_a
               << " p=" << d.p_budget_kw << " V=" << d.voltage_set_v << "]";
        }
        EVLOG_debug << os.str();
    }

    std::map<int, SlotModuleSelection> slot_selections;
    for (const auto& c : cfg_.connectors) {
        const Slot* slot = find_slot_for_gun(c.id);
        if (!slot) continue;
        auto sel = compute_slot_module_selection(plan, *slot);
        slot_selections[slot->id] = sel;
    }

    struct SlotCommandInfo {
        SlotModuleSelection selection;
        GunStatus status;
        GunState gun_state;
        bool disabled_by_csms{false};
        bool paused{false};
        bool local_fault{false};
        int modules_final{0};
        uint8_t mask_final{0};
        ContactorState desired_mc_state{ContactorState::Closed};
        ContactorState desired_gc_state{ContactorState::Open};
        double meas_current{0.0};
        double meas_voltage{0.0};
        std::string fault_reason;
    };

    std::map<int, SlotCommandInfo> slot_info;
    std::map<int, int> actual_modules_per_gun;
    std::map<int, bool> island_fault;
    std::map<int, std::string> island_fault_reason;

    for (const auto& c : cfg_.connectors) {
        const Slot* slot = find_slot_for_gun(c.id);
        if (!slot) continue;

        SlotCommandInfo info{};
        info.selection = slot_selections.count(slot->id) ? slot_selections[slot->id] : SlotModuleSelection{};
        const auto mc_it = plan.mc_commands.find(slot->mc_id);
        info.desired_mc_state = mc_it != plan.mc_commands.end() ? mc_it->second : ContactorState::Closed;
        const auto gc_it = plan.gc_commands.find(slot->gc_id);
        info.desired_gc_state = gc_it != plan.gc_commands.end() ? gc_it->second : ContactorState::Open;
        const auto snap_it = snapshots.find(c.id);
        info.status = snap_it != snapshots.end() ? snap_it->second.status : GunStatus{};
        info.meas_current = snap_it != snapshots.end() ? snap_it->second.measured_current_a : 0.0;
        info.meas_voltage = snap_it != snapshots.end() ? snap_it->second.status.present_voltage_v.value_or(last_voltage_v_[c.id])
                                                       : last_voltage_v_[c.id];
        info.gun_state = gun_lookup.count(c.id) ? gun_lookup.at(c.id) : GunState{};
        info.disabled_by_csms = evse_disabled_.count(c.id) ? evse_disabled_[c.id] : false;
        info.paused = paused_evse_[c.id] || info.disabled_by_csms;

        int runtime_healthy_modules = 0;
        for (const auto& m : module_states_) {
            if (m.slot_id == slot->id && m.healthy) {
                runtime_healthy_modules++;
            }
        }

        if (info.status.gc_welded) info.fault_reason = "GCWelded";
        if (info.status.mc_welded) info.fault_reason = "MCWelded";
        if (info.status.isolation_fault && info.fault_reason.empty()) info.fault_reason = "Isolation";
        if (info.status.overtemp_fault && info.fault_reason.empty()) info.fault_reason = "Overtemp";
        if (info.status.overcurrent_fault && info.fault_reason.empty()) info.fault_reason = "Overcurrent";
        if (info.status.comm_fault && info.fault_reason.empty()) info.fault_reason = "CommFault";
        info.local_fault = !info.gun_state.safety_ok || runtime_healthy_modules <= 0 || info.status.gc_welded ||
                           info.status.mc_welded || info.status.isolation_fault || info.status.overtemp_fault ||
                           info.status.overcurrent_fault || info.status.comm_fault;

        if (info.selection.gun_id > 0 && info.selection.module_count > 0 && !info.local_fault &&
            !info.disabled_by_csms && info.desired_mc_state == ContactorState::Closed) {
            info.modules_final = info.selection.module_count;
            info.mask_final = info.selection.mask;
        } else {
            info.modules_final = 0;
            info.mask_final = 0;
        }

        slot_info[slot->id] = info;
        if (info.selection.gun_id > 0) {
            actual_modules_per_gun[info.selection.gun_id] += info.modules_final;
            if (info.local_fault && !island_fault[info.selection.gun_id]) {
                island_fault[info.selection.gun_id] = true;
                island_fault_reason[info.selection.gun_id] =
                    info.fault_reason.empty() ? "IslandSlotFault" : info.fault_reason;
            }
        }
    }

    std::map<int, GunDispatch> adjusted_dispatch = gun_dispatch;
    for (auto& kv : adjusted_dispatch) {
        auto& disp = kv.second;
        const int gid = kv.first;
        const int actual = actual_modules_per_gun.count(gid) ? actual_modules_per_gun[gid] : 0;
        disp.modules_assigned = actual;
        const auto g_it = gun_lookup.find(gid);
        const double gun_cap = g_it != gun_lookup.end() && g_it->second.gun_power_limit_kw > 0.0
                                   ? g_it->second.gun_power_limit_kw
                                   : disp.p_budget_kw;
        const double p_cap_modules = actual * planner_cfg_.module_power_kw;
        const double p_set = std::min({disp.p_budget_kw, p_cap_modules, gun_cap});
        const double v_target = disp.voltage_set_v > 0.0 ? disp.voltage_set_v : planner_cfg_.default_voltage_v;
        const double v_safe = std::max(planner_cfg_.min_voltage_v_for_div, v_target);
        double i_target = v_safe > 0.0 ? (p_set * 1000.0) / v_safe : 0.0;
        if (g_it != gun_lookup.end() && g_it->second.gun_current_limit_a > 0.0) {
            i_target = std::min(i_target, g_it->second.gun_current_limit_a);
        }
        disp.p_set_kw = p_set;
        disp.voltage_set_v = v_target;
        disp.current_limit_a = i_target;
    }

    for (const auto& c : cfg_.connectors) {
        const Slot* slot = find_slot_for_gun(c.id);
        if (!slot) continue;
        const auto info_it = slot_info.find(slot->id);
        SlotCommandInfo info{};
        if (info_it != slot_info.end()) {
            info = info_it->second;
        }
        const int gun_for_slot = info.selection.gun_id;
        const bool in_island = info.selection.in_island && gun_for_slot > 0;
        const bool is_home = in_island && slot->gun_id == gun_for_slot;

        const auto disp_it = adjusted_dispatch.find(gun_for_slot);
        GunDispatch dispatch{};
        if (disp_it != adjusted_dispatch.end()) {
            dispatch = disp_it->second;
        } else {
            dispatch.gun_id = gun_for_slot;
            dispatch.voltage_set_v = info.meas_voltage > 0.0 ? info.meas_voltage : planner_cfg_.default_voltage_v;
        }

        const auto snap_it = snapshots.find(c.id);
        const GunStatus status = snap_it != snapshots.end() ? snap_it->second.status : GunStatus{};
        const double meas_i = snap_it != snapshots.end() ? snap_it->second.measured_current_a : 0.0;
        const GunState g = gun_lookup.count(c.id) ? gun_lookup.at(c.id) : GunState{};
        bool local_fault = info.local_fault;
        if (is_home && island_fault.count(gun_for_slot) && island_fault[gun_for_slot] && !local_fault) {
            local_fault = true;
            info.fault_reason = island_fault_reason[gun_for_slot];
        }

        // MC sequencing: honor open-on-charge islands but gate opens on low current with a short timeout.
        const double mc_open_thresh = planner_cfg_.mc_open_current_a > 0.0 ? planner_cfg_.mc_open_current_a : 0.5;
        bool mc_closed_cmd = (info.desired_mc_state == ContactorState::Closed);
        bool isolation_ready = true;
        const bool mc_change_requested = last_mc_state_.count(slot->mc_id) &&
            info.desired_mc_state != last_mc_state_[slot->mc_id];
        if (mc_change_requested &&
            ((status.relay_closed || std::fabs(meas_i) >= mc_open_thresh))) {
            mc_closed_cmd = (last_mc_state_[slot->mc_id] == ContactorState::Closed);
            power_constrained_[c.id] = true;
            EVLOG_debug << "Deferring MC change for slot " << slot->id << " while charging is active";
            isolation_ready = false;
        } else if (info.desired_mc_state == ContactorState::Open && !local_fault) {
            const bool already_isolated =
                (last_mc_state_[slot->mc_id] == ContactorState::Open) &&
                (!mc_open_pending_.count(slot->id) || !mc_open_pending_[slot->id]);
            if (!already_isolated) {
                const bool safe_to_open = (std::fabs(meas_i) < mc_open_thresh) || !status.relay_closed;
                if (!safe_to_open) {
                    mc_closed_cmd = true;
                    mc_open_pending_[slot->id] = true;
                    auto& ts = mc_open_request_time_[slot->id];
                    if (ts.time_since_epoch().count() == 0) {
                        ts = now;
                    } else if ((now - ts) > MC_OPEN_TIMEOUT_MS) {
                        local_fault = true;
                        info.fault_reason = info.fault_reason.empty() ? "MCOpenTimeout" : info.fault_reason;
                        EVLOG_warning << "MC open timeout for slot " << slot->id << " (gun " << gun_for_slot
                                      << "); locking out connector";
                    }
                    isolation_ready = false;
                } else {
                    mc_closed_cmd = false;
                    mc_open_pending_.erase(slot->id);
                    mc_open_request_time_.erase(slot->id);
                }
            } else {
                mc_closed_cmd = false;
            }
        } else {
            mc_open_pending_.erase(slot->id);
            mc_open_request_time_.erase(slot->id);
            mc_closed_cmd = (info.desired_mc_state == ContactorState::Closed);
        }
        if (local_fault) {
            isolation_ready = false;
            mc_open_pending_.erase(slot->id);
            mc_open_request_time_.erase(slot->id);
            mc_closed_cmd = false;
        }

        // GC: avoid opening under load unless forced; rely on PLC to ramp to zero.
        const double gc_open_thresh = planner_cfg_.gc_open_current_a > 0.0 ? planner_cfg_.gc_open_current_a : 0.5;
        bool gc_closed_cmd = is_home && (info.desired_gc_state == ContactorState::Closed) &&
                             dispatch.modules_assigned > 0 && !info.disabled_by_csms && !local_fault;
        if (!gc_closed_cmd && !local_fault && is_home) {
            const bool safe_to_open = std::fabs(meas_i) < gc_open_thresh || !status.relay_closed;
            if (!safe_to_open) {
                gc_closed_cmd = true;
                gc_open_pending_[c.id] = true;
                auto& ts = gc_open_request_time_[c.id];
                if (ts.time_since_epoch().count() == 0) {
                    ts = now;
                } else if ((now - ts) > GC_OPEN_TIMEOUT_MS) {
                    local_fault = true;
                    info.fault_reason = info.fault_reason.empty() ? "GCOpenTimeout" : info.fault_reason;
                    EVLOG_warning << "GC open timeout for connector " << c.id
                                  << " while waiting for current to drop";
                }
            } else {
                gc_open_pending_.erase(c.id);
                gc_open_request_time_.erase(c.id);
            }
        } else if (!is_home) {
            gc_open_pending_.erase(c.id);
            gc_open_request_time_.erase(c.id);
        } else {
            gc_open_pending_.erase(c.id);
            gc_open_request_time_.erase(c.id);
        }
        if (info.disabled_by_csms || local_fault) {
            gc_closed_cmd = false;
        }

        const auto enforced_mc = enforce_hold(slot->mc_id,
                                              mc_closed_cmd ? ContactorState::Closed : ContactorState::Open,
                                              last_mc_state_, mc_command_change_time_,
                                              planner_cfg_.min_mc_hold_ms, true);
        mc_closed_cmd = (enforced_mc == ContactorState::Closed);
        const auto enforced_gc = enforce_hold(slot->gc_id,
                                              gc_closed_cmd ? ContactorState::Closed : ContactorState::Open,
                                              last_gc_state_, gc_command_change_time_,
                                              planner_cfg_.min_gc_hold_ms, true);
        gc_closed_cmd = (enforced_gc == ContactorState::Closed);

        // Precharge/voltage match before closing GC (home slot only).
        bool precharge_ok = true;
        if (is_home) {
            const double v_target = dispatch.voltage_set_v;
            double v_meas = status.present_voltage_v ? status.present_voltage_v.value() : last_voltage_v_[c.id];
            if (v_meas <= 0.0) v_meas = last_voltage_v_[c.id];
            if (v_meas <= 0.0) v_meas = planner_cfg_.default_voltage_v;
            const bool precharge_needed = dispatch.modules_assigned > 0 && gc_closed_cmd &&
                                          !info.disabled_by_csms && !local_fault;
            if (precharge_needed) {
                const double dv = std::fabs(v_meas - v_target);
                precharge_ok = dv <= cfg_.precharge_voltage_tolerance_v;
                if (!precharge_ok) {
                    auto& ts = precharge_start_[c.id];
                    if (ts.time_since_epoch().count() == 0) {
                        ts = now;
                    } else if ((now - ts) > std::chrono::milliseconds(cfg_.precharge_timeout_ms)) {
                        local_fault = true;
                        info.fault_reason = info.fault_reason.empty() ? "PrechargeTimeout" : info.fault_reason;
                        EVLOG_warning << "Precharge timeout for connector " << c.id;
                    }
                } else {
                    precharge_start_.erase(c.id);
                }
            } else {
                precharge_start_.erase(c.id);
            }
            if (!precharge_ok) {
                gc_closed_cmd = false;
            }
            if (local_fault) {
                precharge_start_.erase(c.id);
            }
        }

        const bool modules_allowed = in_island && !local_fault && !info.disabled_by_csms &&
                                     isolation_ready && dispatch.modules_assigned > 0 && mc_closed_cmd;
        const int slot_module_cmd = modules_allowed ? info.modules_final : 0;
        const uint8_t slot_mask_cmd = modules_allowed ? info.mask_final : 0;
        const int gc_module_count = is_home ? dispatch.modules_assigned : slot_module_cmd;
        const bool allow_energy = modules_allowed && gc_closed_cmd && isolation_ready && precharge_ok && is_home;

        PowerCommand cmd;
        cmd.connector = c.id;
        cmd.module_count = gc_module_count;
        cmd.module_mask = slot_mask_cmd;
        cmd.gc_closed = gc_closed_cmd;
        cmd.mc_closed = (!info.disabled_by_csms && !local_fault) ? mc_closed_cmd : false;
        cmd.voltage_set_v = dispatch.voltage_set_v;
        cmd.current_limit_a = allow_energy ? dispatch.current_limit_a : 0.0;
        cmd.power_kw = allow_energy ? dispatch.p_set_kw : 0.0;

        if (info.paused && g.ev_session_active && is_home) {
            cmd.current_limit_a = 0.0;
            cmd.power_kw = 0.0;
            if (info.disabled_by_csms) {
                cmd.gc_closed = false;
                cmd.mc_closed = (!local_fault && !info.disabled_by_csms) ? mc_closed_cmd : false;
                cmd.module_count = 0;
                cmd.module_mask = 0;
            } else {
                if (!allow_energy && isolation_ready && !local_fault) {
                    cmd.gc_closed = gc_closed_cmd;
                }
                cmd.mc_closed = (!info.disabled_by_csms && !local_fault) ? mc_closed_cmd : false;
                if (cmd.module_mask == 0 && slot_mask_cmd != 0) {
                    cmd.module_mask = slot_mask_cmd;
                } else if (cmd.module_mask == 0 && last_module_mask_cmd_[c.id] != 0) {
                    cmd.module_mask = last_module_mask_cmd_[c.id];
                }
            }
        }

        if (module_controller_ && slot) {
            ModuleCommandRequest mreq;
            mreq.slot_id = slot->id;
            mreq.mask = slot_mask_cmd;
            mreq.enable = modules_allowed;
            mreq.voltage_v = dispatch.voltage_set_v;
            mreq.current_a = dispatch.current_limit_a;
            mreq.power_kw = dispatch.p_set_kw;
            module_controller_->apply_command(mreq);
        }

        last_current_limit_a_[c.id] = cmd.current_limit_a;
        last_requested_power_kw_[c.id] = dispatch.p_set_kw;
        last_module_alloc_[c.id] = cmd.module_count;
        last_module_mask_cmd_[c.id] = cmd.module_mask;
        EvseLimits limits{};
        if (dispatch.voltage_set_v > 0.0) {
            limits.max_voltage_v = dispatch.voltage_set_v;
        }
        limits.max_current_a = cmd.current_limit_a;
        limits.max_power_kw = cmd.power_kw;
        hardware_->apply_power_command(cmd);
        hardware_->set_evse_limits(c.id, limits);
        last_mc_state_[slot->mc_id] = cmd.mc_closed ? ContactorState::Closed : ContactorState::Open;
        last_gc_state_[slot->gc_id] = cmd.gc_closed ? ContactorState::Closed : ContactorState::Open;

        if (is_home && charge_point_) {
            charge_point_->on_max_current_offered(c.id, static_cast<std::int32_t>(std::round(cmd.current_limit_a)));
            charge_point_->on_max_power_offered(
                c.id, static_cast<std::int32_t>(std::round(cmd.power_kw * 1000.0)));

            const bool constrained = g.ev_session_active && !local_fault && !info.disabled_by_csms &&
                                     (((dispatch.modules_assigned == 0 && dispatch.p_budget_kw > 0.0) ||
                                       (cmd.module_count == 0 && dispatch.modules_assigned > 0) ||
                                       (dispatch.p_set_kw + 1e-3 < dispatch.p_budget_kw)));
            power_constrained_[c.id] = constrained;
        } else {
            power_constrained_[c.id] = false;
        }

        if (local_fault && is_home && g.ev_session_active) {
            finish_transaction(c.id, ocpp::v16::Reason::PowerLoss, std::nullopt);
            hardware_->disable(c.id);
            const std::string reason = !info.fault_reason.empty() ? info.fault_reason : "LocalFault";
            if (charge_point_) {
                ocpp::v16::ErrorInfo err(reason, ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
                charge_point_->on_error(c.id, err);
            }
            {
                std::lock_guard<std::mutex> lock(state_mutex_);
                connector_faulted_[c.id] = true;
                connector_state_[c.id] = ConnectorState::Faulted;
            }
        }

        EVLOG_debug << "Planner dispatch slot " << slot->id << " gun=" << gun_for_slot
                    << " modules=" << cmd.module_count << " mask=0x" << std::hex
                    << static_cast<int>(cmd.module_mask) << std::dec << " I_lim=" << cmd.current_limit_a
                    << "A V_set=" << cmd.voltage_set_v << " GC=" << (cmd.gc_closed ? "C" : "O")
                    << " MC=" << (cmd.mc_closed ? "C" : "O");
    }
}

bool OcppAdapter::safety_trip_needed(const GunStatus& status) const {
    return !status.safety_ok || status.estop || status.earth_fault;
}

void OcppAdapter::enter_global_fault(const std::string& reason, ocpp::v16::Reason stop_reason) {
    if (global_fault_latched_.exchange(true)) {
        return;
    }
    global_fault_reason_ = reason;
    EVLOG_error << "Global fault latched: " << reason;
    for (const auto& c : cfg_.connectors) {
        finish_transaction(c.id, stop_reason, std::nullopt);
        hardware_->disable(c.id);
        if (charge_point_) {
            ocpp::v16::ErrorInfo err(reason, ocpp::v16::ChargePointErrorCode::PowerSwitchFailure, true);
            charge_point_->on_error(c.id, err);
        }
        {
            std::lock_guard<std::mutex> lock(state_mutex_);
            connector_faulted_[c.id] = true;
            connector_state_[c.id] = ConnectorState::Faulted;
        }
    }
}

void OcppAdapter::apply_zero_power_plan() {
    mc_open_pending_.clear();
    mc_open_request_time_.clear();
    gc_open_pending_.clear();
    gc_open_request_time_.clear();
    for (const auto& c : cfg_.connectors) {
        PowerCommand cmd;
        cmd.connector = c.id;
        cmd.module_count = 0;
        cmd.module_mask = 0;
        cmd.gc_closed = false;
        cmd.mc_closed = false;
        cmd.voltage_set_v = last_voltage_v_[c.id];
        cmd.current_limit_a = 0.0;
        cmd.power_kw = 0.0;
        last_current_limit_a_[c.id] = 0.0;
        last_module_alloc_[c.id] = 0;
        last_module_mask_cmd_[c.id] = 0;
        hardware_->apply_power_command(cmd);
        EvseLimits limits{};
        limits.max_voltage_v = cmd.voltage_set_v;
        limits.max_current_a = 0.0;
        limits.max_power_kw = 0.0;
        hardware_->set_evse_limits(c.id, limits);
        if (charge_point_) {
            charge_point_->on_max_current_offered(c.id, 0);
            charge_point_->on_max_power_offered(c.id, 0);
        }
    }
}

std::string OcppAdapter::make_session_id() const {
    std::random_device rd;
    std::mt19937_64 gen(rd());
    std::uniform_int_distribution<std::uint64_t> dist;

    std::stringstream ss;
    ss << cfg_.charge_point_id << "-" << std::hex << dist(gen);
    return ss.str();
}

void OcppAdapter::refresh_charging_profile_limits() {
    std::lock_guard<std::mutex> lock(plan_mutex_);
    if (!charge_point_) {
        return;
    }

    profile_current_limit_a_.clear();
    profile_power_limit_kw_.clear();
    profile_next_refresh_.reset();

    const auto schedules =
        charge_point_->get_all_composite_charging_schedules(3600, ocpp::v16::ChargingRateUnit::A);
    const auto now_utc = ocpp::DateTime().to_time_point();
    const auto now_steady = std::chrono::steady_clock::now();

    for (const auto& kv : schedules) {
        const int connector_id = kv.first;
        const auto& sched = kv.second;
        if (sched.chargingSchedulePeriod.empty()) {
            continue;
        }
        const auto start_tp = sched.startSchedule ? sched.startSchedule->to_time_point() : now_utc;
        const auto elapsed = now_utc - start_tp;
        const bool in_future = elapsed < std::chrono::seconds::zero();

        // Track next refresh boundary for future periods or duration end.
        auto consider_next_refresh = [&](const std::chrono::seconds& delta_from_now) {
            if (delta_from_now <= std::chrono::seconds::zero()) {
                return;
            }
            const auto candidate =
                now_steady + std::chrono::duration_cast<std::chrono::steady_clock::duration>(delta_from_now);
            if (!profile_next_refresh_ || candidate < *profile_next_refresh_) {
                profile_next_refresh_ = candidate;
            }
        };

        if (in_future) {
            consider_next_refresh(std::chrono::duration_cast<std::chrono::seconds>(-elapsed));
            continue;
        }

        const auto elapsed_s = std::chrono::duration_cast<std::chrono::seconds>(elapsed).count();
        if (sched.duration && elapsed_s >= *sched.duration) {
            continue;
        }

        const ocpp::v16::ChargingSchedulePeriod* active = nullptr;
        std::optional<int> next_start_s;
        for (const auto& period : sched.chargingSchedulePeriod) {
            if (period.startPeriod <= elapsed_s) {
                if (!active || period.startPeriod > active->startPeriod) {
                    active = &period;
                }
            } else {
                if (!next_start_s || period.startPeriod < *next_start_s) {
                    next_start_s = period.startPeriod;
                }
            }
        }

        if (next_start_s) {
            const auto next_tp = start_tp + std::chrono::seconds(*next_start_s);
            consider_next_refresh(std::chrono::duration_cast<std::chrono::seconds>(next_tp - now_utc));
        }
        if (sched.duration) {
            const auto end_tp = start_tp + std::chrono::seconds(*sched.duration);
            consider_next_refresh(std::chrono::duration_cast<std::chrono::seconds>(end_tp - now_utc));
        }

        if (!active) {
            continue;
        }

        if (sched.chargingRateUnit == ocpp::v16::ChargingRateUnit::A) {
            profile_current_limit_a_[connector_id] = active->limit;
        } else if (sched.chargingRateUnit == ocpp::v16::ChargingRateUnit::W) {
            profile_power_limit_kw_[connector_id] = active->limit / 1000.0;
        }
    }
}

void OcppAdapter::update_connector_state(std::int32_t connector, GunStatus status, bool has_session,
                                         bool tx_started, bool authorized, bool fault_active, bool disabled,
                                         bool post_stop_plugged, bool seamless_retry_active) {
    ConnectorState next = ConnectorState::Available;
    if (seamless_retry_active) {
        status.plugged_in = true;
        if (status.cp_state == 'U') {
            status.cp_state = 'B';
        }
    }
    const bool cp_known = status.cp_state != 'U';
    const bool vehicle_present =
        status.plugged_in || (cp_known && status.cp_state != 'A' && status.cp_state != 'U');
    const bool finishing_hint = post_stop_plugged || status.hlc_charge_complete;
    bool paused = false;
    bool constrained = false;
    {
        std::lock_guard<std::mutex> lock(plan_mutex_);
        paused = paused_evse_[connector];
        constrained = power_constrained_[connector];
    }
    if (fault_active || status.meter_stale) {
        next = ConnectorState::Faulted;
    } else if (disabled) {
        next = ConnectorState::SuspendedEVSE;
    } else if (has_session) {
        if (!tx_started) {
            next = ConnectorState::Preparing;
        } else if (!vehicle_present || status.hlc_charge_complete) {
            next = ConnectorState::Finishing;
        } else if (paused || constrained) {
            next = ConnectorState::SuspendedEVSE;
        } else if (!status.relay_closed) {
            const bool ev_requesting = cp_known ? (status.cp_state == 'C' || status.cp_state == 'D') : authorized;
            next = ev_requesting ? ConnectorState::SuspendedEVSE : ConnectorState::SuspendedEV;
        } else {
            next = ConnectorState::Charging;
        }
    } else if (finishing_hint && vehicle_present) {
        next = ConnectorState::Finishing;
    } else if (vehicle_present) {
        next = ConnectorState::Preparing;
    }

    ConnectorState current;
    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        current = connector_state_[connector];
    }
    if (next == current) {
        return;
    }

    switch (next) {
    case ConnectorState::Faulted:
        charge_point_->on_disabled(connector);
        break;
    case ConnectorState::Preparing:
        charge_point_->on_all_errors_cleared(connector);
        break;
    case ConnectorState::SuspendedEV:
        charge_point_->on_suspend_charging_ev(connector);
        break;
    case ConnectorState::SuspendedEVSE:
        charge_point_->on_suspend_charging_evse(connector);
        break;
    case ConnectorState::Finishing:
        charge_point_->on_suspend_charging_ev(connector);
        break;
    case ConnectorState::Charging:
        charge_point_->on_resume_charging(connector);
        break;
    case ConnectorState::Available:
        charge_point_->on_all_errors_cleared(connector);
        charge_point_->on_enabled(connector);
        break;
    }

    std::lock_guard<std::mutex> lock(state_mutex_);
    connector_state_[connector] = next;
}

std::chrono::steady_clock::time_point OcppAdapter::to_steady(std::chrono::system_clock::time_point t_sys) const {
    const auto now_sys = std::chrono::system_clock::now();
    const auto now_steady = std::chrono::steady_clock::now();
    return now_steady + std::chrono::duration_cast<std::chrono::steady_clock::duration>(t_sys - now_sys);
}

std::chrono::system_clock::time_point OcppAdapter::to_system(std::chrono::steady_clock::time_point t_steady) const {
    const auto now_sys = std::chrono::system_clock::now();
    const auto now_steady = std::chrono::steady_clock::now();
    return now_sys + std::chrono::duration_cast<std::chrono::system_clock::duration>(t_steady - now_steady);
}

int OcppAdapter::meter_interval_seconds_for_connector(std::int32_t connector) {
    std::lock_guard<std::mutex> lock(plan_mutex_);
    auto it = connector_meter_intervals_.find(connector);
    if (it != connector_meter_intervals_.end() && it->second > 0) {
        return it->second;
    }
    return std::max(1, cfg_.meter_sample_interval_s);
}

std::string OcppAdapter::token_source_to_string(AuthTokenSource src) {
    switch (src) {
    case AuthTokenSource::RFID: return "rfid";
    case AuthTokenSource::Autocharge: return "autocharge";
    case AuthTokenSource::RemoteStart: return "remotestart";
    default: return "unknown";
    }
}

AuthTokenSource OcppAdapter::token_source_from_string(const std::string& s) {
    if (s == "rfid") return AuthTokenSource::RFID;
    if (s == "autocharge") return AuthTokenSource::Autocharge;
    if (s == "remotestart") return AuthTokenSource::RemoteStart;
    return AuthTokenSource::RFID;
}

void OcppAdapter::set_auth_state(std::int32_t connector, AuthorizationState state) {
    AuthorizationState prev = AuthorizationState::Unknown;
    {
        std::lock_guard<std::mutex> lock(auth_mutex_);
        prev = auth_state_cache_[connector];
        if (prev == state) {
            return;
        }
        auth_state_cache_[connector] = state;
    }
    hardware_->set_authorization_state(connector, state);
}

bool OcppAdapter::token_matches_reservation(std::int32_t connector, const std::string& token,
                                            const std::optional<std::string>& parent_token) {
    std::lock_guard<std::mutex> lock(plan_mutex_);
    const auto trimmed = clamp_id_token(token);
    const auto req_it = reservation_required_tag_.find(connector);
    if (req_it == reservation_required_tag_.end()) {
        return true;
    }
    if (trimmed == req_it->second) {
        return true;
    }
    const auto parent_it = reservation_parent_tag_.find(connector);
    if (parent_it != reservation_parent_tag_.end() && parent_it->second) {
        if (trimmed == parent_it->second.value()) {
            return true;
        }
        if (parent_token && *parent_token == parent_it->second.value()) {
            return true;
        }
    }
    return false;
}

ocpp::v16::DataTransferResponse
OcppAdapter::handle_data_transfer_request(const ocpp::v16::DataTransferRequest& request) {
    ocpp::v16::DataTransferResponse resp;
    const std::string vendor = request.vendorId.get();
    const std::string message_id = request.messageId ? request.messageId->get() : "";

    auto known_vendor = [](const std::string& v) {
        static const std::set<std::string> vendors = {"iso15118",
                                                      "PnC",
                                                      "pnc",
                                                      "org.openchargealliance.iso15118",
                                                      "org.openchargealliance.ocpp",
                                                      "org.openchargealliance.iso15118pnc",
                                                      "org.openchargealliance.pnc"};
        return vendors.find(v) != vendors.end();
    };

    if (!known_vendor(vendor)) {
        resp.status = ocpp::v16::DataTransferStatus::UnknownVendorId;
        resp.data = std::string("Unsupported vendor: ") + vendor;
        EVLOG_warning << "DataTransfer request from CSMS rejected: unknown vendorId=" << vendor
                      << " messageId=" << message_id;
        return resp;
    }

    // Known vendor but no specific handler: respond cleanly with UnknownMessageId to avoid silent drop.
    resp.status = ocpp::v16::DataTransferStatus::UnknownMessageId;
    resp.data = std::string("No handler for vendor=") + vendor +
        (message_id.empty() ? "" : (" messageId=" + message_id));
    EVLOG_warning << "DataTransfer request for vendor=" << vendor << " messageId=" << message_id
                  << " is not implemented; responding UnknownMessageId";
    return resp;
}

void OcppAdapter::handle_configuration_key_change(const ocpp::v16::KeyValue& key_value) {
    const std::string key = key_value.key.get();
    const std::string value = key_value.value ? key_value.value->get() : "";
    EVLOG_info << "Configuration key changed by CSMS: " << key << "=" << value;

    auto parse_int = [&](int fallback) {
        try {
            return std::stoi(value);
        } catch (...) {
            return fallback;
        }
    };

    if (key == "MeterValueSampleInterval") {
        const int interval = std::max(1, parse_int(cfg_.meter_sample_interval_s));
        std::lock_guard<std::mutex> lock(plan_mutex_);
        for (const auto& c : cfg_.connectors) {
            connector_meter_intervals_[c.id] = interval;
        }
    } else if (key == "MinimumStatusDuration") {
        cfg_.minimum_status_duration_s = parse_int(cfg_.minimum_status_duration_s);
    } else if (key == "ConnectionTimeOut") {
        hardware_->set_connection_timeout(parse_int(0));
    } else if (key == "HeartbeatInterval") {
        cfg_.meter_keepalive_s = std::max(1, parse_int(cfg_.meter_keepalive_s));
    }
}

void OcppAdapter::persist_pending_tokens() {
    std::lock_guard<std::mutex> lock(session_mutex_);
    persist_pending_tokens_locked();
}

void OcppAdapter::persist_pending_tokens_locked() {
    try {
        nlohmann::json root;
        root["tokens"] = nlohmann::json::array();
        const auto now_sys = std::chrono::system_clock::now();
        for (const auto& kv : pending_tokens_) {
            for (const auto& pending : kv.second) {
                nlohmann::json entry;
                entry["connector"] = kv.first;
                entry["idToken"] = pending.token.id_token;
                entry["source"] = token_source_to_string(pending.token.source);
                entry["connectorHint"] = pending.token.connector_hint;
                entry["prevalidated"] = pending.token.prevalidated;
                entry["receivedAt"] =
                    std::chrono::duration_cast<std::chrono::seconds>(to_system(pending.token.received_at).time_since_epoch()).count();
                entry["expiresAt"] =
                    std::chrono::duration_cast<std::chrono::seconds>(to_system(pending.expires_at).time_since_epoch()).count();
                root["tokens"].push_back(entry);
            }
        }
        if (!pending_token_store_.empty()) {
            std::error_code ec;
            std::filesystem::create_directories(pending_token_store_.parent_path(), ec);
            std::ofstream out(pending_token_store_);
            if (out) {
                out << root.dump(2);
            }
        }
    } catch (const std::exception& e) {
        EVLOG_warning << "Failed to persist pending tokens: " << e.what();
    }
}

void OcppAdapter::persist_local_auth_cache_locked() {
    try {
        nlohmann::json root;
        root["entries"] = nlohmann::json::array();
        const auto now_sys = std::chrono::system_clock::now();
        for (const auto& kv : local_auth_cache_) {
            const auto sys_tp = to_system(kv.second);
            nlohmann::json entry;
            entry["idToken"] = kv.first;
            entry["lastSeen"] = std::chrono::duration_cast<std::chrono::seconds>(sys_tp.time_since_epoch()).count();
            root["entries"].push_back(entry);
        }
        if (!local_auth_cache_store_.empty()) {
            std::error_code ec;
            std::filesystem::create_directories(local_auth_cache_store_.parent_path(), ec);
            std::ofstream out(local_auth_cache_store_);
            if (out) {
                out << root.dump(2);
            }
        }
    } catch (const std::exception& e) {
        EVLOG_warning << "Failed to persist local auth cache: " << e.what();
    }
}

void OcppAdapter::load_pending_tokens_from_disk() {
    if (pending_token_store_.empty()) return;
    if (!std::filesystem::exists(pending_token_store_)) return;
    try {
        std::ifstream in(pending_token_store_);
        if (!in) return;
        nlohmann::json root;
        in >> root;
        if (!root.contains("tokens") || !root["tokens"].is_array()) return;
        const auto now_sys = std::chrono::system_clock::now();
        const auto now_steady = std::chrono::steady_clock::now();
        const auto ttl = std::chrono::seconds(std::max(1, cfg_.auth_wait_timeout_s));
        for (const auto& entry : root["tokens"]) {
            try {
                const int connector = entry.value("connector", 0);
                const std::string id = entry.value("idToken", "");
                if (connector <= 0 || id.empty()) continue;
                const std::string src_str = entry.value("source", "rfid");
                AuthToken token;
                token.id_token = id;
                token.source = token_source_from_string(src_str);
                token.connector_hint = entry.value("connectorHint", 0);
                token.prevalidated = entry.value("prevalidated", false);
                const auto recv_epoch = std::chrono::seconds(entry.value("receivedAt", 0LL));
                const auto exp_epoch = std::chrono::seconds(entry.value("expiresAt", 0LL));
                const auto recv_sys = std::chrono::system_clock::time_point(recv_epoch);
                const auto exp_sys = std::chrono::system_clock::time_point(exp_epoch);
                if (exp_sys <= now_sys) continue;
                const auto recv_delta = recv_sys - now_sys;
                const auto exp_delta = exp_sys - now_sys;
                token.received_at = now_steady + std::chrono::duration_cast<std::chrono::steady_clock::duration>(recv_delta);
                PendingToken pending;
                pending.token = token;
                // If stored expiry is missing, recompute via TTL from receive time
                pending.expires_at = exp_epoch.count() > 0
                    ? now_steady + std::chrono::duration_cast<std::chrono::steady_clock::duration>(exp_delta)
                    : token.received_at + ttl;
                pending_tokens_[connector].push_back(pending);
            } catch (...) {
                continue;
            }
        }
    } catch (const std::exception& e) {
        EVLOG_warning << "Failed to load pending tokens: " << e.what();
    }
}

void OcppAdapter::load_local_auth_cache_from_disk() {
    if (local_auth_cache_store_.empty()) return;
    if (!std::filesystem::exists(local_auth_cache_store_)) return;
    try {
        std::ifstream in(local_auth_cache_store_);
        if (!in) return;
        nlohmann::json root;
        in >> root;
        if (!root.contains("entries")) return;
        local_auth_cache_.clear();
        const auto now = std::chrono::steady_clock::now();
        for (const auto& entry : root["entries"]) {
            if (!entry.contains("idToken") || !entry.contains("lastSeen")) continue;
            const auto id = entry["idToken"].get<std::string>();
            const auto last = std::chrono::system_clock::time_point(std::chrono::seconds(entry["lastSeen"].get<int64_t>()));
            const auto steady = to_steady(last);
            if ((now - steady) < LOCAL_AUTH_CACHE_TTL) {
                local_auth_cache_[id] = steady;
            }
        }
    } catch (const std::exception& e) {
        EVLOG_warning << "Failed to load local auth cache: " << e.what();
    }
}

} // namespace charger


=== src/power_manager.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "power_manager.hpp"

#include <algorithm>
#include <cmath>
#include <limits>
#include <chrono>
#include <set>

namespace charger {

PowerManager::PowerManager(PlannerConfig cfg) : cfg_(std::move(cfg)) {}

void PowerManager::set_slots(std::vector<Slot> slots) {
    slots_ = std::move(slots);
    slot_lookup_.clear();
    for (const auto& s : slots_) {
        slot_lookup_[s.id] = s;
    }
}

void PowerManager::update_modules(const std::vector<ModuleState>& modules) {
    modules_.clear();
    for (const auto& m : modules) {
        modules_.emplace(m.id, m);
    }
}

void PowerManager::update_guns(const std::vector<GunState>& guns) {
    guns_.clear();
    for (const auto& g : guns) {
        guns_.emplace(g.id, g);
    }
}

std::vector<int> PowerManager::active_guns() const {
    std::vector<int> active;
    for (const auto& kv : guns_) {
        const auto& g = kv.second;
        if (!g.ev_session_active) continue;
        if (g.fsm_state == GunFsmState::Ready || g.fsm_state == GunFsmState::IslandReady ||
            g.fsm_state == GunFsmState::Charging) {
            active.push_back(g.id);
        }
    }
    return active;
}

Plan PowerManager::blank_plan() const {
    Plan plan;
    for (const auto& slot : slots_) {
        plan.mc_commands[slot.mc_id] = ContactorState::Closed;
        plan.gc_commands[slot.gc_id] = ContactorState::Open;
    }
    for (const auto& m : modules_) {
        plan.mn_commands[m.second.mn_id] = ContactorState::Open;
    }
    return plan;
}

const Slot* PowerManager::find_slot(int slot_id) const {
    auto it = std::find_if(slots_.begin(), slots_.end(), [&](const Slot& s) { return s.id == slot_id; });
    return it == slots_.end() ? nullptr : &(*it);
}

int PowerManager::count_healthy_modules_in_slot(int slot_id) const {
    int healthy = 0;
    for (const auto& kv : modules_) {
        if (kv.second.slot_id == slot_id && kv.second.healthy) {
            healthy++;
        }
    }
    return healthy;
}

int PowerManager::ideal_modules_for_gun(const GunState& g, double p_budget) const {
    if (p_budget <= 0.0) {
        return 0;
    }
    if (cfg_.module_power_kw <= 0.0) {
        return cfg_.min_modules_per_active_gun;
    }
    int n = 1;
    if (p_budget <= cfg_.ideal_low_factor * cfg_.module_power_kw) {
        n = 1;
    } else if (p_budget <= cfg_.ideal_high_factor * cfg_.module_power_kw) {
        n = 2;
    } else {
        n = static_cast<int>(std::ceil(p_budget / (cfg_.module_power_kw * cfg_.ideal_high_factor)));
        n = std::max(n, 2);
    }
    int max_by_config = std::max(1, cfg_.max_modules_per_gun);
    int max_by_cable = max_by_config;
    if (g.gun_power_limit_kw > 0.0) {
        max_by_cable = static_cast<int>(std::ceil(g.gun_power_limit_kw / cfg_.module_power_kw));
        max_by_cable = std::min(max_by_cable, max_by_config);
    }
    const int min_allowed = p_budget > 0.0 ? std::max(0, cfg_.min_modules_per_active_gun) : 0;
    n = std::clamp(n, min_allowed, std::max(min_allowed, max_by_cable));
    return n;
}

std::vector<std::string> PowerManager::select_modules_for_slot(const Slot& slot, int n_needed,
                                                               Plan& plan,
                                                               const std::vector<std::string>& preferred) const {
    std::vector<std::string> selected;
    if (n_needed <= 0) {
        for (const auto& mod_id : slot.modules) {
            const auto it = modules_.find(mod_id);
            if (it != modules_.end()) {
                plan.mn_commands[it->second.mn_id] = ContactorState::Open;
            }
        }
        return selected;
    }

    std::vector<std::string> ordered;
    std::set<std::string> already;
    for (const auto& pref : preferred) {
        if (std::find(slot.modules.begin(), slot.modules.end(), pref) != slot.modules.end()) {
            ordered.push_back(pref);
            already.insert(pref);
        }
    }
    for (const auto& mod_id : slot.modules) {
        if (!already.count(mod_id)) {
            ordered.push_back(mod_id);
        }
    }

    auto maybe_enable = [&](const std::string& mod_id) {
        const auto it = modules_.find(mod_id);
        if (it == modules_.end()) return;
        const auto& m = it->second;
        if (!m.healthy) {
            plan.mn_commands[m.mn_id] = ContactorState::Open;
            return;
        }
        if (static_cast<int>(selected.size()) < n_needed) {
            plan.mn_commands[m.mn_id] = ContactorState::Closed;
            selected.push_back(mod_id);
        } else {
            plan.mn_commands[m.mn_id] = ContactorState::Open;
        }
    };

    for (const auto& mod_id : ordered) {
        if (static_cast<int>(selected.size()) >= n_needed) break;
        maybe_enable(mod_id);
    }
    return selected;
}

std::vector<int> PowerManager::build_island_slots_for_gun(const GunState& g, int n_needed,
                                                          const std::set<int>& active_home_slots,
                                                          const std::set<int>& reserved_slots,
                                                          std::set<int>& claimed_slots) const {
    std::vector<int> slots;
    if (!find_slot(g.slot_id)) return slots;
    slots.push_back(g.slot_id);
    claimed_slots.insert(g.slot_id);
    if (!cfg_.allow_cross_slot_islands || n_needed <= count_healthy_modules_in_slot(g.slot_id)) {
        return slots;
    }

    int cw_edge = g.slot_id;
    int ccw_edge = g.slot_id;
    int available = count_healthy_modules_in_slot(g.slot_id);
    int remaining = std::max(0, n_needed - available);
    int cw_steps = 0;
    int ccw_steps = 0;

    while (remaining > 0 && (cw_steps < cfg_.max_island_radius || ccw_steps < cfg_.max_island_radius)) {
        bool expanded = false;
        if (cw_steps < cfg_.max_island_radius) {
            if (slot_lookup_.count(cw_edge)) {
                const int candidate = slot_lookup_.at(cw_edge).cw_id;
                if (slot_lookup_.count(candidate) && !claimed_slots.count(candidate) &&
                    !active_home_slots.count(candidate) &&
                    (!reserved_slots.count(candidate) || candidate == g.slot_id)) {
                    const int healthy = count_healthy_modules_in_slot(candidate);
                    if (healthy > 0) {
                        slots.push_back(candidate);
                        cw_edge = candidate;
                        claimed_slots.insert(candidate);
                        available += healthy;
                        remaining = std::max(0, n_needed - available);
                        expanded = true;
                    }
                }
                cw_steps++;
            } else {
                cw_steps = cfg_.max_island_radius;
            }
        }

        if (remaining <= 0) break;

        if (ccw_steps < cfg_.max_island_radius) {
            if (slot_lookup_.count(ccw_edge)) {
                const int candidate = slot_lookup_.at(ccw_edge).ccw_id;
                if (slot_lookup_.count(candidate) && !claimed_slots.count(candidate) &&
                    !active_home_slots.count(candidate) &&
                    (!reserved_slots.count(candidate) || candidate == g.slot_id)) {
                    const int healthy = count_healthy_modules_in_slot(candidate);
                    if (healthy > 0) {
                        slots.insert(slots.begin(), candidate);
                        ccw_edge = candidate;
                        claimed_slots.insert(candidate);
                        available += healthy;
                        remaining = std::max(0, n_needed - available);
                        expanded = true;
                    }
                }
                ccw_steps++;
            } else {
                ccw_steps = cfg_.max_island_radius;
            }
        }

        if (!expanded) {
            break;
        }
    }
    return slots;
}

std::vector<std::string> PowerManager::assign_modules_for_island(const std::vector<int>& slot_ids, int n_needed,
                                                                 Plan& plan,
                                                                 const std::vector<std::string>& preferred) const {
    std::vector<std::string> selected;
    int remaining = n_needed;
    for (int slot_id : slot_ids) {
        const auto* slot = find_slot(slot_id);
        if (!slot || remaining <= 0) {
            continue;
        }
        std::vector<std::string> slot_pref;
        for (const auto& id : preferred) {
            const auto it = modules_.find(id);
            if (it != modules_.end() && it->second.slot_id == slot_id) {
                slot_pref.push_back(id);
            }
        }
        auto slot_sel = select_modules_for_slot(*slot, remaining, plan, slot_pref);
        remaining -= static_cast<int>(slot_sel.size());
        selected.insert(selected.end(), slot_sel.begin(), slot_sel.end());
    }
    return selected;
}

std::map<int, double> PowerManager::compute_power_budgets(const std::vector<int>& active,
                                                          const std::map<int, double>& req_limited,
                                                          int healthy_modules) const {
    std::map<int, double> budgets;
    if (active.empty() || healthy_modules <= 0) {
        return budgets;
    }

    const double p_module_total = healthy_modules * cfg_.module_power_kw;
    const double system_cap = std::min(p_module_total, cfg_.grid_limit_kw);

    double total_req = 0.0;
    for (auto gid : active) {
        auto it = req_limited.find(gid);
        if (it != req_limited.end()) {
            total_req += it->second;
        }
    }

    if (total_req <= system_cap) {
        for (auto gid : active) {
            budgets[gid] = req_limited.at(gid);
        }
        return budgets;
    }

    std::set<int> remaining(active.begin(), active.end());
    double remaining_power = system_cap;
    while (!remaining.empty() && remaining_power > 0.0) {
        double total_weight = 0.0;
        for (auto gid : remaining) {
            const auto& g = guns_.at(gid);
            const double w = std::max(0.1, 1.0 + static_cast<double>(g.priority));
            total_weight += w;
        }

        bool any_capped = false;
        std::vector<int> remove_list;

        for (auto gid : remaining) {
            const double weight = std::max(0.1, 1.0 + static_cast<double>(guns_.at(gid).priority));
            const double share = remaining_power * (weight / total_weight);
            const double candidate = budgets[gid] + share;
            const double cap = req_limited.at(gid);
            if (candidate >= cap) {
                const double extra = cap - budgets[gid];
                budgets[gid] = cap;
                remaining_power = std::max(0.0, remaining_power - std::max(extra, 0.0));
                remove_list.push_back(gid);
                any_capped = true;
            } else {
                budgets[gid] = candidate;
            }
        }

        for (auto gid : remove_list) {
            remaining.erase(gid);
        }
        if (!any_capped) {
            remaining_power = 0.0;
        }
    }

    return budgets;
}

std::map<int, int> PowerManager::compute_module_allocation(const std::vector<int>& active,
                                                           const std::map<int, double>& budgets,
                                                           const std::map<int, int>& ideal,
                                                           int healthy_modules) const {
    std::map<int, int> n_modules = ideal;
    int total = 0;
    for (auto gid : active) {
        total += n_modules[gid];
    }
    if (total <= healthy_modules) {
        return n_modules;
    }

    auto reduce_once = [&](bool respect_minimum) -> bool {
        int chosen = -1;
        int from_count = -1;
        int best_priority = std::numeric_limits<int>::max();
        double best_budget = std::numeric_limits<double>::max();
        for (auto gid : active) {
            const double budget = budgets.at(gid);
            const auto& g = guns_.at(gid);
            const int min_allowed = (budget > 0.0 && respect_minimum)
                                        ? std::max(0, cfg_.min_modules_per_active_gun)
                                        : 0;
            if (n_modules[gid] <= min_allowed) continue;
            if (n_modules[gid] > from_count ||
                (n_modules[gid] == from_count && (g.priority < best_priority ||
                                                 (g.priority == best_priority && budget < best_budget)))) {
                chosen = gid;
                from_count = n_modules[gid];
                best_priority = g.priority;
                best_budget = budget;
            }
        }
        if (chosen == -1) return false;
        n_modules[chosen] -= 1;
        total -= 1;
        return true;
    };

    // First reduce down to per-gun minimums, then below if still over-subscribed.
    while (total > healthy_modules && reduce_once(true)) {
    }
    while (total > healthy_modules && reduce_once(false)) {
    }
    return n_modules;
}

Plan PowerManager::build_plan(const std::vector<int>& active, const std::map<int, double>& budgets,
                              const std::map<int, int>& modules_per_gun,
                              const std::set<int>& reserved_slots) {
    Plan plan = blank_plan();
    next_island_id_ = 1;

    std::set<int> active_home_slots;
    for (auto gid : active) {
        active_home_slots.insert(guns_.at(gid).slot_id);
    }

    std::set<int> claimed_slots = active_home_slots;
    std::map<int, std::vector<int>> island_slots;
    for (auto gid : active) {
        const auto& g = guns_.at(gid);
        const int n_needed = modules_per_gun.at(gid);
        if (n_needed <= 0) {
            island_slots[gid] = {g.slot_id};
            continue;
        }
        island_slots[gid] = build_island_slots_for_gun(g, n_needed, active_home_slots, reserved_slots, claimed_slots);
        if (island_slots[gid].empty()) {
            island_slots[gid].push_back(g.slot_id);
        }
    }

    for (auto gid : active) {
        const auto& g = guns_.at(gid);
        const auto* home_slot = find_slot(g.slot_id);
        if (!home_slot) {
            continue;
        }

        int n_needed = modules_per_gun.at(gid);
        if (!g.safety_ok || g.gc_welded || g.mc_welded) {
            n_needed = 0;
        }

        const auto slots_for_g = island_slots[gid];
        if (!g.mc_welded && !slots_for_g.empty() && n_needed > 0) {
            const auto* ccw_boundary = find_slot(slots_for_g.front());
            if (ccw_boundary) {
                const auto* prev_slot = find_slot(ccw_boundary->ccw_id);
                if (prev_slot) {
                    plan.mc_commands[prev_slot->mc_id] = ContactorState::Open;
                }
            }
            const auto* cw_boundary = find_slot(slots_for_g.back());
            if (cw_boundary) {
                plan.mc_commands[cw_boundary->mc_id] = ContactorState::Open;
            }
        }

        const auto preferred = last_module_ids_[gid];
        auto selected = assign_modules_for_island(slots_for_g, n_needed, plan, preferred);
        const int assigned = static_cast<int>(selected.size());
        if (assigned == 0) {
            plan.gc_commands[home_slot->gc_id] = ContactorState::Open;
        } else {
            plan.gc_commands[home_slot->gc_id] = ContactorState::Closed;
        }

        IslandState island;
        island.id = next_island_id_++;
        island.slot_ids = slots_for_g;
        island.gun_id = gid;
        island.module_ids = selected;

        const double p_cap_modules = assigned * cfg_.module_power_kw;
        const double p_budget = budgets.at(gid);
        const double p_set = std::min({p_budget, p_cap_modules,
                                       g.gun_power_limit_kw > 0.0 ? g.gun_power_limit_kw : p_cap_modules});
        const double min_v = g.min_voltage_v > 0.0 ? g.min_voltage_v : cfg_.min_voltage_v_for_div;
        const double max_v = g.max_voltage_v > 0.0 ? g.max_voltage_v : std::numeric_limits<double>::max();
        double target_v = g.ev_req_voltage_v > 0.0 ? g.ev_req_voltage_v : cfg_.default_voltage_v;
        if (target_v < min_v) target_v = min_v;
        if (target_v > max_v) target_v = max_v;
        island.p_set_kw = p_set;
        island.v_set_v = std::max(target_v, cfg_.min_voltage_v_for_div);

        GunDispatch dispatch;
        dispatch.gun_id = gid;
        dispatch.p_budget_kw = p_budget;
        dispatch.p_set_kw = p_set;
        dispatch.modules_assigned = assigned;
        dispatch.voltage_set_v = island.v_set_v;
        const double v_safe = std::max(cfg_.min_voltage_v_for_div, island.v_set_v);
        double i_target = (p_set * 1000.0) / v_safe;
        if (g.gun_current_limit_a > 0.0) {
            i_target = std::min(i_target, g.gun_current_limit_a);
        }
        const double prev = g.i_set_a;
        if (cfg_.ramp_step_a > 0.0) {
            if (i_target > prev + cfg_.ramp_step_a) i_target = prev + cfg_.ramp_step_a;
            if (i_target < prev - cfg_.ramp_step_a) i_target = prev - cfg_.ramp_step_a;
        }
        if (i_target < 0.0) i_target = 0.0;
        dispatch.current_limit_a = i_target;

        plan.islands.push_back(std::move(island));
        plan.guns.push_back(dispatch);
    }

    return plan;
}

Plan PowerManager::compute_plan() {
    const auto now = std::chrono::steady_clock::now();
    const auto active = active_guns();
    next_island_id_ = 1;
    if (active.empty()) {
        return blank_plan();
    }

    std::set<int> reserved_slots;
    for (const auto& kv : guns_) {
        const auto& g = kv.second;
        if (g.plugged_in || g.reserved) {
            reserved_slots.insert(g.slot_id);
        }
        if (g.fsm_state == GunFsmState::Charging) {
            reserved_slots.insert(g.slot_id);
        }
    }

    int healthy_modules = 0;
    for (const auto& m : modules_) {
        if (m.second.healthy) {
            healthy_modules++;
        }
    }
    if (healthy_modules <= 0) {
        return blank_plan();
    }

    std::map<int, double> req_limited;
    for (auto gid : active) {
        const auto& g = guns_.at(gid);
        double req = std::max(0.0, g.ev_req_power_kw);
        const double gun_cap = g.gun_power_limit_kw > 0.0 ? g.gun_power_limit_kw : req;
        req = std::min(req, gun_cap);
        req_limited[gid] = req;
    }

    const auto budgets = compute_power_budgets(active, req_limited, healthy_modules);
    if (budgets.empty()) {
        return blank_plan();
    }

    std::map<int, int> ideal_modules;
    for (auto gid : active) {
        const double p = budgets.at(gid);
        ideal_modules[gid] = ideal_modules_for_gun(guns_.at(gid), p);
    }

    const auto modules_per_gun = compute_module_allocation(active, budgets, ideal_modules, healthy_modules);
    auto plan = build_plan(active, budgets, modules_per_gun, reserved_slots);
    apply_hysteresis(plan, now);
    if (!validate_plan(plan)) {
        return blank_plan();
    }
    return plan;
}

void PowerManager::apply_hysteresis(Plan& plan, std::chrono::steady_clock::time_point now) {
    const auto hold = std::chrono::milliseconds(cfg_.min_module_hold_ms);
    for (auto& dispatch : plan.guns) {
        const int gid = dispatch.gun_id;
        const int prev = last_modules_assigned_[gid];
        const auto it_time = last_alloc_change_.find(gid);
        const bool have_time = it_time != last_alloc_change_.end() &&
            it_time->second.time_since_epoch().count() != 0;
        auto island_it = std::find_if(plan.islands.begin(), plan.islands.end(),
                                      [&](const IslandState& isl) {
                                          return isl.gun_id && isl.gun_id.value() == gid;
                                      });

        const bool within_hold = have_time && (now - it_time->second) < hold;
        const bool request_differs = dispatch.modules_assigned != prev;

        auto desired_modules = last_module_ids_[gid];
        bool previous_still_desired = !desired_modules.empty();
        for (const auto& mod_id : desired_modules) {
            const auto mit = modules_.find(mod_id);
            if (mit == modules_.end()) {
                previous_still_desired = false;
                break;
            }
            const auto cmd_it = plan.mn_commands.find(mit->second.mn_id);
            if (cmd_it == plan.mn_commands.end() || cmd_it->second != ContactorState::Closed) {
                previous_still_desired = false;
                break;
            }
        }

        if (request_differs && dispatch.modules_assigned > 0 && prev > 0 &&
            within_hold && previous_still_desired) {
            dispatch.modules_assigned = prev;
            if (island_it != plan.islands.end()) {
                island_it->module_ids = desired_modules;
            }
            const auto git = guns_.find(gid);
            const GunState* g_state = git != guns_.end() ? &git->second : nullptr;
            const double v_target = island_it != plan.islands.end() ? island_it->v_set_v : dispatch.voltage_set_v;
            const double p_cap = prev * cfg_.module_power_kw;
            const double p_set = std::min({dispatch.p_budget_kw, p_cap,
                                           g_state && g_state->gun_power_limit_kw > 0.0
                                               ? g_state->gun_power_limit_kw
                                               : p_cap});
            const double v_safe = std::max(cfg_.min_voltage_v_for_div, v_target);
            double i_target = v_safe > 0.0 ? (p_set * 1000.0) / v_safe : 0.0;
            if (g_state && g_state->gun_current_limit_a > 0.0) {
                i_target = std::min(i_target, g_state->gun_current_limit_a);
            }
            dispatch.p_set_kw = p_set;
            dispatch.current_limit_a = std::max(0.0, i_target);
            dispatch.voltage_set_v = v_target;

            if (island_it != plan.islands.end()) {
                island_it->p_set_kw = p_set;
            }
            for (const auto& mod_id : desired_modules) {
                const auto mit = modules_.find(mod_id);
                if (mit != modules_.end()) {
                    plan.mn_commands[mit->second.mn_id] = ContactorState::Closed;
                }
            }
            if (g_state) {
                if (const auto* slot = find_slot(g_state->slot_id)) {
                    plan.gc_commands[slot->gc_id] = prev > 0 ? ContactorState::Closed : ContactorState::Open;
                }
            }
        }

        if (island_it != plan.islands.end()) {
            last_module_ids_[gid] = island_it->module_ids;
        } else {
            last_module_ids_[gid].clear();
        }
        if (dispatch.modules_assigned != prev || !have_time) {
            last_alloc_change_[gid] = now;
            last_modules_assigned_[gid] = dispatch.modules_assigned;
        }
    }
}

bool PowerManager::validate_plan(const Plan& plan) const {
    std::set<std::string> used_modules;
    std::set<int> used_slots;
    std::map<int, int> gun_modules;
    for (const auto& d : plan.guns) {
        gun_modules[d.gun_id] = d.modules_assigned;
    }

    for (const auto& island : plan.islands) {
        if (island.gun_id) {
            const int gid = island.gun_id.value();
            if (gun_modules.count(gid) && gun_modules[gid] != static_cast<int>(island.module_ids.size())) {
                return false;
            }
        }
        for (int sid : island.slot_ids) {
            if (!used_slots.insert(sid).second) {
                return false;
            }
        }
        for (const auto& mid : island.module_ids) {
            if (!used_modules.insert(mid).second) {
                return false;
            }
            auto mit = modules_.find(mid);
            if (mit == modules_.end() || !mit->second.healthy) {
                return false;
            }
        }
    }
    return true;
}

} // namespace charger


=== src/power_module_controller.cpp ===
// SPDX-License-Identifier: Apache-2.0
#include "power_module_controller.hpp"

#include <algorithm>
#include <array>
#include <chrono>
#include <cmath>
#include <cctype>
#include <cstring>
#include <map>
#include <mutex>
#include <utility>
#include <vector>

#include <everest/logging.hpp>

#ifdef __linux__
#include <fcntl.h>
#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <unistd.h>
#else
// Minimal definitions to allow non-Linux builds to compile; no CAN I/O.
struct can_frame {
    uint32_t can_id;
    uint8_t can_dlc;
    uint8_t data[8];
};
constexpr uint32_t CAN_EFF_FLAG = 0x80000000U;
constexpr uint32_t CAN_EFF_MASK = 0x1FFFFFFFU;
#endif

namespace charger {

namespace {
constexpr uint16_t MAXWELL_PROT_NO = 0x060;
constexpr uint8_t MAXWELL_FUNC_SET = 0x03;
constexpr uint8_t MAXWELL_FUNC_READ = 0x10;
constexpr uint8_t MAXWELL_TYPE_FLOAT = 0x41;
constexpr uint8_t MAXWELL_TYPE_INT = 0x42;
constexpr uint8_t MAXWELL_OK = 0xF0;
constexpr uint8_t MAXWELL_CONTROLLER_ADDR = 0xF0;
constexpr std::chrono::milliseconds MAXWELL_PERIODIC_TX(500);
constexpr std::chrono::milliseconds MAXWELL_POLL_PERIOD(500);
constexpr std::chrono::seconds TELEMETRY_STALE(2);

struct ModuleSetpoint {
    bool enable{false};
    double voltage_v{0.0};
    double current_a{0.0};
    double power_kw{0.0};
};

struct ModuleTelemetryState {
    bool healthy{false};
    bool fault{false};
    double temperature_c{0.0};
    double voltage_v{0.0};
    double current_a{0.0};
    uint32_t alarms{0};
    uint8_t healthy_mask{0};
    uint8_t fault_mask{0};
    std::chrono::steady_clock::time_point last_update{};
};

void map_maxwell_alarms(uint32_t alarms, uint8_t& healthy_mask, uint8_t& fault_mask) {
    if (alarms == 0) {
        healthy_mask = 0x03;
        fault_mask = 0x00;
        return;
    }
    // Severe faults that should mark modules unusable
    constexpr uint32_t SEVERE_MASK =
        (1u << 0) |  (1u << 1) |  (1u << 3) |  (1u << 4) |  (1u << 5) |
        (1u << 7) |  (1u << 8) |  (1u << 9) |  (1u << 14) | (1u << 16) |
        (1u << 17) | (1u << 22) | (1u << 27) | (1u << 28) | (1u << 30) |
        (1u << 31);
    if ((alarms & SEVERE_MASK) != 0) {
        healthy_mask = 0x00;
        fault_mask = 0x03; // both modules in slot
    } else {
        healthy_mask = 0x03;
        fault_mask = 0x00;
    }
}

int popcount(uint8_t v) {
    int count = 0;
    while (v) {
        count += (v & 0x1);
        v >>= 1U;
    }
    return count;
}

uint32_t encode_float_be(float value) {
    uint32_t raw = 0;
    std::memcpy(&raw, &value, sizeof(float));
    return raw;
}

float decode_float_be(const uint8_t* buf) {
    uint32_t raw = (static_cast<uint32_t>(buf[0]) << 24) |
                   (static_cast<uint32_t>(buf[1]) << 16) |
                   (static_cast<uint32_t>(buf[2]) << 8) |
                   (static_cast<uint32_t>(buf[3]));
    float val = 0.0f;
    std::memcpy(&val, &raw, sizeof(float));
    return val;
}

uint32_t decode_u32_be(const uint8_t* buf) {
    return (static_cast<uint32_t>(buf[0]) << 24) |
           (static_cast<uint32_t>(buf[1]) << 16) |
           (static_cast<uint32_t>(buf[2]) << 8) |
           static_cast<uint32_t>(buf[3]);
}

class CanChannel {
public:
    explicit CanChannel(std::string iface) : iface_(std::move(iface)) {
#ifdef __linux__
        sock_ = ::socket(PF_CAN, SOCK_RAW, CAN_RAW);
        if (sock_ < 0) {
            EVLOG_error << "Failed to open CAN socket on " << iface_;
            return;
        }
        const int on = 1;
        ::setsockopt(sock_, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &on, sizeof(on));
        struct ifreq ifr {};
        std::strncpy(ifr.ifr_name, iface_.c_str(), IFNAMSIZ - 1);
        if (::ioctl(sock_, SIOCGIFINDEX, &ifr) < 0) {
            EVLOG_error << "CAN ioctl failed for " << iface_;
            ::close(sock_);
            sock_ = -1;
            return;
        }
        struct sockaddr_can addr {};
        addr.can_family = AF_CAN;
        addr.can_ifindex = ifr.ifr_ifindex;
        struct can_filter filter {};
        filter.can_id = (static_cast<uint32_t>(MAXWELL_PROT_NO) << 20) | CAN_EFF_FLAG;
        filter.can_mask = (static_cast<uint32_t>(0x1FF) << 20) | CAN_EFF_FLAG;
        ::setsockopt(sock_, SOL_CAN_RAW, CAN_RAW_FILTER, &filter, sizeof(filter));
        if (::bind(sock_, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0) {
            EVLOG_error << "Failed to bind CAN socket on " << iface_;
            ::close(sock_);
            sock_ = -1;
            return;
        }
        const int flags = ::fcntl(sock_, F_GETFL, 0);
        ::fcntl(sock_, F_SETFL, flags | O_NONBLOCK);
#endif
    }

    ~CanChannel() {
#ifdef __linux__
        if (sock_ >= 0) {
            ::close(sock_);
        }
#endif
    }

    bool valid() const { return sock_ >= 0; }

    bool send(const can_frame& frame) {
#ifdef __linux__
        if (sock_ < 0) return false;
        const auto n = ::write(sock_, &frame, sizeof(frame));
        return n == sizeof(frame);
#else
        (void)frame;
        return false;
#endif
    }

    bool recv(can_frame& frame) {
#ifdef __linux__
        if (sock_ < 0) return false;
        const auto n = ::recv(sock_, &frame, sizeof(frame), MSG_DONTWAIT);
        return n == sizeof(frame);
#else
        (void)frame;
        return false;
#endif
    }

private:
    std::string iface_;
    int sock_{-1};
};

class ModuleDriver {
public:
    explicit ModuleDriver(ModuleSpec spec) : spec_(std::move(spec)) {}
    virtual ~ModuleDriver() = default;

    virtual void apply(const ModuleSetpoint& sp) = 0;
    virtual void poll() = 0;

    const ModuleSpec& spec() const { return spec_; }
    const ModuleTelemetryState& telemetry() const { return telemetry_; }

protected:
    ModuleSpec spec_;
    ModuleTelemetryState telemetry_{};
};

class MaxwellModuleDriver : public ModuleDriver {
public:
    MaxwellModuleDriver(const ModuleSpec& spec, std::shared_ptr<CanChannel> channel) :
        ModuleDriver(spec), channel_(std::move(channel)) {
        last_sent_.voltage_v = 0.0;
    }

    void apply(const ModuleSetpoint& sp) override {
        desired_ = sp;
        const auto now = std::chrono::steady_clock::now();
        if (!channel_ || !channel_->valid() || spec_.address < 0) {
            return;
        }
        const auto cmd_interval = std::chrono::milliseconds(std::max(100, spec_.cmd_interval_ms));
        const bool state_change = (sp.enable != last_sent_.enable) ||
                                  (std::fabs(sp.voltage_v - last_sent_.voltage_v) > 0.5) ||
                                  (std::fabs(sp.current_a - last_sent_.current_a) > 0.5) ||
                                  (std::fabs(sp.power_kw - last_sent_.power_kw) > 0.5);
        const bool periodic = (now - last_tx_) >= cmd_interval;
        if (!state_change && !periodic) {
            return;
        }
        if (sp.enable) {
            send_set_float(0x0021, static_cast<float>(sp.voltage_v));
            const double rated_current = spec_.rated_current_a > 0.0
                                             ? spec_.rated_current_a
                                             : (spec_.rated_power_kw > 0.0 && sp.voltage_v > 1.0
                                                    ? (spec_.rated_power_kw * 1000.0) / sp.voltage_v
                                                    : 0.0);
            const float frac = rated_current > 0.0
                                   ? static_cast<float>(std::clamp(sp.current_a / rated_current, 0.0, 1.0))
                                   : 1.0f;
            send_set_float(0x0022, frac);
        if (spec_.rated_power_kw > 0.0 && sp.power_kw > 0.0) {
            const float p_frac =
                static_cast<float>(std::clamp(sp.power_kw / spec_.rated_power_kw, 0.0, 1.0));
            send_set_float(0x0020, p_frac);
        }
        send_set_int(0x0030, 0x00000000); // startup
    } else {
        send_set_int(0x0030, 0x00010000); // shutdown
    }
    last_sent_ = sp;
    last_tx_ = now;
}

    void poll() override {
        if (!channel_ || !channel_->valid() || spec_.address < 0) {
            return;
        }
        const auto now = std::chrono::steady_clock::now();
        const auto poll_interval = std::chrono::milliseconds(std::max(100, spec_.poll_interval_ms));
        if (!spec_.broadcast && (now - last_poll_) >= poll_interval) {
            send_read(0x0001); // voltage
            send_read(0x0002); // current
            send_read(0x0004); // DC board temperature
            send_read(0x0040); // alarm/status
            last_poll_ = now;
        }
        can_frame frame{};
        while (channel_->recv(frame)) {
            handle_frame(frame);
        }
    }

private:
    uint32_t build_can_id() const {
        uint32_t id = 0;
        id |= (static_cast<uint32_t>(MAXWELL_PROT_NO & 0x1FF) << 20);
        id |= (1U << 19); // PTP
        uint32_t dst = static_cast<uint32_t>(spec_.address & 0xFF);
        if (spec_.broadcast) {
            if (spec_.group <= 7) {
                dst = 0xFE;
            } else {
                const int ext_group = std::min(60, std::max(0, spec_.group));
                dst = static_cast<uint32_t>(0xFD - ext_group);
            }
        }
        id |= (dst << 11);
        id |= (static_cast<uint32_t>(MAXWELL_CONTROLLER_ADDR) << 3);
        id |= (static_cast<uint32_t>(spec_.group & 0x07));
        return id | CAN_EFF_FLAG;
    }

    void send_set_float(uint16_t reg, float value) {
        can_frame frame{};
        frame.can_id = build_can_id();
        frame.can_dlc = 8;
        frame.data[0] = MAXWELL_FUNC_SET;
        frame.data[1] = 0x00;
        frame.data[2] = static_cast<uint8_t>((reg >> 8) & 0xFF);
        frame.data[3] = static_cast<uint8_t>(reg & 0xFF);
        const uint32_t raw = encode_float_be(value);
        frame.data[4] = static_cast<uint8_t>((raw >> 24) & 0xFF);
        frame.data[5] = static_cast<uint8_t>((raw >> 16) & 0xFF);
        frame.data[6] = static_cast<uint8_t>((raw >> 8) & 0xFF);
        frame.data[7] = static_cast<uint8_t>(raw & 0xFF);
        channel_->send(frame);
    }

    void send_set_int(uint16_t reg, uint32_t value) {
        can_frame frame{};
        frame.can_id = build_can_id();
        frame.can_dlc = 8;
        frame.data[0] = MAXWELL_FUNC_SET;
        frame.data[1] = 0x00;
        frame.data[2] = static_cast<uint8_t>((reg >> 8) & 0xFF);
        frame.data[3] = static_cast<uint8_t>(reg & 0xFF);
        frame.data[4] = static_cast<uint8_t>((value >> 24) & 0xFF);
        frame.data[5] = static_cast<uint8_t>((value >> 16) & 0xFF);
        frame.data[6] = static_cast<uint8_t>((value >> 8) & 0xFF);
        frame.data[7] = static_cast<uint8_t>(value & 0xFF);
        channel_->send(frame);
    }

    void send_read(uint16_t reg) {
        can_frame frame{};
        frame.can_id = build_can_id();
        frame.can_dlc = 8;
        frame.data[0] = MAXWELL_FUNC_READ;
        frame.data[1] = 0x00;
        frame.data[2] = static_cast<uint8_t>((reg >> 8) & 0xFF);
        frame.data[3] = static_cast<uint8_t>(reg & 0xFF);
        frame.data[4] = 0x00;
        frame.data[5] = 0x00;
        frame.data[6] = 0x00;
        frame.data[7] = 0x00;
        channel_->send(frame);
    }

    void handle_frame(const can_frame& frame) {
        const uint32_t id = frame.can_id & CAN_EFF_MASK;
        const uint16_t prot = static_cast<uint16_t>((id >> 20) & 0x1FF);
        const uint8_t src_addr = static_cast<uint8_t>((id >> 3) & 0xFF);
        if (prot != MAXWELL_PROT_NO || src_addr != static_cast<uint8_t>(spec_.address & 0xFF)) {
            return;
        }
        if (frame.can_dlc < 8) {
            return;
        }
        const uint8_t type = frame.data[0];
        const uint8_t status = frame.data[1];
        const uint16_t reg = static_cast<uint16_t>((frame.data[2] << 8) | frame.data[3]);
        if (status != MAXWELL_OK) {
            telemetry_.fault = true;
            telemetry_.healthy = false;
            telemetry_.last_update = std::chrono::steady_clock::now();
            return;
        }
        const auto now = std::chrono::steady_clock::now();
        if (type == MAXWELL_TYPE_FLOAT) {
            const float val = decode_float_be(&frame.data[4]);
            if (reg == 0x0001) {
                telemetry_.voltage_v = val;
            } else if (reg == 0x0002) {
                telemetry_.current_a = val;
            } else if (reg == 0x0004) {
                telemetry_.temperature_c = val;
            }
        } else if (type == MAXWELL_TYPE_INT) {
            const uint32_t val = decode_u32_be(&frame.data[4]);
            if (reg == 0x0040) {
                telemetry_.alarms = val;
                telemetry_.fault = val != 0;
                uint8_t healthy_mask = 0x00;
                uint8_t fault_mask = 0x00;
                map_maxwell_alarms(val, healthy_mask, fault_mask);
                telemetry_.healthy_mask = healthy_mask;
                telemetry_.fault_mask = fault_mask;
            }
        }
        telemetry_.last_update = now;
        if (telemetry_.fault_mask != 0) {
            telemetry_.fault = true;
        }
        telemetry_.healthy = !telemetry_.fault;
    }

    ModuleSetpoint last_sent_{};
    ModuleSetpoint desired_{};
    std::chrono::steady_clock::time_point last_tx_{};
    std::chrono::steady_clock::time_point last_poll_{};
    std::shared_ptr<CanChannel> channel_;
};

class PowerModuleControllerImpl {
public:
    PowerModuleControllerImpl() = default;
    explicit PowerModuleControllerImpl(std::vector<ModuleSpec> specs) { set_modules(std::move(specs)); }

    void set_modules(std::vector<ModuleSpec> specs) {
        std::lock_guard<std::mutex> lock(mtx_);
        modules_.clear();
        slot_index_.clear();
        channels_.clear();
        for (auto& spec : specs) {
            if (spec.type.empty()) {
                continue;
            }
            if (spec.address < 0) {
                EVLOG_warning << "Skipping module " << spec.id << " (slot " << spec.slot_id
                              << ") because no address was provided";
                continue;
            }
            std::string type_lower = spec.type;
            std::transform(type_lower.begin(), type_lower.end(), type_lower.begin(),
                           [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
            spec.type = type_lower;
            auto chan = get_or_create_channel(spec.can_interface);
            ModuleRuntime rt;
            rt.spec = spec;
            rt.driver = make_driver(spec, chan);
            if (!rt.driver) {
                EVLOG_warning << "No driver registered for module type '" << spec.type
                              << "'; module " << spec.id << " will be treated as unavailable";
                continue;
            }
            const size_t idx = modules_.size();
            modules_.push_back(std::move(rt));
            slot_index_[spec.slot_id].push_back(idx);
        }
    }

    void apply(const ModuleCommandRequest& req) {
        std::lock_guard<std::mutex> lock(mtx_);
        const auto it = slot_index_.find(req.slot_id);
        if (it == slot_index_.end()) {
            return;
        }
        const auto& indices = it->second;
        int enabled = 0;
        for (auto idx : indices) {
            if (idx >= modules_.size()) continue;
            const auto& spec = modules_[idx].spec;
            if (req.enable && ((req.mask >> spec.slot_index) & 0x1)) {
                enabled++;
            }
        }
        const double current_per_module = (enabled > 0) ? (req.current_a / static_cast<double>(enabled)) : 0.0;
        const double power_per_module = (enabled > 0) ? (req.power_kw / static_cast<double>(enabled)) : 0.0;
        for (auto idx : indices) {
            if (idx >= modules_.size()) continue;
            auto& mod = modules_[idx];
            const bool active = req.enable && ((req.mask >> mod.spec.slot_index) & 0x1);
            ModuleSetpoint sp;
            sp.enable = active;
            sp.voltage_v = req.voltage_v;
            sp.current_a = active ? current_per_module : 0.0;
            sp.power_kw = active ? power_per_module : 0.0;
            if (mod.driver) {
                mod.driver->apply(sp);
            }
        }
    }

    ModuleHealthSnapshot snapshot(int slot_id) const {
        std::lock_guard<std::mutex> lock(mtx_);
        ModuleHealthSnapshot snap{};
        const auto it = slot_index_.find(slot_id);
        if (it == slot_index_.end()) {
            return snap;
        }
        snap.valid = true;
        const auto now = std::chrono::steady_clock::now();
        for (auto idx : it->second) {
            if (idx >= modules_.size()) continue;
            const auto& mod = modules_[idx];
            const auto& telem = mod.driver ? mod.driver->telemetry() : ModuleTelemetryState{};
            const bool fresh = telem.last_update.time_since_epoch().count() > 0 &&
                               (now - telem.last_update) <= TELEMETRY_STALE;
            const bool healthy = fresh && !telem.fault && telem.fault_mask == 0 && telem.alarms == 0;
            const uint8_t bit = static_cast<uint8_t>(1U << mod.spec.slot_index);
            if (healthy) {
                if (telem.healthy_mask) {
                    snap.healthy_mask |= telem.healthy_mask;
                } else {
                    snap.healthy_mask |= bit;
                }
            } else {
                if (telem.fault_mask) {
                    snap.fault_mask |= telem.fault_mask;
                } else {
                    snap.fault_mask |= bit;
                }
            }
            if (mod.spec.slot_index < static_cast<int>(snap.temperatures_c.size())) {
                snap.temperatures_c[mod.spec.slot_index] = telem.temperature_c;
            }
        }
        return snap;
    }

    void poll() {
        std::lock_guard<std::mutex> lock(mtx_);
        for (auto& mod : modules_) {
            if (mod.driver) {
                mod.driver->poll();
            }
        }
    }

private:
    struct ModuleRuntime {
        ModuleSpec spec;
        std::unique_ptr<ModuleDriver> driver;
    };

    std::shared_ptr<CanChannel> get_or_create_channel(const std::string& iface) {
        const auto it = channels_.find(iface);
        if (it != channels_.end()) {
            return it->second;
        }
        auto chan = std::make_shared<CanChannel>(iface);
        channels_[iface] = chan;
        return chan;
    }

    static std::unique_ptr<ModuleDriver> make_driver(const ModuleSpec& spec,
                                                     const std::shared_ptr<CanChannel>& channel) {
        if (spec.type == "maxwell-mxr" || spec.type == "maxwell") {
            return std::make_unique<MaxwellModuleDriver>(spec, channel);
        }
        return nullptr;
    }

    mutable std::mutex mtx_;
    std::vector<ModuleRuntime> modules_;
    std::map<int, std::vector<size_t>> slot_index_;
    std::map<std::string, std::shared_ptr<CanChannel>> channels_;
};
} // namespace

struct PowerModuleController::Impl {
    PowerModuleControllerImpl impl;
};

PowerModuleController::PowerModuleController() : impl_(std::make_unique<Impl>()) {}

PowerModuleController::PowerModuleController(const std::vector<ModuleSpec>& specs) :
    impl_(std::make_unique<Impl>()) {
    impl_->impl.set_modules(specs);
}

PowerModuleController::~PowerModuleController() = default;

void PowerModuleController::set_modules(const std::vector<ModuleSpec>& specs) {
    if (!impl_) return;
    impl_->impl.set_modules(specs);
}

void PowerModuleController::apply_command(const ModuleCommandRequest& req) {
    if (!impl_) return;
    impl_->impl.apply(req);
}

ModuleHealthSnapshot PowerModuleController::snapshot_for_slot(int slot_id) const {
    if (!impl_) return {};
    return impl_->impl.snapshot(slot_id);
}

void PowerModuleController::poll() {
    if (!impl_) return;
    impl_->impl.poll();
}

} // namespace charger


